"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.importAttributesOrAssertions = exports.importAssertions = exports.importAttributes = void 0;

var _acorn = _interopRequireWildcard(require("acorn"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var leftCurlyBrace = "{".charCodeAt(0);
var space = " ".charCodeAt(0);
var withKeyword = "with";
var assertKeyword = "assert";
var FUNC_STATEMENT = 1,
    FUNC_HANGING_STATEMENT = 2,
    FUNC_NULLABLE_ID = 4;
var importAttributes = plugin({
  keyword: "with"
});
exports.importAttributes = importAttributes;
var importAssertions = plugin({
  keyword: "assert"
});
exports.importAssertions = importAssertions;
var importAttributesOrAssertions = plugin({
  keyword: "with-assert"
});
exports.importAttributesOrAssertions = importAttributesOrAssertions;

function plugin(options) {
  return function (Parser) {
    return pluginImpl(options, Parser);
  };
}

function pluginImpl(options, Parser) {
  // Use supplied version acorn version if present, to avoid
  // reference mismatches due to different acorn versions. This
  // allows this plugin to be used with Rollup which supplies
  // its own internal version of acorn and thereby sidesteps
  // the package manager.
  var acorn = Parser.acorn || _acorn;
  var tt = acorn.tokTypes,
      TokenType = acorn.TokenType;
  var keyword = options.keyword;
  var isWithKeyword = keyword.includes(withKeyword);
  var isAssertKeyword = keyword.includes(assertKeyword);
  var isWithOrAssertKeyword = isWithKeyword && isAssertKeyword;
  return (
    /*#__PURE__*/
    function (_Parser) {
      _inherits(_class, _Parser);

      function _class() {
        var _getPrototypeOf2;

        var _this;

        _classCallCheck(this, _class);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(_class)).call.apply(_getPrototypeOf2, [this].concat(args)));
        _this.withToken = isWithKeyword && new TokenType(withKeyword);
        _this.assertToken = isAssertKeyword && new TokenType(assertKeyword);
        return _this;
      }

      _createClass(_class, [{
        key: "_codeAt",
        value: function _codeAt(i) {
          return this.input.charCodeAt(i);
        }
      }, {
        key: "_eat",
        value: function _eat(t) {
          if (this.type !== t) {
            this.unexpected();
          }

          this.next();
        }
      }, {
        key: "_matchKeywordToken",
        value: function _matchKeywordToken() {
          return isWithOrAssertKeyword && (this.type === this.withToken || this.type === this.assertToken) || isWithKeyword && this.type === this.withToken || isAssertKeyword && this.type === this.assertToken;
        }
      }, {
        key: "_getProperty",
        value: function _getProperty() {
          if (isWithOrAssertKeyword) {
            return this.type === this.withToken ? "attributes" : "assertions";
          }

          return isWithKeyword ? "attributes" : "assertions";
        }
      }, {
        key: "readToken",
        value: function readToken(code) {
          var i = 0;
          var keyword;
          var token;

          if (isWithOrAssertKeyword) {
            if (this.input.slice(this.pos, this.pos + withKeyword.length) === withKeyword) {
              keyword = withKeyword;
              token = this.withToken;
            } else if (this.input.slice(this.pos, this.pos + assertKeyword.length) === assertKeyword) {
              keyword = assertKeyword;
              token = this.assertToken;
            } else {
              return _get(_getPrototypeOf(_class.prototype), "readToken", this).call(this, code);
            }

            i += keyword.length;
          } else {
            keyword = isWithKeyword ? withKeyword : assertKeyword;
            token = isWithKeyword ? this.withToken : this.assertToken;

            for (; i < keyword.length; i++) {
              if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {
                return _get(_getPrototypeOf(_class.prototype), "readToken", this).call(this, code);
              }
            }
          } // ensure that the keyword is at the correct location
          // ie `with{...` or `with {...`


          for (;; i++) {
            if (this._codeAt(this.pos + i) === leftCurlyBrace) {
              // Found '{'
              break;
            } else if (this._codeAt(this.pos + i) === space) {
              // white space is allowed between `with` and `{`, so continue.
              continue;
            } else {
              return _get(_getPrototypeOf(_class.prototype), "readToken", this).call(this, code);
            }
          } // If we're inside a dynamic import expression we'll parse
          // the `with` keyword as a standard object property name
          // ie `import(""./foo.json", { with: { type: "json" } })`


          if (this.type.label === "{") {
            return _get(_getPrototypeOf(_class.prototype), "readToken", this).call(this, code);
          }

          this.pos += keyword.length;
          return this.finishToken(token);
        }
      }, {
        key: "parseDynamicImport",
        value: function parseDynamicImport(node) {
          this.next(); // skip `(`
          // Parse node.source.

          node.source = this.parseMaybeAssign();

          if (this.eat(tt.comma)) {
            var expr = this.parseExpression();
            node.arguments = [expr];
          }

          this._eat(tt.parenR);

          return this.finishNode(node, "ImportExpression");
        } // ported from acorn/src/statement.js pp.parseExport

      }, {
        key: "parseExport",
        value: function parseExport(node, exports) {
          this.next(); // export * from '...'

          if (this.eat(tt.star)) {
            if (this.options.ecmaVersion >= 11) {
              if (this.eatContextual("as")) {
                node.exported = this.parseIdent(true);
                this.checkExport(exports, node.exported.name, this.lastTokStart);
              } else {
                node.exported = null;
              }
            }

            this.expectContextual("from");

            if (this.type !== tt.string) {
              this.unexpected();
            }

            node.source = this.parseExprAtom();

            if (this._matchKeywordToken()) {
              var property = this._getProperty();

              this.next();
              var attributes = this.parseImportAttributes();

              if (attributes) {
                node[property] = attributes;
              }
            }

            this.semicolon();
            return this.finishNode(node, "ExportAllDeclaration");
          }

          if (this.eat(tt._default)) {
            // export default ...
            this.checkExport(exports, "default", this.lastTokStart);
            var isAsync;

            if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {
              var fNode = this.startNode();
              this.next();

              if (isAsync) {
                this.next();
              }

              node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
            } else if (this.type === tt._class) {
              var cNode = this.startNode();
              node.declaration = this.parseClass(cNode, "nullableID");
            } else {
              node.declaration = this.parseMaybeAssign();
              this.semicolon();
            }

            return this.finishNode(node, "ExportDefaultDeclaration");
          } // export var|const|let|function|class ...


          if (this.shouldParseExportStatement()) {
            node.declaration = this.parseStatement(null);

            if (node.declaration.type === "VariableDeclaration") {
              this.checkVariableExport(exports, node.declaration.declarations);
            } else {
              this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);
            }

            node.specifiers = [];
            node.source = null;
          } else {
            // export { x, y as z } [from '...']
            node.declaration = null;
            node.specifiers = this.parseExportSpecifiers(exports);

            if (this.eatContextual("from")) {
              if (this.type !== tt.string) {
                this.unexpected();
              }

              node.source = this.parseExprAtom();

              if (this._matchKeywordToken()) {
                var _property = this._getProperty();

                this.next();

                var _attributes = this.parseImportAttributes();

                if (_attributes) {
                  node[_property] = _attributes;
                }
              }
            } else {
              for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
                // check for keywords used as local names
                var spec = list[i];
                this.checkUnreserved(spec.local); // check if export is defined

                this.checkLocalExport(spec.local);
              }

              node.source = null;
            }

            this.semicolon();
          }

          return this.finishNode(node, "ExportNamedDeclaration");
        }
      }, {
        key: "parseImport",
        value: function parseImport(node) {
          this.next(); // import '...'

          if (this.type === tt.string) {
            node.specifiers = [];
            node.source = this.parseExprAtom();
          } else {
            node.specifiers = this.parseImportSpecifiers();
            this.expectContextual("from");
            node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();
          }

          if (this._matchKeywordToken()) {
            var property = this._getProperty();

            this.next();
            var attributes = this.parseImportAttributes();

            if (attributes) {
              node[property] = attributes;
            }
          }

          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
      }, {
        key: "parseImportAttributes",
        value: function parseImportAttributes() {
          this._eat(tt.braceL);

          var attrs = this.parsewithEntries();

          this._eat(tt.braceR);

          return attrs;
        }
      }, {
        key: "parsewithEntries",
        value: function parsewithEntries() {
          var attrs = [];
          var attrNames = new Set();

          do {
            if (this.type === tt.braceR) {
              break;
            }

            var node = this.startNode(); // parse withionKey : IdentifierName, StringLiteral

            var withionKeyNode = void 0;

            if (this.type === tt.string) {
              withionKeyNode = this.parseLiteral(this.value);
            } else {
              withionKeyNode = this.parseIdent(true);
            }

            this.next();
            node.key = withionKeyNode; // check if we already have an entry for an attribute
            // if a duplicate entry is found, throw an error
            // for now this logic will come into play only when someone declares `type` twice

            if (attrNames.has(node.key.name)) {
              this.raise(this.pos, "Duplicated key in attributes");
            }

            attrNames.add(node.key.name);

            if (this.type !== tt.string) {
              this.raise(this.pos, "Only string is supported as an attribute value");
            }

            node.value = this.parseLiteral(this.value);
            attrs.push(this.finishNode(node, "ImportAttribute"));
          } while (this.eat(tt.comma));

          return attrs;
        }
      }]);

      return _class;
    }(Parser)
  );
}