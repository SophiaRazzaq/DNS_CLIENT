'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var flatten = require('flat');

var camelcase = require('camelcase');

var decamelize = require('decamelize');

var isPlainObj = require('is-plain-obj');

function isAlias(key, alias) {
  // TODO Switch to Object.values one Node.js 6 is dropped
  return Object.keys(alias).some(function (id) {
    return [].concat(alias[id]).indexOf(key) !== -1;
  });
}

function hasDefaultValue(key, value, defaults) {
  return value === defaults[key];
}

function isCamelCased(key, argv) {
  return /[A-Z]/.test(key) && camelcase(key) === key && // Is it camel case?
  argv[decamelize(key, '-')] != null; // Is the standard version defined?
}

function keyToFlag(key) {
  return key.length === 1 ? "-".concat(key) : "--".concat(key);
}

function parseCommand(cmd) {
  var extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, ' ');
  var splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
  var bregex = /\.*[\][<>]/g;
  var firstCommand = splitCommand.shift();

  if (!firstCommand) {
    throw new Error("No command found in: ".concat(cmd));
  }

  var parsedCommand = {
    cmd: firstCommand.replace(bregex, ''),
    demanded: [],
    optional: []
  };
  splitCommand.forEach(function (cmd, i) {
    var variadic = false;
    cmd = cmd.replace(/\s/g, '');

    if (/\.+[\]>]/.test(cmd) && i === splitCommand.length - 1) {
      variadic = true;
    }

    if (/^\[/.test(cmd)) {
      parsedCommand.optional.push({
        cmd: cmd.replace(bregex, '').split('|'),
        variadic: variadic
      });
    } else {
      parsedCommand.demanded.push({
        cmd: cmd.replace(bregex, '').split('|'),
        variadic: variadic
      });
    }
  });
  return parsedCommand;
}

function unparseOption(key, value, unparsed) {
  if (typeof value === 'string') {
    unparsed.push(keyToFlag(key), value);
  } else if (value === true) {
    unparsed.push(keyToFlag(key));
  } else if (value === false) {
    unparsed.push("--no-".concat(key));
  } else if (Array.isArray(value)) {
    value.forEach(function (item) {
      return unparseOption(key, item, unparsed);
    });
  } else if (isPlainObj(value)) {
    var flattened = flatten(value, {
      safe: true
    });

    for (var flattenedKey in flattened) {
      if (!isCamelCased(flattenedKey, flattened)) {
        unparseOption("".concat(key, ".").concat(flattenedKey), flattened[flattenedKey], unparsed);
      }
    } // Fallback case (numbers and other types)

  } else if (value != null) {
    unparsed.push(keyToFlag(key), "".concat(value));
  }
}

function unparsePositional(argv, options, unparsed) {
  var knownPositional = []; // Unparse command if set, collecting all known positional arguments
  // e.g.: build <first> <second> <rest...>

  if (options.command) {
    var _options$command$matc = options.command.match(/[^<[]*/),
        cmd = _options$command$matc[0],
        index = _options$command$matc.index;

    var _parseCommand = parseCommand("foo ".concat(options.command.substr(index + cmd.length))),
        demanded = _parseCommand.demanded,
        optional = _parseCommand.optional; // Push command (can be a deep command)


    unparsed.push.apply(unparsed, _toConsumableArray(cmd.trim().split(/\s+/))); // Push positional arguments

    [].concat(_toConsumableArray(demanded), _toConsumableArray(optional)).forEach(function (_ref) {
      var cmds = _ref.cmd,
          variadic = _ref.variadic;
      knownPositional.push.apply(knownPositional, _toConsumableArray(cmds));
      var cmd = cmds[0];
      var args = (variadic ? argv[cmd] || [] : [argv[cmd]]).filter(function (arg) {
        return arg != null;
      }).map(function (arg) {
        return "".concat(arg);
      });
      unparsed.push.apply(unparsed, _toConsumableArray(args));
    });
  } // Unparse unkown positional arguments


  argv._ && unparsed.push.apply(unparsed, _toConsumableArray(argv._.slice(knownPositional.length)));
  return knownPositional;
}

function unparseOptions(argv, options, knownPositional, unparsed) {
  for (var _i = 0, _Object$keys = Object.keys(argv); _i < _Object$keys.length; _i++) {
    var key = _Object$keys[_i];
    var value = argv[key];

    if ( // Remove positional arguments
    knownPositional.includes(key) || // Remove special _, -- and $0
    ['_', '--', '$0'].includes(key) || // Remove aliases
    isAlias(key, options.alias) || // Remove default values
    hasDefaultValue(key, value, options["default"]) || // Remove camel-cased
    isCamelCased(key, argv)) {
      continue;
    }

    unparseOption(key, argv[key], unparsed);
  }
}

function unparseEndOfOptions(argv, options, unparsed) {
  // Unparse ending (--) arguments if set
  argv['--'] && unparsed.push.apply(unparsed, ['--'].concat(_toConsumableArray(argv['--'])));
} // ------------------------------------------------------------


function unparser(argv, options) {
  options = Object.assign({
    alias: {},
    "default": {},
    command: null
  }, options);
  var unparsed = []; // Unparse known & unknown positional arguments (foo <first> <second> [rest...])
  // All known positional will be returned so that they are not added as flags

  var knownPositional = unparsePositional(argv, options, unparsed); // Unparse option arguments (--foo hello --bar hi)

  unparseOptions(argv, options, knownPositional, unparsed); // Unparse "end-of-options" arguments (stuff after " -- ")

  unparseEndOfOptions(argv, options, unparsed);
  return unparsed;
}

module.exports = unparser;