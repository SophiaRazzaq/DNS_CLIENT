'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});

var path = require('path');

var pm = require('picomatch');

function _interopDefaultLegacy(e) {
  return e && _typeof(e) === 'object' && 'default' in e ? e : {
    'default': e
  };
}

var pm__default =
/*#__PURE__*/
_interopDefaultLegacy(pm);

var addExtension = function addExtension(filename) {
  var ext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '.js';
  var result = "".concat(filename);
  if (!path.extname(filename)) result += ext;
  return result;
};

var WalkerBase =
/*#__PURE__*/
function () {
  function WalkerBase() {
    _classCallCheck(this, WalkerBase);

    WalkerBase.prototype.__init.call(this);

    WalkerBase.prototype.__init2.call(this);

    WalkerBase.prototype.__init3.call(this);

    WalkerBase.prototype.__init4.call(this);
  }

  _createClass(WalkerBase, [{
    key: "__init",
    value: function __init() {
      this.should_skip = false;
    }
  }, {
    key: "__init2",
    value: function __init2() {
      this.should_remove = false;
    }
  }, {
    key: "__init3",
    value: function __init3() {
      this.replacement = null;
    }
  }, {
    key: "__init4",
    value: function __init4() {
      var _this = this;

      this.context = {
        skip: function skip() {
          return _this.should_skip = true;
        },
        remove: function remove() {
          return _this.should_remove = true;
        },
        replace: function replace(node) {
          return _this.replacement = node;
        }
      };
    }
  }, {
    key: "replace",
    value: function replace(parent, prop, index, node) {
      if (parent) {
        if (index !== null) {
          parent[prop][index] = node;
        } else {
          parent[prop] = node;
        }
      }
    }
  }, {
    key: "remove",
    value: function remove(parent, prop, index) {
      if (parent) {
        if (index !== null) {
          parent[prop].splice(index, 1);
        } else {
          delete parent[prop];
        }
      }
    }
  }]);

  return WalkerBase;
}();

var SyncWalkerClass =
/*#__PURE__*/
function (_WalkerBase) {
  _inherits(SyncWalkerClass, _WalkerBase);

  function SyncWalkerClass(walker) {
    var _this2;

    _classCallCheck(this, SyncWalkerClass);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(SyncWalkerClass).call(this));
    _this2.enter = walker.enter;
    _this2.leave = walker.leave;
    return _this2;
  }

  _createClass(SyncWalkerClass, [{
    key: "visit",
    value: function visit(node, parent, enter, leave, prop, index) {
      if (node) {
        if (enter) {
          var _should_skip = this.should_skip;
          var _should_remove = this.should_remove;
          var _replacement = this.replacement;
          this.should_skip = false;
          this.should_remove = false;
          this.replacement = null;
          enter.call(this.context, node, parent, prop, index);

          if (this.replacement) {
            node = this.replacement;
            this.replace(parent, prop, index, node);
          }

          if (this.should_remove) {
            this.remove(parent, prop, index);
          }

          var skipped = this.should_skip;
          var removed = this.should_remove;
          this.should_skip = _should_skip;
          this.should_remove = _should_remove;
          this.replacement = _replacement;
          if (skipped) return node;
          if (removed) return null;
        }

        for (var key in node) {
          var value = node[key];

          if (_typeof(value) !== "object") {
            continue;
          } else if (Array.isArray(value)) {
            for (var i = 0; i < value.length; i += 1) {
              if (value[i] !== null && typeof value[i].type === 'string') {
                if (!this.visit(value[i], node, enter, leave, key, i)) {
                  // removed
                  i--;
                }
              }
            }
          } else if (value !== null && typeof value.type === "string") {
            this.visit(value, node, enter, leave, key, null);
          }
        }

        if (leave) {
          var _replacement2 = this.replacement;
          var _should_remove2 = this.should_remove;
          this.replacement = null;
          this.should_remove = false;
          leave.call(this.context, node, parent, prop, index);

          if (this.replacement) {
            node = this.replacement;
            this.replace(parent, prop, index, node);
          }

          if (this.should_remove) {
            this.remove(parent, prop, index);
          }

          var _removed = this.should_remove;
          this.replacement = _replacement2;
          this.should_remove = _should_remove2;
          if (_removed) return null;
        }
      }

      return node;
    }
  }]);

  return SyncWalkerClass;
}(WalkerBase);

function walk(ast, walker) {
  var instance = new SyncWalkerClass(walker);
  return instance.visit(ast, null, walker.enter, walker.leave);
}

var extractors = {
  ArrayPattern: function ArrayPattern(names, param) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = param.elements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var element = _step.value;
        if (element) extractors[element.type](names, element);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  },
  AssignmentPattern: function AssignmentPattern(names, param) {
    extractors[param.left.type](names, param.left);
  },
  Identifier: function Identifier(names, param) {
    names.push(param.name);
  },
  MemberExpression: function MemberExpression() {},
  ObjectPattern: function ObjectPattern(names, param) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = param.properties[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var prop = _step2.value;

        // @ts-ignore Typescript reports that this is not a valid type
        if (prop.type === 'RestElement') {
          extractors.RestElement(names, prop);
        } else {
          extractors[prop.value.type](names, prop.value);
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  },
  RestElement: function RestElement(names, param) {
    extractors[param.argument.type](names, param.argument);
  }
};

var extractAssignedNames = function extractAssignedNames(param) {
  var names = [];
  extractors[param.type](names, param);
  return names;
};

var blockDeclarations = {
  "const": true,
  "let": true
};

var Scope =
/*#__PURE__*/
function () {
  function Scope() {
    var _this3 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Scope);

    this.parent = options.parent;
    this.isBlockScope = !!options.block;
    this.declarations = Object.create(null);

    if (options.params) {
      options.params.forEach(function (param) {
        extractAssignedNames(param).forEach(function (name) {
          _this3.declarations[name] = true;
        });
      });
    }
  }

  _createClass(Scope, [{
    key: "addDeclaration",
    value: function addDeclaration(node, isBlockDeclaration, isVar) {
      var _this4 = this;

      if (!isBlockDeclaration && this.isBlockScope) {
        // it's a `var` or function node, and this
        // is a block scope, so we need to go up
        this.parent.addDeclaration(node, isBlockDeclaration, isVar);
      } else if (node.id) {
        extractAssignedNames(node.id).forEach(function (name) {
          _this4.declarations[name] = true;
        });
      }
    }
  }, {
    key: "contains",
    value: function contains(name) {
      return this.declarations[name] || (this.parent ? this.parent.contains(name) : false);
    }
  }]);

  return Scope;
}();

var attachScopes = function attachScopes(ast) {
  var propertyName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'scope';
  var scope = new Scope();
  walk(ast, {
    enter: function enter(n, parent) {
      var node = n; // function foo () {...}
      // class Foo {...}

      if (/(Function|Class)Declaration/.test(node.type)) {
        scope.addDeclaration(node, false, false);
      } // var foo = 1


      if (node.type === 'VariableDeclaration') {
        var kind = node.kind;
        var isBlockDeclaration = blockDeclarations[kind];
        node.declarations.forEach(function (declaration) {
          scope.addDeclaration(declaration, isBlockDeclaration, true);
        });
      }

      var newScope; // create new function scope

      if (/Function/.test(node.type)) {
        var func = node;
        newScope = new Scope({
          parent: scope,
          block: false,
          params: func.params
        }); // named function expressions - the name is considered
        // part of the function's scope

        if (func.type === 'FunctionExpression' && func.id) {
          newScope.addDeclaration(func, false, false);
        }
      } // create new for scope


      if (/For(In|Of)?Statement/.test(node.type)) {
        newScope = new Scope({
          parent: scope,
          block: true
        });
      } // create new block scope


      if (node.type === 'BlockStatement' && !/Function/.test(parent.type)) {
        newScope = new Scope({
          parent: scope,
          block: true
        });
      } // catch clause has its own block scope


      if (node.type === 'CatchClause') {
        newScope = new Scope({
          parent: scope,
          params: node.param ? [node.param] : [],
          block: true
        });
      }

      if (newScope) {
        Object.defineProperty(node, propertyName, {
          value: newScope,
          configurable: true
        });
        scope = newScope;
      }
    },
    leave: function leave(n) {
      var node = n;
      if (node[propertyName]) scope = scope.parent;
    }
  });
  return scope;
}; // Helper since Typescript can't detect readonly arrays with Array.isArray


function isArray(arg) {
  return Array.isArray(arg);
}

function ensureArray(thing) {
  if (isArray(thing)) return thing;
  if (thing == null) return [];
  return [thing];
}

var normalizePath = function normalizePath(filename) {
  return filename.split(path.win32.sep).join(path.posix.sep);
};

function getMatcherString(id, resolutionBase) {
  if (resolutionBase === false || path.isAbsolute(id) || id.startsWith('*')) {
    return normalizePath(id);
  } // resolve('') is valid and will default to process.cwd()


  var basePath = normalizePath(path.resolve(resolutionBase || '')) // escape all possible (posix + win) path characters that might interfere with regex
  .replace(/[-^$*+?.()|[\]{}]/g, '\\$&'); // Note that we use posix.join because:
  // 1. the basePath has been normalized to use /
  // 2. the incoming glob (id) matcher, also uses /
  // otherwise Node will force backslash (\) on windows

  return path.posix.join(basePath, normalizePath(id));
}

var createFilter = function createFilter(include, exclude, options) {
  var resolutionBase = options && options.resolve;

  var getMatcher = function getMatcher(id) {
    return id instanceof RegExp ? id : {
      test: function test(what) {
        // this refactor is a tad overly verbose but makes for easy debugging
        var pattern = getMatcherString(id, resolutionBase);
        var fn = pm__default["default"](pattern, {
          dot: true
        });
        var result = fn(what);
        return result;
      }
    };
  };

  var includeMatchers = ensureArray(include).map(getMatcher);
  var excludeMatchers = ensureArray(exclude).map(getMatcher);
  return function result(id) {
    if (typeof id !== 'string') return false;
    if (/\0/.test(id)) return false;
    var pathId = normalizePath(id);

    for (var i = 0; i < excludeMatchers.length; ++i) {
      var matcher = excludeMatchers[i];
      if (matcher.test(pathId)) return false;
    }

    for (var _i = 0; _i < includeMatchers.length; ++_i) {
      var _matcher = includeMatchers[_i];
      if (_matcher.test(pathId)) return true;
    }

    return !includeMatchers.length;
  };
};

var reservedWords = 'break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public';
var builtins = 'arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl';
var forbiddenIdentifiers = new Set("".concat(reservedWords, " ").concat(builtins).split(' '));
forbiddenIdentifiers.add('');

var makeLegalIdentifier = function makeLegalIdentifier(str) {
  var identifier = str.replace(/-(\w)/g, function (_, letter) {
    return letter.toUpperCase();
  }).replace(/[^$_a-zA-Z0-9]/g, '_');

  if (/\d/.test(identifier[0]) || forbiddenIdentifiers.has(identifier)) {
    identifier = "_".concat(identifier);
  }

  return identifier || '_';
};

function stringify(obj) {
  return (JSON.stringify(obj) || 'undefined').replace(/[\u2028\u2029]/g, function (_char) {
    return "\\u".concat("000".concat(_char.charCodeAt(0).toString(16)).slice(-4));
  });
}

function serializeArray(arr, indent, baseIndent) {
  var output = '[';
  var separator = indent ? "\n".concat(baseIndent).concat(indent) : '';

  for (var i = 0; i < arr.length; i++) {
    var key = arr[i];
    output += "".concat(i > 0 ? ',' : '').concat(separator).concat(serialize(key, indent, baseIndent + indent));
  }

  return "".concat(output).concat(indent ? "\n".concat(baseIndent) : '', "]");
}

function serializeObject(obj, indent, baseIndent) {
  var output = '{';
  var separator = indent ? "\n".concat(baseIndent).concat(indent) : '';
  var entries = Object.entries(obj);

  for (var i = 0; i < entries.length; i++) {
    var _entries$i = _slicedToArray(entries[i], 2),
        key = _entries$i[0],
        value = _entries$i[1];

    var stringKey = makeLegalIdentifier(key) === key ? key : stringify(key);
    output += "".concat(i > 0 ? ',' : '').concat(separator).concat(stringKey, ":").concat(indent ? ' ' : '').concat(serialize(value, indent, baseIndent + indent));
  }

  return "".concat(output).concat(indent ? "\n".concat(baseIndent) : '', "}");
}

function serialize(obj, indent, baseIndent) {
  if (_typeof(obj) === 'object' && obj !== null) {
    if (Array.isArray(obj)) return serializeArray(obj, indent, baseIndent);
    if (obj instanceof Date) return "new Date(".concat(obj.getTime(), ")");
    if (obj instanceof RegExp) return obj.toString();
    return serializeObject(obj, indent, baseIndent);
  }

  if (typeof obj === 'number') {
    if (obj === Infinity) return 'Infinity';
    if (obj === -Infinity) return '-Infinity';
    if (obj === 0) return 1 / obj === Infinity ? '0' : '-0';
    if (obj !== obj) return 'NaN'; // eslint-disable-line no-self-compare
  }

  if (_typeof(obj) === 'symbol') {
    var key = Symbol.keyFor(obj);
    if (key !== undefined) return "Symbol.for(".concat(stringify(key), ")");
  }

  if (typeof obj === 'bigint') return "".concat(obj, "n");
  return stringify(obj);
}

var dataToEsm = function dataToEsm(data) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var t = options.compact ? '' : 'indent' in options ? options.indent : '\t';

  var _ = options.compact ? '' : ' ';

  var n = options.compact ? '' : '\n';
  var declarationType = options.preferConst ? 'const' : 'var';

  if (options.namedExports === false || _typeof(data) !== 'object' || Array.isArray(data) || data instanceof Date || data instanceof RegExp || data === null) {
    var code = serialize(data, options.compact ? null : t, '');
    var magic = _ || (/^[{[\-\/]/.test(code) ? '' : ' '); // eslint-disable-line no-useless-escape

    return "export default".concat(magic).concat(code, ";");
  }

  var namedExportCode = '';
  var defaultExportRows = [];

  for (var _i2 = 0, _Object$entries = Object.entries(data); _i2 < _Object$entries.length; _i2++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];

    if (key === makeLegalIdentifier(key)) {
      if (options.objectShorthand) defaultExportRows.push(key);else defaultExportRows.push("".concat(key, ":").concat(_).concat(key));
      namedExportCode += "export ".concat(declarationType, " ").concat(key).concat(_, "=").concat(_).concat(serialize(value, options.compact ? null : t, ''), ";").concat(n);
    } else {
      defaultExportRows.push("".concat(stringify(key), ":").concat(_).concat(serialize(value, options.compact ? null : t, '')));
    }
  }

  return "".concat(namedExportCode, "export default").concat(_, "{").concat(n).concat(t).concat(defaultExportRows.join(",".concat(n).concat(t))).concat(n, "};").concat(n);
}; // TODO: remove this in next major


var index = {
  addExtension: addExtension,
  attachScopes: attachScopes,
  createFilter: createFilter,
  dataToEsm: dataToEsm,
  extractAssignedNames: extractAssignedNames,
  makeLegalIdentifier: makeLegalIdentifier,
  normalizePath: normalizePath
};
exports.addExtension = addExtension;
exports.attachScopes = attachScopes;
exports.createFilter = createFilter;
exports.dataToEsm = dataToEsm;
exports["default"] = index;
exports.extractAssignedNames = extractAssignedNames;
exports.makeLegalIdentifier = makeLegalIdentifier;
exports.normalizePath = normalizePath;