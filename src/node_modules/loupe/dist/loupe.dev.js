"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;

var __commonJS = function __commonJS(cb, mod) {
  return function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
      exports: {}
    }).exports, mod), mod.exports;
  };
};

var __export = function __export(target, all) {
  for (var name in all) {
    __defProp(target, name, {
      get: all[name],
      enumerable: true
    });
  }
};

var __copyProps = function __copyProps(to, from, except, desc) {
  if (from && _typeof(from) === "object" || typeof from === "function") {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      var _loop = function _loop() {
        var key = _step.value;
        if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
          get: function get() {
            return from[key];
          },
          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
      };

      for (var _iterator = __getOwnPropNames(from)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        _loop();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  return to;
};

var __toCommonJS = function __toCommonJS(mod) {
  return __copyProps(__defProp({}, "__esModule", {
    value: true
  }), mod);
}; // (disabled):util


var require_util = __commonJS({
  "(disabled):util": function disabledUtil() {}
}); // src/index.ts


var src_exports = {};

__export(src_exports, {
  custom: function custom() {
    return _custom;
  },
  "default": function _default() {
    return src_default;
  },
  inspect: function inspect() {
    return _inspect;
  },
  registerConstructor: function registerConstructor() {
    return _registerConstructor;
  },
  registerStringTag: function registerStringTag() {
    return _registerStringTag;
  }
});

module.exports = __toCommonJS(src_exports); // src/helpers.ts

var ansiColors = {
  bold: ["1", "22"],
  dim: ["2", "22"],
  italic: ["3", "23"],
  underline: ["4", "24"],
  // 5 & 6 are blinking
  inverse: ["7", "27"],
  hidden: ["8", "28"],
  strike: ["9", "29"],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ["30", "39"],
  red: ["31", "39"],
  green: ["32", "39"],
  yellow: ["33", "39"],
  blue: ["34", "39"],
  magenta: ["35", "39"],
  cyan: ["36", "39"],
  white: ["37", "39"],
  brightblack: ["30;1", "39"],
  brightred: ["31;1", "39"],
  brightgreen: ["32;1", "39"],
  brightyellow: ["33;1", "39"],
  brightblue: ["34;1", "39"],
  brightmagenta: ["35;1", "39"],
  brightcyan: ["36;1", "39"],
  brightwhite: ["37;1", "39"],
  grey: ["90", "39"]
};
var styles = {
  special: "cyan",
  number: "yellow",
  bigint: "yellow",
  "boolean": "yellow",
  undefined: "grey",
  "null": "bold",
  string: "green",
  symbol: "green",
  date: "magenta",
  regexp: "red"
};
var truncator = "\u2026";

function colorise(value, styleType) {
  var color = ansiColors[styles[styleType]] || ansiColors[styleType] || "";

  if (!color) {
    return String(value);
  }

  return "\x1B[".concat(color[0], "m").concat(String(value), "\x1B[").concat(color[1], "m");
}

function normaliseOptions() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$showHidden = _ref.showHidden,
      showHidden = _ref$showHidden === void 0 ? false : _ref$showHidden,
      _ref$depth = _ref.depth,
      depth = _ref$depth === void 0 ? 2 : _ref$depth,
      _ref$colors = _ref.colors,
      colors = _ref$colors === void 0 ? false : _ref$colors,
      _ref$customInspect = _ref.customInspect,
      customInspect = _ref$customInspect === void 0 ? true : _ref$customInspect,
      _ref$showProxy = _ref.showProxy,
      showProxy = _ref$showProxy === void 0 ? false : _ref$showProxy,
      _ref$maxArrayLength = _ref.maxArrayLength,
      maxArrayLength = _ref$maxArrayLength === void 0 ? Infinity : _ref$maxArrayLength,
      _ref$breakLength = _ref.breakLength,
      breakLength = _ref$breakLength === void 0 ? Infinity : _ref$breakLength,
      _ref$seen = _ref.seen,
      seen = _ref$seen === void 0 ? [] : _ref$seen,
      _ref$truncate = _ref.truncate,
      truncate2 = _ref$truncate === void 0 ? Infinity : _ref$truncate,
      _ref$stylize = _ref.stylize,
      stylize = _ref$stylize === void 0 ? String : _ref$stylize;

  var inspect2 = arguments.length > 1 ? arguments[1] : undefined;
  var options = {
    showHidden: Boolean(showHidden),
    depth: Number(depth),
    colors: Boolean(colors),
    customInspect: Boolean(customInspect),
    showProxy: Boolean(showProxy),
    maxArrayLength: Number(maxArrayLength),
    breakLength: Number(breakLength),
    truncate: Number(truncate2),
    seen: seen,
    inspect: inspect2,
    stylize: stylize
  };

  if (options.colors) {
    options.stylize = colorise;
  }

  return options;
}

function isHighSurrogate(_char) {
  return _char >= "\uD800" && _char <= "\uDBFF";
}

function truncate(string, length) {
  var tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : truncator;
  string = String(string);
  var tailLength = tail.length;
  var stringLength = string.length;

  if (tailLength > length && stringLength > tailLength) {
    return tail;
  }

  if (stringLength > length && stringLength > tailLength) {
    var end = length - tailLength;

    if (end > 0 && isHighSurrogate(string[end - 1])) {
      end = end - 1;
    }

    return "".concat(string.slice(0, end)).concat(tail);
  }

  return string;
}

function inspectList(list, options, inspectItem) {
  var separator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ", ";
  inspectItem = inspectItem || options.inspect;
  var size = list.length;
  if (size === 0) return "";
  var originalLength = options.truncate;
  var output = "";
  var peek = "";
  var truncated = "";

  for (var i = 0; i < size; i += 1) {
    var last = i + 1 === list.length;
    var secondToLast = i + 2 === list.length;
    truncated = "".concat(truncator, "(").concat(list.length - i, ")");
    var value = list[i];
    options.truncate = originalLength - output.length - (last ? 0 : separator.length);
    var string = peek || inspectItem(value, options) + (last ? "" : separator);
    var nextLength = output.length + string.length;
    var truncatedLength = nextLength + truncated.length;

    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {
      break;
    }

    if (!last && !secondToLast && truncatedLength > originalLength) {
      break;
    }

    peek = last ? "" : inspectItem(list[i + 1], options) + (secondToLast ? "" : separator);

    if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {
      break;
    }

    output += string;

    if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = "".concat(truncator, "(").concat(list.length - i - 1, ")");
      break;
    }

    truncated = "";
  }

  return "".concat(output).concat(truncated);
}

function quoteComplexKey(key) {
  if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
    return key;
  }

  return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}

function inspectProperty(_ref2, options) {
  var _ref3 = _slicedToArray(_ref2, 2),
      key = _ref3[0],
      value = _ref3[1];

  options.truncate -= 2;

  if (typeof key === "string") {
    key = quoteComplexKey(key);
  } else if (typeof key !== "number") {
    key = "[".concat(options.inspect(key, options), "]");
  }

  options.truncate -= key.length;
  value = options.inspect(value, options);
  return "".concat(key, ": ").concat(value);
} // src/array.ts


function inspectArray(array, options) {
  var nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length) return "[]";
  options.truncate -= 4;
  var listContents = inspectList(array, options);
  options.truncate -= listContents.length;
  var propertyContents = "";

  if (nonIndexProperties.length) {
    propertyContents = inspectList(nonIndexProperties.map(function (key) {
      return [key, array[key]];
    }), options, inspectProperty);
  }

  return "[ ".concat(listContents).concat(propertyContents ? ", ".concat(propertyContents) : "", " ]");
} // src/typedarray.ts


var getArrayName = function getArrayName(array) {
  if (typeof Buffer === "function" && array instanceof Buffer) {
    return "Buffer";
  }

  if (array[Symbol.toStringTag]) {
    return array[Symbol.toStringTag];
  }

  return array.constructor.name;
};

function inspectTypedArray(array, options) {
  var name = getArrayName(array);
  options.truncate -= name.length + 4;
  var nonIndexProperties = Object.keys(array).slice(array.length);
  if (!array.length && !nonIndexProperties.length) return "".concat(name, "[]");
  var output = "";

  for (var i = 0; i < array.length; i++) {
    var string = "".concat(options.stylize(truncate(array[i], options.truncate), "number")).concat(i === array.length - 1 ? "" : ", ");
    options.truncate -= string.length;

    if (array[i] !== array.length && options.truncate <= 3) {
      output += "".concat(truncator, "(").concat(array.length - array[i] + 1, ")");
      break;
    }

    output += string;
  }

  var propertyContents = "";

  if (nonIndexProperties.length) {
    propertyContents = inspectList(nonIndexProperties.map(function (key) {
      return [key, array[key]];
    }), options, inspectProperty);
  }

  return "".concat(name, "[ ").concat(output).concat(propertyContents ? ", ".concat(propertyContents) : "", " ]");
} // src/date.ts


function inspectDate(dateObject, options) {
  var stringRepresentation = dateObject.toJSON();

  if (stringRepresentation === null) {
    return "Invalid Date";
  }

  var split = stringRepresentation.split("T");
  var date = split[0];
  return options.stylize("".concat(date, "T").concat(truncate(split[1], options.truncate - date.length - 1)), "date");
} // src/function.ts


function inspectFunction(func, options) {
  var functionType = func[Symbol.toStringTag] || "Function";
  var name = func.name;

  if (!name) {
    return options.stylize("[".concat(functionType, "]"), "special");
  }

  return options.stylize("[".concat(functionType, " ").concat(truncate(name, options.truncate - 11), "]"), "special");
} // src/map.ts


function inspectMapEntry(_ref4, options) {
  var _ref5 = _slicedToArray(_ref4, 2),
      key = _ref5[0],
      value = _ref5[1];

  options.truncate -= 4;
  key = options.inspect(key, options);
  options.truncate -= key.length;
  value = options.inspect(value, options);
  return "".concat(key, " => ").concat(value);
}

function mapToEntries(map) {
  var entries = [];
  map.forEach(function (value, key) {
    entries.push([key, value]);
  });
  return entries;
}

function inspectMap(map, options) {
  var size = map.size - 1;

  if (size <= 0) {
    return "Map{}";
  }

  options.truncate -= 7;
  return "Map{ ".concat(inspectList(mapToEntries(map), options, inspectMapEntry), " }");
} // src/number.ts


var isNaN = Number.isNaN || function (i) {
  return i !== i;
};

function inspectNumber(number, options) {
  if (isNaN(number)) {
    return options.stylize("NaN", "number");
  }

  if (number === Infinity) {
    return options.stylize("Infinity", "number");
  }

  if (number === -Infinity) {
    return options.stylize("-Infinity", "number");
  }

  if (number === 0) {
    return options.stylize(1 / number === Infinity ? "+0" : "-0", "number");
  }

  return options.stylize(truncate(String(number), options.truncate), "number");
} // src/bigint.ts


function inspectBigInt(number, options) {
  var nums = truncate(number.toString(), options.truncate - 1);
  if (nums !== truncator) nums += "n";
  return options.stylize(nums, "bigint");
} // src/regexp.ts


function inspectRegExp(value, options) {
  var flags = value.toString().split("/")[2];
  var sourceLength = options.truncate - (2 + flags.length);
  var source = value.source;
  return options.stylize("/".concat(truncate(source, sourceLength), "/").concat(flags), "regexp");
} // src/set.ts


function arrayFromSet(set) {
  var values = [];
  set.forEach(function (value) {
    values.push(value);
  });
  return values;
}

function inspectSet(set, options) {
  if (set.size === 0) return "Set{}";
  options.truncate -= 7;
  return "Set{ ".concat(inspectList(arrayFromSet(set), options), " }");
} // src/string.ts


var stringEscapeChars = new RegExp("['\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]", "g");
var escapeCharacters = {
  "\b": "\\b",
  "	": "\\t",
  "\n": "\\n",
  "\f": "\\f",
  "\r": "\\r",
  "'": "\\'",
  "\\": "\\\\"
};
var hex = 16;
var unicodeLength = 4;

function escape(_char2) {
  return escapeCharacters[_char2] || "\\u".concat("0000".concat(_char2.charCodeAt(0).toString(hex)).slice(-unicodeLength));
}

function inspectString(string, options) {
  if (stringEscapeChars.test(string)) {
    string = string.replace(stringEscapeChars, escape);
  }

  return options.stylize("'".concat(truncate(string, options.truncate - 2), "'"), "string");
} // src/symbol.ts


function inspectSymbol(value) {
  if ("description" in Symbol.prototype) {
    return value.description ? "Symbol(".concat(value.description, ")") : "Symbol()";
  }

  return value.toString();
} // src/promise.ts


var getPromiseValue = function getPromiseValue() {
  return "Promise{\u2026}";
};

try {
  var _process$binding = process.binding("util"),
      getPromiseDetails = _process$binding.getPromiseDetails,
      kPending = _process$binding.kPending,
      kRejected = _process$binding.kRejected;

  if (Array.isArray(getPromiseDetails(Promise.resolve()))) {
    getPromiseValue = function getPromiseValue(value, options) {
      var _getPromiseDetails = getPromiseDetails(value),
          _getPromiseDetails2 = _slicedToArray(_getPromiseDetails, 2),
          state = _getPromiseDetails2[0],
          innerValue = _getPromiseDetails2[1];

      if (state === kPending) {
        return "Promise{<pending>}";
      }

      return "Promise".concat(state === kRejected ? "!" : "", "{").concat(options.inspect(innerValue, options), "}");
    };
  }
} catch (notNode) {}

var promise_default = getPromiseValue; // src/object.ts

function inspectObject(object, options) {
  var properties = Object.getOwnPropertyNames(object);
  var symbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(object) : [];

  if (properties.length === 0 && symbols.length === 0) {
    return "{}";
  }

  options.truncate -= 4;
  options.seen = options.seen || [];

  if (options.seen.indexOf(object) >= 0) {
    return "[Circular]";
  }

  options.seen.push(object);
  var propertyContents = inspectList(properties.map(function (key) {
    return [key, object[key]];
  }), options, inspectProperty);
  var symbolContents = inspectList(symbols.map(function (key) {
    return [key, object[key]];
  }), options, inspectProperty);
  options.seen.pop();
  var sep = "";

  if (propertyContents && symbolContents) {
    sep = ", ";
  }

  return "{ ".concat(propertyContents).concat(sep).concat(symbolContents, " }");
} // src/class.ts


var toStringTag = typeof Symbol !== "undefined" && Symbol.toStringTag ? Symbol.toStringTag : false;

function inspectClass(value, options) {
  var name = "";

  if (toStringTag && toStringTag in value) {
    name = value[toStringTag];
  }

  name = name || value.constructor.name;

  if (!name || name === "_class") {
    name = "<Anonymous Class>";
  }

  options.truncate -= name.length;
  return "".concat(name).concat(inspectObject(value, options));
} // src/arguments.ts


function inspectArguments(args, options) {
  if (args.length === 0) return "Arguments[]";
  options.truncate -= 13;
  return "Arguments[ ".concat(inspectList(args, options), " ]");
} // src/error.ts


var errorKeys = ["stack", "line", "column", "name", "message", "fileName", "lineNumber", "columnNumber", "number", "description"];

function inspectObject2(error, options) {
  var properties = Object.getOwnPropertyNames(error).filter(function (key) {
    return errorKeys.indexOf(key) === -1;
  });
  var name = error.name;
  options.truncate -= name.length;
  var message = "";

  if (typeof error.message === "string") {
    message = truncate(error.message, options.truncate);
  } else {
    properties.unshift("message");
  }

  message = message ? ": ".concat(message) : "";
  options.truncate -= message.length + 5;
  var propertyContents = inspectList(properties.map(function (key) {
    return [key, error[key]];
  }), options, inspectProperty);
  return "".concat(name).concat(message).concat(propertyContents ? " { ".concat(propertyContents, " }") : "");
} // src/html.ts


function inspectAttribute(_ref6, options) {
  var _ref7 = _slicedToArray(_ref6, 2),
      key = _ref7[0],
      value = _ref7[1];

  options.truncate -= 3;

  if (!value) {
    return "".concat(options.stylize(String(key), "yellow"));
  }

  return "".concat(options.stylize(String(key), "yellow"), "=").concat(options.stylize("\"".concat(value, "\""), "string"));
}

function inspectHTMLCollection(collection, options) {
  return inspectList(collection, options, inspectHTML, "\n");
}

function inspectHTML(element, options) {
  var properties = element.getAttributeNames();
  var name = element.tagName.toLowerCase();
  var head = options.stylize("<".concat(name), "special");
  var headClose = options.stylize(">", "special");
  var tail = options.stylize("</".concat(name, ">"), "special");
  options.truncate -= name.length * 2 + 5;
  var propertyContents = "";

  if (properties.length > 0) {
    propertyContents += " ";
    propertyContents += inspectList(properties.map(function (key) {
      return [key, element.getAttribute(key)];
    }), options, inspectAttribute, " ");
  }

  options.truncate -= propertyContents.length;
  var truncate2 = options.truncate;
  var children = inspectHTMLCollection(element.children, options);

  if (children && children.length > truncate2) {
    children = "".concat(truncator, "(").concat(element.children.length, ")");
  }

  return "".concat(head).concat(propertyContents).concat(headClose).concat(children).concat(tail);
} // src/index.ts


var symbolsSupported = typeof Symbol === "function" && typeof Symbol["for"] === "function";
var chaiInspect = symbolsSupported ? Symbol["for"]("chai/inspect") : "@@chai/inspect";
var nodeInspect = false;

try {
  var nodeUtil = require_util();
  nodeInspect = nodeUtil.inspect ? nodeUtil.inspect.custom : false;
} catch (noNodeInspect) {
  nodeInspect = false;
}

var constructorMap =
/* @__PURE__ */
new WeakMap();
var stringTagMap = {};
var baseTypesMap = {
  undefined: function undefined(value, options) {
    return options.stylize("undefined", "undefined");
  },
  "null": function _null(value, options) {
    return options.stylize("null", "null");
  },
  "boolean": function boolean(value, options) {
    return options.stylize(String(value), "boolean");
  },
  Boolean: function Boolean(value, options) {
    return options.stylize(String(value), "boolean");
  },
  number: inspectNumber,
  Number: inspectNumber,
  bigint: inspectBigInt,
  BigInt: inspectBigInt,
  string: inspectString,
  String: inspectString,
  "function": inspectFunction,
  Function: inspectFunction,
  symbol: inspectSymbol,
  // A Symbol polyfill will return `Symbol` not `symbol` from typedetect
  Symbol: inspectSymbol,
  Array: inspectArray,
  Date: inspectDate,
  Map: inspectMap,
  Set: inspectSet,
  RegExp: inspectRegExp,
  Promise: promise_default,
  // WeakSet, WeakMap are totally opaque to us
  WeakSet: function WeakSet(value, options) {
    return options.stylize("WeakSet{\u2026}", "special");
  },
  WeakMap: function WeakMap(value, options) {
    return options.stylize("WeakMap{\u2026}", "special");
  },
  Arguments: inspectArguments,
  Int8Array: inspectTypedArray,
  Uint8Array: inspectTypedArray,
  Uint8ClampedArray: inspectTypedArray,
  Int16Array: inspectTypedArray,
  Uint16Array: inspectTypedArray,
  Int32Array: inspectTypedArray,
  Uint32Array: inspectTypedArray,
  Float32Array: inspectTypedArray,
  Float64Array: inspectTypedArray,
  Generator: function Generator() {
    return "";
  },
  DataView: function DataView() {
    return "";
  },
  ArrayBuffer: function ArrayBuffer() {
    return "";
  },
  Error: inspectObject2,
  HTMLCollection: inspectHTMLCollection,
  NodeList: inspectHTMLCollection
};

var inspectCustom = function inspectCustom(value, options, type) {
  if (chaiInspect in value && typeof value[chaiInspect] === "function") {
    return value[chaiInspect](options);
  }

  if (nodeInspect && nodeInspect in value && typeof value[nodeInspect] === "function") {
    return value[nodeInspect](options.depth, options);
  }

  if ("inspect" in value && typeof value.inspect === "function") {
    return value.inspect(options.depth, options);
  }

  if ("constructor" in value && constructorMap.has(value.constructor)) {
    return constructorMap.get(value.constructor)(value, options);
  }

  if (stringTagMap[type]) {
    return stringTagMap[type](value, options);
  }

  return "";
};

var toString = Object.prototype.toString;

function _inspect(value) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = normaliseOptions(opts, _inspect);
  var customInspect = options.customInspect;
  var type = value === null ? "null" : _typeof(value);

  if (type === "object") {
    type = toString.call(value).slice(8, -1);
  }

  if (type in baseTypesMap) {
    return baseTypesMap[type](value, options);
  }

  if (customInspect && value) {
    var output = inspectCustom(value, options, type);

    if (output) {
      if (typeof output === "string") return output;
      return _inspect(output, options);
    }
  }

  var proto = value ? Object.getPrototypeOf(value) : false;

  if (proto === Object.prototype || proto === null) {
    return inspectObject(value, options);
  }

  if (value && typeof HTMLElement === "function" && value instanceof HTMLElement) {
    return inspectHTML(value, options);
  }

  if ("constructor" in value) {
    if (value.constructor !== Object) {
      return inspectClass(value, options);
    }

    return inspectObject(value, options);
  }

  if (value === Object(value)) {
    return inspectObject(value, options);
  }

  return options.stylize(String(value), type);
}

function _registerConstructor(constructor, inspector) {
  if (constructorMap.has(constructor)) {
    return false;
  }

  constructorMap.set(constructor, inspector);
  return true;
}

function _registerStringTag(stringTag, inspector) {
  if (stringTag in stringTagMap) {
    return false;
  }

  stringTagMap[stringTag] = inspector;
  return true;
}

var _custom = chaiInspect;
var src_default = _inspect;