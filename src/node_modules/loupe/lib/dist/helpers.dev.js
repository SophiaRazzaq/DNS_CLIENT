"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normaliseOptions = normaliseOptions;
exports.truncate = truncate;
exports.inspectList = inspectList;
exports.inspectProperty = inspectProperty;
exports.truncator = void 0;

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var ansiColors = {
  bold: ['1', '22'],
  dim: ['2', '22'],
  italic: ['3', '23'],
  underline: ['4', '24'],
  // 5 & 6 are blinking
  inverse: ['7', '27'],
  hidden: ['8', '28'],
  strike: ['9', '29'],
  // 10-20 are fonts
  // 21-29 are resets for 1-9
  black: ['30', '39'],
  red: ['31', '39'],
  green: ['32', '39'],
  yellow: ['33', '39'],
  blue: ['34', '39'],
  magenta: ['35', '39'],
  cyan: ['36', '39'],
  white: ['37', '39'],
  brightblack: ['30;1', '39'],
  brightred: ['31;1', '39'],
  brightgreen: ['32;1', '39'],
  brightyellow: ['33;1', '39'],
  brightblue: ['34;1', '39'],
  brightmagenta: ['35;1', '39'],
  brightcyan: ['36;1', '39'],
  brightwhite: ['37;1', '39'],
  grey: ['90', '39']
};
var styles = {
  special: 'cyan',
  number: 'yellow',
  bigint: 'yellow',
  "boolean": 'yellow',
  undefined: 'grey',
  "null": 'bold',
  string: 'green',
  symbol: 'green',
  date: 'magenta',
  regexp: 'red'
};
var truncator = 'â€¦';
exports.truncator = truncator;

function colorise(value, styleType) {
  var color = ansiColors[styles[styleType]] || ansiColors[styleType] || '';

  if (!color) {
    return String(value);
  }

  return "\x1B[".concat(color[0], "m").concat(String(value), "\x1B[").concat(color[1], "m");
}

function normaliseOptions() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$showHidden = _ref.showHidden,
      showHidden = _ref$showHidden === void 0 ? false : _ref$showHidden,
      _ref$depth = _ref.depth,
      depth = _ref$depth === void 0 ? 2 : _ref$depth,
      _ref$colors = _ref.colors,
      colors = _ref$colors === void 0 ? false : _ref$colors,
      _ref$customInspect = _ref.customInspect,
      customInspect = _ref$customInspect === void 0 ? true : _ref$customInspect,
      _ref$showProxy = _ref.showProxy,
      showProxy = _ref$showProxy === void 0 ? false : _ref$showProxy,
      _ref$maxArrayLength = _ref.maxArrayLength,
      maxArrayLength = _ref$maxArrayLength === void 0 ? Infinity : _ref$maxArrayLength,
      _ref$breakLength = _ref.breakLength,
      breakLength = _ref$breakLength === void 0 ? Infinity : _ref$breakLength,
      _ref$seen = _ref.seen,
      seen = _ref$seen === void 0 ? [] : _ref$seen,
      _ref$truncate = _ref.truncate,
      truncate = _ref$truncate === void 0 ? Infinity : _ref$truncate,
      _ref$stylize = _ref.stylize,
      stylize = _ref$stylize === void 0 ? String : _ref$stylize;

  var inspect = arguments.length > 1 ? arguments[1] : undefined;
  var options = {
    showHidden: Boolean(showHidden),
    depth: Number(depth),
    colors: Boolean(colors),
    customInspect: Boolean(customInspect),
    showProxy: Boolean(showProxy),
    maxArrayLength: Number(maxArrayLength),
    breakLength: Number(breakLength),
    truncate: Number(truncate),
    seen: seen,
    inspect: inspect,
    stylize: stylize
  };

  if (options.colors) {
    options.stylize = colorise;
  }

  return options;
}

function isHighSurrogate(_char) {
  return _char >= "\uD800" && _char <= "\uDBFF";
}

function truncate(string, length) {
  var tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : truncator;
  string = String(string);
  var tailLength = tail.length;
  var stringLength = string.length;

  if (tailLength > length && stringLength > tailLength) {
    return tail;
  }

  if (stringLength > length && stringLength > tailLength) {
    var end = length - tailLength;

    if (end > 0 && isHighSurrogate(string[end - 1])) {
      end = end - 1;
    }

    return "".concat(string.slice(0, end)).concat(tail);
  }

  return string;
} // eslint-disable-next-line complexity


function inspectList(list, options, inspectItem) {
  var separator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ', ';
  inspectItem = inspectItem || options.inspect;
  var size = list.length;
  if (size === 0) return '';
  var originalLength = options.truncate;
  var output = '';
  var peek = '';
  var truncated = '';

  for (var i = 0; i < size; i += 1) {
    var last = i + 1 === list.length;
    var secondToLast = i + 2 === list.length;
    truncated = "".concat(truncator, "(").concat(list.length - i, ")");
    var value = list[i]; // If there is more than one remaining we need to account for a separator of `, `

    options.truncate = originalLength - output.length - (last ? 0 : separator.length);
    var string = peek || inspectItem(value, options) + (last ? '' : separator);
    var nextLength = output.length + string.length;
    var truncatedLength = nextLength + truncated.length; // If this is the last element, and adding it would
    // take us over length, but adding the truncator wouldn't - then break now

    if (last && nextLength > originalLength && output.length + truncated.length <= originalLength) {
      break;
    } // If this isn't the last or second to last element to scan,
    // but the string is already over length then break here


    if (!last && !secondToLast && truncatedLength > originalLength) {
      break;
    } // Peek at the next string to determine if we should
    // break early before adding this item to the output


    peek = last ? '' : inspectItem(list[i + 1], options) + (secondToLast ? '' : separator); // If we have one element left, but this element and
    // the next takes over length, the break early

    if (!last && secondToLast && truncatedLength > originalLength && nextLength + peek.length > originalLength) {
      break;
    }

    output += string; // If the next element takes us to length -
    // but there are more after that, then we should truncate now

    if (!last && !secondToLast && nextLength + peek.length >= originalLength) {
      truncated = "".concat(truncator, "(").concat(list.length - i - 1, ")");
      break;
    }

    truncated = '';
  }

  return "".concat(output).concat(truncated);
}

function quoteComplexKey(key) {
  if (key.match(/^[a-zA-Z_][a-zA-Z_0-9]*$/)) {
    return key;
  }

  return JSON.stringify(key).replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
}

function inspectProperty(_ref2, options) {
  var _ref3 = _slicedToArray(_ref2, 2),
      key = _ref3[0],
      value = _ref3[1];

  options.truncate -= 2;

  if (typeof key === 'string') {
    key = quoteComplexKey(key);
  } else if (typeof key !== 'number') {
    key = "[".concat(options.inspect(key, options), "]");
  }

  options.truncate -= key.length;
  value = options.inspect(value, options);
  return "".concat(key, ": ").concat(value);
}