"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RateLimit = exports.Sema = void 0;

var events_1 = __importDefault(require("events"));

function arrayMove(src, srcIndex, dst, dstIndex, len) {
  for (var j = 0; j < len; ++j) {
    dst[j + dstIndex] = src[j + srcIndex];
    src[j + srcIndex] = void 0;
  }
}

function pow2AtLeast(n) {
  n = n >>> 0;
  n = n - 1;
  n = n | n >> 1;
  n = n | n >> 2;
  n = n | n >> 4;
  n = n | n >> 8;
  n = n | n >> 16;
  return n + 1;
}

function getCapacity(capacity) {
  return pow2AtLeast(Math.min(Math.max(16, capacity), 1073741824));
} // Deque is based on https://github.com/petkaantonov/deque/blob/master/js/deque.js
// Released under the MIT License: https://github.com/petkaantonov/deque/blob/6ef4b6400ad3ba82853fdcc6531a38eb4f78c18c/LICENSE


var Deque =
/*#__PURE__*/
function () {
  function Deque(capacity) {
    _classCallCheck(this, Deque);

    this._capacity = getCapacity(capacity);
    this._length = 0;
    this._front = 0;
    this.arr = [];
  }

  _createClass(Deque, [{
    key: "push",
    value: function push(item) {
      var length = this._length;
      this.checkCapacity(length + 1);
      var i = this._front + length & this._capacity - 1;
      this.arr[i] = item;
      this._length = length + 1;
      return length + 1;
    }
  }, {
    key: "pop",
    value: function pop() {
      var length = this._length;

      if (length === 0) {
        return void 0;
      }

      var i = this._front + length - 1 & this._capacity - 1;
      var ret = this.arr[i];
      this.arr[i] = void 0;
      this._length = length - 1;
      return ret;
    }
  }, {
    key: "shift",
    value: function shift() {
      var length = this._length;

      if (length === 0) {
        return void 0;
      }

      var front = this._front;
      var ret = this.arr[front];
      this.arr[front] = void 0;
      this._front = front + 1 & this._capacity - 1;
      this._length = length - 1;
      return ret;
    }
  }, {
    key: "checkCapacity",
    value: function checkCapacity(size) {
      if (this._capacity < size) {
        this.resizeTo(getCapacity(this._capacity * 1.5 + 16));
      }
    }
  }, {
    key: "resizeTo",
    value: function resizeTo(capacity) {
      var oldCapacity = this._capacity;
      this._capacity = capacity;
      var front = this._front;
      var length = this._length;

      if (front + length > oldCapacity) {
        var moveItemsCount = front + length & oldCapacity - 1;
        arrayMove(this.arr, 0, this.arr, oldCapacity, moveItemsCount);
      }
    }
  }, {
    key: "length",
    get: function get() {
      return this._length;
    }
  }]);

  return Deque;
}();

var ReleaseEmitter =
/*#__PURE__*/
function (_events_1$default) {
  _inherits(ReleaseEmitter, _events_1$default);

  function ReleaseEmitter() {
    _classCallCheck(this, ReleaseEmitter);

    return _possibleConstructorReturn(this, _getPrototypeOf(ReleaseEmitter).apply(this, arguments));
  }

  return ReleaseEmitter;
}(events_1["default"]);

function isFn(x) {
  return typeof x === 'function';
}

function defaultInit() {
  return '1';
}

var Sema =
/*#__PURE__*/
function () {
  function Sema(nr) {
    var _this = this;

    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$initFn = _ref.initFn,
        initFn = _ref$initFn === void 0 ? defaultInit : _ref$initFn,
        pauseFn = _ref.pauseFn,
        resumeFn = _ref.resumeFn,
        _ref$capacity = _ref.capacity,
        capacity = _ref$capacity === void 0 ? 10 : _ref$capacity;

    _classCallCheck(this, Sema);

    if (isFn(pauseFn) !== isFn(resumeFn)) {
      throw new Error('pauseFn and resumeFn must be both set for pausing');
    }

    this.nrTokens = nr;
    this.free = new Deque(nr);
    this.waiting = new Deque(capacity);
    this.releaseEmitter = new ReleaseEmitter();
    this.noTokens = initFn === defaultInit;
    this.pauseFn = pauseFn;
    this.resumeFn = resumeFn;
    this.paused = false;
    this.releaseEmitter.on('release', function (token) {
      var p = _this.waiting.shift();

      if (p) {
        p.resolve(token);
      } else {
        if (_this.resumeFn && _this.paused) {
          _this.paused = false;

          _this.resumeFn();
        }

        _this.free.push(token);
      }
    });

    for (var i = 0; i < nr; i++) {
      this.free.push(initFn());
    }
  }

  _createClass(Sema, [{
    key: "tryAcquire",
    value: function tryAcquire() {
      return this.free.pop();
    }
  }, {
    key: "acquire",
    value: function acquire() {
      var _this2 = this;

      var token;
      return regeneratorRuntime.async(function acquire$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              token = this.tryAcquire();

              if (!(token !== void 0)) {
                _context.next = 3;
                break;
              }

              return _context.abrupt("return", token);

            case 3:
              return _context.abrupt("return", new Promise(function (resolve, reject) {
                if (_this2.pauseFn && !_this2.paused) {
                  _this2.paused = true;

                  _this2.pauseFn();
                }

                _this2.waiting.push({
                  resolve: resolve,
                  reject: reject
                });
              }));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "release",
    value: function release(token) {
      this.releaseEmitter.emit('release', this.noTokens ? '1' : token);
    }
  }, {
    key: "drain",
    value: function drain() {
      var a = new Array(this.nrTokens);

      for (var i = 0; i < this.nrTokens; i++) {
        a[i] = this.acquire();
      }

      return Promise.all(a);
    }
  }, {
    key: "nrWaiting",
    value: function nrWaiting() {
      return this.waiting.length;
    }
  }]);

  return Sema;
}();

exports.Sema = Sema;

function RateLimit(rps) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$timeUnit = _ref2.timeUnit,
      timeUnit = _ref2$timeUnit === void 0 ? 1000 : _ref2$timeUnit,
      _ref2$uniformDistribu = _ref2.uniformDistribution,
      uniformDistribution = _ref2$uniformDistribu === void 0 ? false : _ref2$uniformDistribu;

  var sema = new Sema(uniformDistribution ? 1 : rps);
  var delay = uniformDistribution ? timeUnit / rps : timeUnit;
  return function rl() {
    return regeneratorRuntime.async(function rl$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return regeneratorRuntime.awrap(sema.acquire());

          case 2:
            setTimeout(function () {
              return sema.release();
            }, delay);

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    });
  };
}

exports.RateLimit = RateLimit;