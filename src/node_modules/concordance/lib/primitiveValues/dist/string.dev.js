'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var keyword = require('esutils').keyword;

var fastDiff = require('fast-diff');

var constants = require('../constants');

var formatUtils = require('../formatUtils');

var lineBuilder = require('../lineBuilder');

var DEEP_EQUAL = constants.DEEP_EQUAL;
var UNEQUAL = constants.UNEQUAL;

function describe(value) {
  return new StringValue(value);
}

exports.describe = describe;
exports.deserialize = describe;
var tag = Symbol('StringValue');
exports.tag = tag; // TODO: Escape invisible characters (e.g. zero-width joiner, non-breaking space),
// ambiguous characters (other kinds of spaces, combining characters). Use
// http://graphemica.com/blocks/control-pictures where applicable.

function basicEscape(string) {
  return string.replace(/\\/g, '\\\\');
}

var CRLF_CONTROL_PICTURE = "\u240D\u240A";
var LF_CONTROL_PICTURE = "\u240A";
var CR_CONTROL_PICTURE = "\u240D";
var MATCH_CONTROL_PICTURES = new RegExp("".concat(CR_CONTROL_PICTURE, "|").concat(LF_CONTROL_PICTURE, "|").concat(CR_CONTROL_PICTURE), 'g');

function escapeLinebreak(string) {
  if (string === '\r\n') return CRLF_CONTROL_PICTURE;
  if (string === '\n') return LF_CONTROL_PICTURE;
  if (string === '\r') return CR_CONTROL_PICTURE;
  return string;
}

function themeControlPictures(theme, resetWrap, str) {
  return str.replace(MATCH_CONTROL_PICTURES, function (picture) {
    return resetWrap.close + formatUtils.wrap(theme.string.controlPicture, picture) + resetWrap.open;
  });
}

var MATCH_SINGLE_QUOTE = /'/g;
var MATCH_DOUBLE_QUOTE = /"/g;
var MATCH_BACKTICKS = /`/g;

function escapeQuotes(line, string) {
  var quote = line.escapeQuote;
  if (quote === '\'') return string.replace(MATCH_SINGLE_QUOTE, "\\'");
  if (quote === '"') return string.replace(MATCH_DOUBLE_QUOTE, '\\"');
  if (quote === '`') return string.replace(MATCH_BACKTICKS, '\\`');
  return string;
}

function includesLinebreaks(string) {
  return string.includes('\r') || string.includes('\n');
}

function diffLine(theme, actual, expected, invert) {
  var outcome = fastDiff(actual, expected); // TODO: Compute when line is mostly unequal (80%? 90%?) and treat it as being
  // completely unequal.

  var isPartiallyEqual = !(outcome.length === 2 && outcome[0][1] === actual && outcome[1][1] === expected || // Discount line ending control pictures, which will be equal even when the
  // rest of the line isn't.
  outcome.length === 3 && outcome[2][0] === fastDiff.EQUAL && MATCH_CONTROL_PICTURES.test(outcome[2][1]) && outcome[0][1] + outcome[2][1] === actual && outcome[1][1] + outcome[2][1] === expected);
  var stringActual = '';
  var stringExpected = '';
  var noopWrap = {
    open: '',
    close: ''
  };
  var deleteWrap = isPartiallyEqual ? theme.string.diff["delete"] : noopWrap;
  var insertWrap = isPartiallyEqual ? theme.string.diff.insert : noopWrap;
  var equalWrap = isPartiallyEqual ? theme.string.diff.equal : noopWrap;

  if (invert) {
    var _ref = [insertWrap, deleteWrap];
    deleteWrap = _ref[0];
    insertWrap = _ref[1];
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = outcome[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var diff = _step.value;

      if (diff[0] === fastDiff.DELETE) {
        stringActual += formatUtils.wrap(deleteWrap, diff[1]);
      } else if (diff[0] === fastDiff.INSERT) {
        stringExpected += formatUtils.wrap(insertWrap, diff[1]);
      } else {
        var string = formatUtils.wrap(equalWrap, themeControlPictures(theme, equalWrap, diff[1]));
        stringActual += string;
        stringExpected += string;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  if (!isPartiallyEqual) {
    var deleteLineWrap = invert ? theme.string.diff.insertLine : theme.string.diff.deleteLine;
    var insertLineWrap = invert ? theme.string.diff.deleteLine : theme.string.diff.insertLine;
    stringActual = formatUtils.wrap(deleteLineWrap, stringActual);
    stringExpected = formatUtils.wrap(insertLineWrap, stringExpected);
  }

  return [stringActual, stringExpected];
}

var LINEBREAKS = /\r\n|\r|\n/g;

function gatherLines(string) {
  var lines = [];
  var prevIndex = 0;

  for (var match; match = LINEBREAKS.exec(string); prevIndex = match.index + match[0].length) {
    lines.push(string.slice(prevIndex, match.index) + escapeLinebreak(match[0]));
  }

  lines.push(string.slice(prevIndex));
  return lines;
}

var StringValue =
/*#__PURE__*/
function () {
  function StringValue(value) {
    _classCallCheck(this, StringValue);

    this.value = value;
  }

  _createClass(StringValue, [{
    key: "compare",
    value: function compare(expected) {
      return expected.tag === tag && this.value === expected.value ? DEEP_EQUAL : UNEQUAL;
    }
  }, {
    key: "formatDeep",
    value: function formatDeep(theme, indent) {
      // Escape backslashes
      var escaped = basicEscape(this.value);

      if (!this.includesLinebreaks) {
        escaped = escapeQuotes(theme.string.line, escaped);
        return lineBuilder.single(formatUtils.wrap(theme.string.line, formatUtils.wrap(theme.string, escaped)));
      }

      escaped = escapeQuotes(theme.string.multiline, escaped);
      var lineStrings = gatherLines(escaped).map(function (string) {
        return formatUtils.wrap(theme.string, themeControlPictures(theme, theme.string, string));
      });
      var lastIndex = lineStrings.length - 1;
      var indentation = indent;
      return lineBuilder.buffer().append(lineStrings.map(function (string, index) {
        if (index === 0) return lineBuilder.first(theme.string.multiline.start + string);
        if (index === lastIndex) return lineBuilder.last(indentation + string + theme.string.multiline.end);
        return lineBuilder.line(indentation + string);
      }));
    }
  }, {
    key: "formatAsKey",
    value: function formatAsKey(theme) {
      var key = this.value;

      if (keyword.isIdentifierNameES6(key, true) || String(parseInt(key, 10)) === key) {
        return key;
      }

      var escaped = basicEscape(key).replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/'/g, "\\'");
      return formatUtils.wrap(theme.string.line, formatUtils.wrap(theme.string, escaped));
    }
  }, {
    key: "diffDeep",
    value: function diffDeep(expected, theme, indent, invert) {
      if (expected.tag !== tag) return null;
      var escapedActual = basicEscape(this.value);
      var escapedExpected = basicEscape(expected.value);

      if (!includesLinebreaks(escapedActual) && !includesLinebreaks(escapedExpected)) {
        var result = diffLine(theme, escapeQuotes(theme.string.line, escapedActual), escapeQuotes(theme.string.line, escapedExpected), invert);
        return lineBuilder.actual.single(formatUtils.wrap(theme.string.line, result[0])).concat(lineBuilder.expected.single(formatUtils.wrap(theme.string.line, result[1])));
      }

      var actualLines = gatherLines(escapeQuotes(theme.string.multiline, escapedActual));
      var expectedLines = gatherLines(escapeQuotes(theme.string.multiline, escapedExpected));
      var indentation = indent;
      var lines = lineBuilder.buffer();
      var lastActualIndex = actualLines.length - 1;
      var lastExpectedIndex = expectedLines.length - 1;
      var actualBuffer = [];
      var expectedBuffer = [];
      var mustOpenNextExpected = false;

      for (var actualIndex = 0, expectedIndex = 0, extraneousOffset = 0; actualIndex < actualLines.length;) {
        if (actualLines[actualIndex] === expectedLines[expectedIndex]) {
          lines.append(actualBuffer);
          lines.append(expectedBuffer);
          actualBuffer = [];
          expectedBuffer = [];
          var string = actualLines[actualIndex];
          string = themeControlPictures(theme, theme.string.diff.equal, string);
          string = formatUtils.wrap(theme.string.diff.equal, string);

          if (actualIndex === 0) {
            lines.append(lineBuilder.first(theme.string.multiline.start + string));
          } else if (actualIndex === lastActualIndex && expectedIndex === lastExpectedIndex) {
            lines.append(lineBuilder.last(indentation + string + theme.string.multiline.end));
          } else {
            lines.append(lineBuilder.line(indentation + string));
          }

          actualIndex++;
          expectedIndex++;
          continue;
        }

        var expectedIsMissing = false;
        {
          var compare = actualLines[actualIndex];

          for (var index = expectedIndex; !expectedIsMissing && index < expectedLines.length; index++) {
            expectedIsMissing = compare === expectedLines[index];
          }
        }
        var actualIsExtraneous = actualIndex - extraneousOffset > lastExpectedIndex || expectedIndex > lastExpectedIndex;

        if (!actualIsExtraneous) {
          var _compare = expectedLines[expectedIndex];

          for (var _index = actualIndex; !actualIsExtraneous && _index < actualLines.length; _index++) {
            actualIsExtraneous = _compare === actualLines[_index];
          }

          if (!actualIsExtraneous && actualIndex - extraneousOffset === lastExpectedIndex && actualIndex < lastActualIndex) {
            actualIsExtraneous = true;
          }
        }

        if (actualIsExtraneous && !expectedIsMissing) {
          var wrap = invert ? theme.string.diff.insertLine : theme.string.diff.deleteLine;

          var _string = formatUtils.wrap(wrap, actualLines[actualIndex]);

          if (actualIndex === 0) {
            actualBuffer.push(lineBuilder.actual.first(theme.string.multiline.start + _string));
            mustOpenNextExpected = true;
          } else if (actualIndex === lastActualIndex) {
            actualBuffer.push(lineBuilder.actual.last(indentation + _string + theme.string.multiline.end));
          } else {
            actualBuffer.push(lineBuilder.actual.line(indentation + _string));
          }

          actualIndex++;
          extraneousOffset++;
        } else if (expectedIsMissing && !actualIsExtraneous) {
          var _wrap = invert ? theme.string.diff.deleteLine : theme.string.diff.insertLine;

          var _string2 = formatUtils.wrap(_wrap, expectedLines[expectedIndex]);

          if (mustOpenNextExpected) {
            expectedBuffer.push(lineBuilder.expected.first(theme.string.multiline.start + _string2));
            mustOpenNextExpected = false;
          } else if (expectedIndex === lastExpectedIndex) {
            expectedBuffer.push(lineBuilder.expected.last(indentation + _string2 + theme.string.multiline.end));
          } else {
            expectedBuffer.push(lineBuilder.expected.line(indentation + _string2));
          }

          expectedIndex++;
        } else {
          var _result = diffLine(theme, actualLines[actualIndex], expectedLines[expectedIndex], invert);

          if (actualIndex === 0) {
            actualBuffer.push(lineBuilder.actual.first(theme.string.multiline.start + _result[0]));
            mustOpenNextExpected = true;
          } else if (actualIndex === lastActualIndex) {
            actualBuffer.push(lineBuilder.actual.last(indentation + _result[0] + theme.string.multiline.end));
          } else {
            actualBuffer.push(lineBuilder.actual.line(indentation + _result[0]));
          }

          if (mustOpenNextExpected) {
            expectedBuffer.push(lineBuilder.expected.first(theme.string.multiline.start + _result[1]));
            mustOpenNextExpected = false;
          } else if (expectedIndex === lastExpectedIndex) {
            expectedBuffer.push(lineBuilder.expected.last(indentation + _result[1] + theme.string.multiline.end));
          } else {
            expectedBuffer.push(lineBuilder.expected.line(indentation + _result[1]));
          }

          actualIndex++;
          expectedIndex++;
        }
      }

      lines.append(actualBuffer);
      lines.append(expectedBuffer);
      return lines;
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return this.value;
    }
  }, {
    key: "includesLinebreaks",
    get: function get() {
      return includesLinebreaks(this.value);
    }
  }]);

  return StringValue;
}();

Object.defineProperty(StringValue.prototype, 'isPrimitive', {
  value: true
});
Object.defineProperty(StringValue.prototype, 'tag', {
  value: tag
});