'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var constants = require('../constants');

var formatUtils = require('../formatUtils');

var symbolPrimitive = require('../primitiveValues/symbol').tag;

var recursorUtils = require('../recursorUtils');

var AMBIGUOUS = constants.AMBIGUOUS;
var DEEP_EQUAL = constants.DEEP_EQUAL;
var UNEQUAL = constants.UNEQUAL;

function describeComplex(key, value) {
  return new ComplexProperty(key, value);
}

exports.describeComplex = describeComplex;

function deserializeComplex(key, recursor) {
  var value = recursor();
  return new ComplexProperty(key, value);
}

exports.deserializeComplex = deserializeComplex;

function describePrimitive(key, value) {
  return new PrimitiveProperty(key, value);
}

exports.describePrimitive = describePrimitive;

function deserializePrimitive(state) {
  var key = state[0];
  var value = state[1];
  return new PrimitiveProperty(key, value);
}

exports.deserializePrimitive = deserializePrimitive;
var complexTag = Symbol('ComplexProperty');
exports.complexTag = complexTag;
var primitiveTag = Symbol('PrimitiveProperty');
exports.primitiveTag = primitiveTag;

var Property =
/*#__PURE__*/
function () {
  function Property(key) {
    _classCallCheck(this, Property);

    this.key = key;
  }

  _createClass(Property, [{
    key: "compareKeys",
    value: function compareKeys(expected) {
      var result = this.key.compare(expected.key); // Return AMBIGUOUS if symbol keys are unequal. It's likely that properties
      // are compared in order of declaration, which is not the desired strategy.
      // Returning AMBIGUOUS allows compare() and diff() to recognize this
      // situation and sort the symbol properties before comparing them.

      return result === UNEQUAL && this.key.tag === symbolPrimitive && expected.key.tag === symbolPrimitive ? AMBIGUOUS : result;
    }
  }, {
    key: "prepareDiff",
    value: function prepareDiff(expected, lhsRecursor, rhsRecursor, compareComplexShape, isCircular) {
      // Circular values cannot be compared. They must be treated as being unequal when diffing.
      if (isCircular(this.value) || isCircular(expected.value)) return {
        compareResult: UNEQUAL
      }; // Try to line up this or remaining properties with the expected properties.

      var rhsFork = recursorUtils.fork(rhsRecursor);
      var initialExpected = expected;

      do {
        if (expected === null || expected.isProperty !== true) {
          return {
            actualIsExtraneous: true,
            rhsRecursor: recursorUtils.unshift(rhsFork.recursor, initialExpected)
          };
        } else if (this.key.compare(expected.key) === DEEP_EQUAL) {
          if (expected === initialExpected) {
            return null;
          } else {
            return {
              expectedIsMissing: true,
              lhsRecursor: recursorUtils.unshift(lhsRecursor, this),
              rhsRecursor: rhsFork.recursor
            };
          }
        }

        expected = rhsFork.shared();
      } while (true);
    }
  }]);

  return Property;
}();

Object.defineProperty(Property.prototype, 'isProperty', {
  value: true
});

var ComplexProperty =
/*#__PURE__*/
function (_Property) {
  _inherits(ComplexProperty, _Property);

  function ComplexProperty(key, value) {
    var _this;

    _classCallCheck(this, ComplexProperty);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ComplexProperty).call(this, key));
    _this.value = value;
    return _this;
  }

  _createClass(ComplexProperty, [{
    key: "createRecursor",
    value: function createRecursor() {
      return recursorUtils.singleValue(this.value);
    }
  }, {
    key: "compare",
    value: function compare(expected) {
      if (expected.isProperty !== true) return UNEQUAL;
      var keyResult = this.compareKeys(expected);
      if (keyResult !== DEEP_EQUAL) return keyResult;
      return this.tag === expected.tag ? this.value.compare(expected.value) : UNEQUAL;
    }
  }, {
    key: "formatShallow",
    value: function formatShallow(theme, indent) {
      var _this2 = this;

      var increaseValueIndent = theme.property.increaseValueIndent === true;
      return new formatUtils.SingleValueFormatter(theme, function (value) {
        if (typeof theme.property.customFormat === 'function') {
          return theme.property.customFormat(theme, indent, _this2.key, value);
        }

        return value.withFirstPrefixed(_this2.key.formatAsKey(theme) + theme.property.separator).withLastPostfixed(theme.property.after);
      }, increaseValueIndent);
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return this.key;
    }
  }]);

  return ComplexProperty;
}(Property);

Object.defineProperty(ComplexProperty.prototype, 'tag', {
  value: complexTag
});

var PrimitiveProperty =
/*#__PURE__*/
function (_Property2) {
  _inherits(PrimitiveProperty, _Property2);

  function PrimitiveProperty(key, value) {
    var _this3;

    _classCallCheck(this, PrimitiveProperty);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(PrimitiveProperty).call(this, key));
    _this3.value = value;
    return _this3;
  }

  _createClass(PrimitiveProperty, [{
    key: "compare",
    value: function compare(expected) {
      if (expected.isProperty !== true) return UNEQUAL;
      var keyResult = this.compareKeys(expected);
      if (keyResult !== DEEP_EQUAL) return keyResult;
      return this.tag !== expected.tag ? UNEQUAL : this.value.compare(expected.value);
    }
  }, {
    key: "formatDeep",
    value: function formatDeep(theme, indent) {
      var increaseValueIndent = theme.property.increaseValueIndent === true;
      var valueIndent = increaseValueIndent ? indent.increase() : indent; // Since the key and value are formatted directly, modifiers are not
      // applied. Apply modifiers to the property descriptor instead.

      var formatted = this.value.formatDeep(theme, valueIndent);

      if (typeof theme.property.customFormat === 'function') {
        return theme.property.customFormat(theme, indent, this.key, formatted);
      }

      return formatted.withFirstPrefixed(this.key.formatAsKey(theme) + theme.property.separator).withLastPostfixed(theme.property.after);
    }
  }, {
    key: "diffDeep",
    value: function diffDeep(expected, theme, indent, invert) {
      // Verify a diff can be returned.
      if (this.tag !== expected.tag || typeof this.value.diffDeep !== 'function') return null; // Only use this logic to diff values when the keys are the same.

      if (this.key.compare(expected.key) !== DEEP_EQUAL) return null;
      var increaseValueIndent = theme.property.increaseValueIndent === true;
      var valueIndent = increaseValueIndent ? indent.increase() : indent; // Since the key and value are diffed directly, modifiers are not
      // applied. Apply modifiers to the property descriptor instead.

      var diff = this.value.diffDeep(expected.value, theme, valueIndent, invert);
      if (diff === null) return null;

      if (typeof theme.property.customFormat === 'function') {
        return theme.property.customFormat(theme, indent, this.key, diff);
      }

      return diff.withFirstPrefixed(this.key.formatAsKey(theme) + theme.property.separator).withLastPostfixed(theme.property.after);
    }
  }, {
    key: "serialize",
    value: function serialize() {
      return [this.key, this.value];
    }
  }]);

  return PrimitiveProperty;
}(Property);

Object.defineProperty(PrimitiveProperty.prototype, 'tag', {
  value: primitiveTag
});