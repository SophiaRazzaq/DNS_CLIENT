'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var Circular = require('./Circular');

var constants = require('./constants');

var describe = require('./describe');

var recursorUtils = require('./recursorUtils');

var shouldCompareDeep = require('./shouldCompareDeep');

var symbolProperties = require('./symbolProperties');

var AMBIGUOUS = constants.AMBIGUOUS;
var DEEP_EQUAL = constants.DEEP_EQUAL;
var UNEQUAL = constants.UNEQUAL;

function shortcircuitPrimitive(value) {
  if (value === null || value === undefined || value === true || value === false) return true;

  var type = _typeof(value);

  if (type === 'string' || type === 'symbol') return true; // Don't shortcircuit NaN values

  if (type === 'number') return !isNaN(value);
  return false;
}

function compareDescriptors(lhs, rhs) {
  var lhsCircular = new Circular();
  var rhsCircular = new Circular();
  var lhsStack = [];
  var rhsStack = [];
  var topIndex = -1;

  do {
    var result = void 0;

    if (lhsCircular.has(lhs)) {
      result = lhsCircular.get(lhs) === rhsCircular.get(rhs) ? DEEP_EQUAL : UNEQUAL;
    } else if (rhsCircular.has(rhs)) {
      result = UNEQUAL;
    } else {
      result = lhs.compare(rhs);
    }

    if (result === UNEQUAL) return false;

    if (result !== DEEP_EQUAL) {
      if (!shouldCompareDeep(result, lhs, rhs)) return false;

      if (result === AMBIGUOUS && lhs.isProperty === true) {
        // Replace both sides by a pseudo-descriptor which collects symbol
        // properties instead.
        lhs = new symbolProperties.Collector(lhs, lhsStack[topIndex].recursor);
        rhs = new symbolProperties.Collector(rhs, rhsStack[topIndex].recursor); // Replace the current recursors so they can continue correctly after
        // the collectors have been "compared". This is necessary since the
        // collectors eat the first value after the last symbol property.

        lhsStack[topIndex].recursor = recursorUtils.unshift(lhsStack[topIndex].recursor, lhs.collectAll());
        rhsStack[topIndex].recursor = recursorUtils.unshift(rhsStack[topIndex].recursor, rhs.collectAll());
      }

      lhsCircular.add(lhs);
      rhsCircular.add(rhs);
      lhsStack.push({
        subject: lhs,
        recursor: lhs.createRecursor()
      });
      rhsStack.push({
        subject: rhs,
        recursor: rhs.createRecursor()
      });
      topIndex++;
    }

    while (topIndex >= 0) {
      lhs = lhsStack[topIndex].recursor();
      rhs = rhsStack[topIndex].recursor();

      if (lhs !== null && rhs !== null) {
        break;
      }

      if (lhs === null && rhs === null) {
        var lhsRecord = lhsStack.pop();
        var rhsRecord = rhsStack.pop();
        lhsCircular["delete"](lhsRecord.subject);
        rhsCircular["delete"](rhsRecord.subject);
        topIndex--;
      } else {
        return false;
      }
    }
  } while (topIndex >= 0);

  return true;
}

exports.compareDescriptors = compareDescriptors;

function compare(actual, expected, options) {
  if (Object.is(actual, expected)) return {
    pass: true
  }; // Primitive values should be the same, so if actual or expected is primitive
  // then the values will never compare.

  if (shortcircuitPrimitive(actual) || shortcircuitPrimitive(expected)) return {
    pass: false
  };
  actual = describe(actual, options);
  expected = describe(expected, options);
  var pass = compareDescriptors(actual, expected);
  return {
    actual: actual,
    expected: expected,
    pass: pass
  };
}

exports.compare = compare;