'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var md5hex = require('md5-hex');

var argumentsValue = require('./complexValues/arguments');

var arrayBufferValue = require('./complexValues/arrayBuffer');

var boxedValue = require('./complexValues/boxed');

var dataViewValue = require('./complexValues/dataView');

var dateValue = require('./complexValues/date');

var errorValue = require('./complexValues/error');

var functionValue = require('./complexValues/function');

var globalValue = require('./complexValues/global');

var mapValue = require('./complexValues/map');

var objectValue = require('./complexValues/object');

var promiseValue = require('./complexValues/promise');

var regexpValue = require('./complexValues/regexp');

var setValue = require('./complexValues/set');

var typedArrayValue = require('./complexValues/typedArray');

var encoder = require('./encoder');

var itemDescriptor = require('./metaDescriptors/item');

var mapEntryDescriptor = require('./metaDescriptors/mapEntry');

var pointerDescriptor = require('./metaDescriptors/pointer');

var propertyDescriptor = require('./metaDescriptors/property');

var statsDescriptors = require('./metaDescriptors/stats');

var pluginRegistry = require('./pluginRegistry');

var bigIntValue = require('./primitiveValues/bigInt');

var booleanValue = require('./primitiveValues/boolean');

var nullValue = require('./primitiveValues/null');

var numberValue = require('./primitiveValues/number');

var stringValue = require('./primitiveValues/string');

var symbolValue = require('./primitiveValues/symbol');

var undefinedValue = require('./primitiveValues/undefined');

var recursorUtils = require('./recursorUtils'); // Increment if encoding layout, descriptor IDs, or value types change. Previous
// Concordance versions will not be able to decode buffers generated by a newer
// version, so changing this value will require a major version bump of
// Concordance itself. The version is encoded as an unsigned 16 bit integer.


var VERSION = 3; // Adding or removing mappings or changing an index requires the version in
// encoder.js to be bumped, which necessitates a major version bump of
// Concordance itself. Indexes are hexadecimal to make reading the binary
// output easier.

var mappings = [[0x01, bigIntValue.tag, bigIntValue.deserialize], [0x02, booleanValue.tag, booleanValue.deserialize], [0x03, nullValue.tag, nullValue.deserialize], [0x04, numberValue.tag, numberValue.deserialize], [0x05, stringValue.tag, stringValue.deserialize], [0x06, symbolValue.tag, symbolValue.deserialize], [0x07, undefinedValue.tag, undefinedValue.deserialize], [0x08, objectValue.tag, objectValue.deserialize], [0x09, statsDescriptors.iterableTag, statsDescriptors.deserializeIterableStats], [0x0A, statsDescriptors.listTag, statsDescriptors.deserializeListStats], [0x0B, itemDescriptor.complexTag, itemDescriptor.deserializeComplex], [0x0C, itemDescriptor.primitiveTag, itemDescriptor.deserializePrimitive], [0x0D, statsDescriptors.propertyTag, statsDescriptors.deserializePropertyStats], [0x0E, propertyDescriptor.complexTag, propertyDescriptor.deserializeComplex], [0x0F, propertyDescriptor.primitiveTag, propertyDescriptor.deserializePrimitive], [0x10, pointerDescriptor.tag, pointerDescriptor.deserialize], [0x11, mapValue.tag, mapValue.deserialize], [0x12, mapEntryDescriptor.tag, mapEntryDescriptor.deserialize], [0x13, argumentsValue.tag, argumentsValue.deserialize], [0x14, arrayBufferValue.tag, arrayBufferValue.deserialize], [0x15, boxedValue.tag, boxedValue.deserialize], [0x16, dataViewValue.tag, dataViewValue.deserialize], [0x17, dateValue.tag, dateValue.deserialize], [0x18, errorValue.tag, errorValue.deserialize], [0x19, functionValue.tag, functionValue.deserialize], [0x1A, globalValue.tag, globalValue.deserialize], [0x1B, promiseValue.tag, promiseValue.deserialize], [0x1C, regexpValue.tag, regexpValue.deserialize], [0x1D, setValue.tag, setValue.deserialize], [0x1E, typedArrayValue.tag, typedArrayValue.deserialize], [0x1F, typedArrayValue.bytesTag, typedArrayValue.deserializeBytes]];
var tag2id = new Map(mappings.map(function (mapping) {
  return [mapping[1], mapping[0]];
}));
var id2deserialize = new Map(mappings.map(function (mapping) {
  return [mapping[0], mapping[2]];
}));

var DescriptorSerializationError =
/*#__PURE__*/
function (_Error) {
  _inherits(DescriptorSerializationError, _Error);

  function DescriptorSerializationError(descriptor) {
    var _this;

    _classCallCheck(this, DescriptorSerializationError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DescriptorSerializationError).call(this, 'Could not serialize descriptor'));
    _this.name = 'DescriptorSerializationError';
    _this.descriptor = descriptor;
    return _this;
  }

  return DescriptorSerializationError;
}(_wrapNativeSuper(Error));

var MissingPluginError =
/*#__PURE__*/
function (_Error2) {
  _inherits(MissingPluginError, _Error2);

  function MissingPluginError(pluginName) {
    var _this2;

    _classCallCheck(this, MissingPluginError);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(MissingPluginError).call(this, "Could not deserialize buffer: missing plugin ".concat(JSON.stringify(pluginName))));
    _this2.name = 'MissingPluginError';
    _this2.pluginName = pluginName;
    return _this2;
  }

  return MissingPluginError;
}(_wrapNativeSuper(Error));

var PointerLookupError =
/*#__PURE__*/
function (_Error3) {
  _inherits(PointerLookupError, _Error3);

  function PointerLookupError(index) {
    var _this3;

    _classCallCheck(this, PointerLookupError);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(PointerLookupError).call(this, "Could not deserialize buffer: pointer ".concat(index, " could not be resolved")));
    _this3.name = 'PointerLookupError';
    _this3.index = index;
    return _this3;
  }

  return PointerLookupError;
}(_wrapNativeSuper(Error));

var UnsupportedPluginError =
/*#__PURE__*/
function (_Error4) {
  _inherits(UnsupportedPluginError, _Error4);

  function UnsupportedPluginError(pluginName, serializerVersion) {
    var _this4;

    _classCallCheck(this, UnsupportedPluginError);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(UnsupportedPluginError).call(this, "Could not deserialize buffer: plugin ".concat(JSON.stringify(pluginName), " expects a different serialization")));
    _this4.name = 'UnsupportedPluginError';
    _this4.pluginName = pluginName;
    _this4.serializerVersion = serializerVersion;
    return _this4;
  }

  return UnsupportedPluginError;
}(_wrapNativeSuper(Error));

var UnsupportedVersion =
/*#__PURE__*/
function (_Error5) {
  _inherits(UnsupportedVersion, _Error5);

  // eslint-disable-line unicorn/custom-error-definition
  function UnsupportedVersion(serializerVersion) {
    var _this5;

    _classCallCheck(this, UnsupportedVersion);

    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(UnsupportedVersion).call(this, 'Could not deserialize buffer: a different serialization was expected'));
    _this5.name = 'UnsupportedVersion';
    _this5.serializerVersion = serializerVersion;
    return _this5;
  }

  return UnsupportedVersion;
}(_wrapNativeSuper(Error));

function shallowSerializeDescriptor(descriptor, resolvePluginRef) {
  if (!descriptor.serialize) return undefined;
  return serializeState(descriptor.serialize(), resolvePluginRef);
}

function serializeState(state, resolvePluginRef) {
  if (Array.isArray(state)) return state.map(function (x) {
    return serializeState(x);
  });

  if (state && state.tag) {
    var id, pluginIndex;

    if (tag2id.has(state.tag)) {
      id = tag2id.get(state.tag);
      pluginIndex = 0;
    } else {
      var ref = resolvePluginRef(state.tag);

      if (ref) {
        id = ref.id;
        pluginIndex = ref.pluginIndex;
      }
    }

    if (id !== undefined) {
      var serialized = [pluginIndex, id, shallowSerializeDescriptor(state, resolvePluginRef)];
      serialized[encoder.descriptorSymbol] = true;
      return serialized;
    }
  }

  return state;
}

function serialize(descriptor) {
  var usedPlugins = new Map();

  var resolvePluginRef = function resolvePluginRef(tag) {
    var ref = pluginRegistry.resolveDescriptorRef(tag);
    if (!ref) return null;

    if (!usedPlugins.has(ref.name)) {
      // Start at 1, since 0 is reserved for Concordance's descriptors.
      var index = usedPlugins.size + 1;
      usedPlugins.set(ref.name, Object.assign({
        index: index
      }, ref.serialization));
    }

    return {
      id: ref.id,
      pluginIndex: usedPlugins.get(ref.name).index
    };
  };

  var seen = new Set();
  var stack = [];
  var topIndex = -1;
  var rootRecord;

  do {
    if (descriptor.isComplex === true) {
      if (seen.has(descriptor.pointer)) {
        descriptor = pointerDescriptor.describe(descriptor.pointer);
      } else {
        seen.add(descriptor.pointer);
      }
    }

    var id = void 0;
    var pluginIndex = 0;

    if (tag2id.has(descriptor.tag)) {
      id = tag2id.get(descriptor.tag);
    } else {
      var ref = resolvePluginRef(descriptor.tag);
      if (!ref) throw new DescriptorSerializationError(descriptor);
      id = ref.id;
      pluginIndex = ref.pluginIndex;
    }

    var record = {
      id: id,
      pluginIndex: pluginIndex,
      children: [],
      state: shallowSerializeDescriptor(descriptor, resolvePluginRef)
    };

    if (!rootRecord) {
      rootRecord = record;
    } else {
      stack[topIndex].children.push(record);
    }

    if (descriptor.createRecursor) {
      stack.push({
        recursor: descriptor.createRecursor(),
        children: record.children
      });
      topIndex++;
    }

    while (topIndex >= 0) {
      descriptor = stack[topIndex].recursor();

      if (descriptor === null) {
        stack.pop();
        topIndex--;
      } else {
        break;
      }
    }
  } while (topIndex >= 0);

  return encoder.encode(VERSION, rootRecord, usedPlugins);
}

exports.serialize = serialize;

function deserializeState(state, getDescriptorDeserializer) {
  if (state && state[encoder.descriptorSymbol] === true) {
    return shallowDeserializeDescriptor(state, getDescriptorDeserializer);
  }

  return Array.isArray(state) ? state.map(function (item) {
    return deserializeState(item, getDescriptorDeserializer);
  }) : state;
}

function shallowDeserializeDescriptor(entry, getDescriptorDeserializer) {
  var deserializeDescriptor = getDescriptorDeserializer(entry[0], entry[1]);
  return deserializeDescriptor(entry[2]);
}

function deserializeRecord(record, getDescriptorDeserializer, buffer) {
  var deserializeDescriptor = getDescriptorDeserializer(record.pluginIndex, record.id);
  var state = deserializeState(record.state, getDescriptorDeserializer);

  if (record.pointerAddresses.length === 0) {
    return deserializeDescriptor(state);
  }

  var endIndex = record.pointerAddresses.length;
  var index = 0;

  var recursor = function recursor() {
    if (index === endIndex) return null;
    var recursorRecord = encoder.decodeRecord(buffer, record.pointerAddresses[index++]);
    return deserializeRecord(recursorRecord, getDescriptorDeserializer, buffer);
  };

  return deserializeDescriptor(state, recursor);
}

function buildPluginMap(buffer, options) {
  var cache = options && options.deserializedPluginsCache;
  var cacheKey = md5hex(buffer);
  if (cache && cache.has(cacheKey)) return cache.get(cacheKey);
  var decodedPlugins = encoder.decodePlugins(buffer);

  if (decodedPlugins.size === 0) {
    var _pluginMap = new Map();

    if (cache) cache.set(cacheKey, _pluginMap);
    return _pluginMap;
  }

  var deserializerLookup = new Map();

  if (Array.isArray(options && options.plugins)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = pluginRegistry.getDeserializers(options.plugins)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var deserializer = _step.value;
        deserializerLookup.set(deserializer.name, deserializer);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  var pluginMap = new Map();
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = decodedPlugins.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var index = _step2.value;
      var used = decodedPlugins.get(index);
      var pluginName = used.name;
      var serializerVersion = used.serializerVersion; // TODO: Allow plugin author to encode a helpful message in its serialization

      if (!deserializerLookup.has(pluginName)) {
        throw new MissingPluginError(pluginName);
      }

      if (serializerVersion !== deserializerLookup.get(pluginName).serializerVersion) {
        throw new UnsupportedPluginError(pluginName, serializerVersion);
      }

      pluginMap.set(index, deserializerLookup.get(pluginName).id2deserialize);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  if (cache) cache.set(cacheKey, pluginMap);
  return pluginMap;
}

function deserialize(buffer, options) {
  var version = encoder.extractVersion(buffer);
  if (version !== VERSION) throw new UnsupportedVersion(version);
  var decoded = encoder.decode(buffer);
  var pluginMap = buildPluginMap(decoded.pluginBuffer, options);
  var descriptorsByPointerIndex = new Map();

  var mapPointerDescriptor = function mapPointerDescriptor(descriptor) {
    if (descriptor.isPointer === true) {
      if (descriptorsByPointerIndex.has(descriptor.index)) {
        return descriptorsByPointerIndex.get(descriptor.index);
      }

      if (typeof rootDescriptor.createRecursor === 'function') {
        // The descriptor we're pointing to may be elsewhere in the serialized
        // structure. Consume the entire structure and check again.
        recursorUtils.consumeDeep(rootDescriptor.createRecursor());

        if (descriptorsByPointerIndex.has(descriptor.index)) {
          return descriptorsByPointerIndex.get(descriptor.index);
        }
      }

      throw new PointerLookupError(descriptor.index);
    }

    if (descriptor.isComplex === true) {
      descriptorsByPointerIndex.set(descriptor.pointer, descriptor);
    }

    return descriptor;
  };

  var getDescriptorDeserializer = function getDescriptorDeserializer(pluginIndex, id) {
    return function (state, recursor) {
      var deserializeDescriptor = pluginIndex === 0 ? id2deserialize.get(id) : pluginMap.get(pluginIndex).get(id);
      return mapPointerDescriptor(deserializeDescriptor(state, recursor));
    };
  };

  var rootDescriptor = deserializeRecord(decoded.rootRecord, getDescriptorDeserializer, buffer);
  return rootDescriptor;
}

exports.deserialize = deserialize;