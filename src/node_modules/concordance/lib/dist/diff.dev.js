'use strict';

var Circular = require('./Circular');

var Indenter = require('./Indenter');

var constants = require('./constants');

var describe = require('./describe');

var lineBuilder = require('./lineBuilder');

var recursorUtils = require('./recursorUtils');

var shouldCompareDeep = require('./shouldCompareDeep');

var symbolProperties = require('./symbolProperties');

var themeUtils = require('./themeUtils');

var AMBIGUOUS = constants.AMBIGUOUS;
var DEEP_EQUAL = constants.DEEP_EQUAL;
var UNEQUAL = constants.UNEQUAL;
var SHALLOW_EQUAL = constants.SHALLOW_EQUAL;
var NOOP = Symbol('NOOP');

var alwaysFormat = function alwaysFormat() {
  return true;
};

function compareComplexShape(lhs, rhs) {
  var result = lhs.compare(rhs);
  if (result === DEEP_EQUAL) return DEEP_EQUAL;
  if (result === UNEQUAL || !shouldCompareDeep(result, lhs, rhs)) return UNEQUAL;
  var collectedSymbolProperties = false;
  var lhsRecursor = lhs.createRecursor();
  var rhsRecursor = rhs.createRecursor();

  do {
    lhs = lhsRecursor();
    rhs = rhsRecursor();
    if (lhs === null && rhs === null) return SHALLOW_EQUAL;
    if (lhs === null || rhs === null) return UNEQUAL;
    result = lhs.compare(rhs);
    if (result === UNEQUAL) return UNEQUAL;

    if (result === AMBIGUOUS && lhs.isProperty === true && !collectedSymbolProperties && shouldCompareDeep(result, lhs, rhs)) {
      collectedSymbolProperties = true;
      var lhsCollector = new symbolProperties.Collector(lhs, lhsRecursor);
      var rhsCollector = new symbolProperties.Collector(rhs, rhsRecursor);
      lhsRecursor = recursorUtils.sequence(lhsCollector.createRecursor(), recursorUtils.unshift(lhsRecursor, lhsCollector.collectAll()));
      rhsRecursor = recursorUtils.sequence(rhsCollector.createRecursor(), recursorUtils.unshift(rhsRecursor, rhsCollector.collectAll()));
    }
  } while (true);
}

function diffDescriptors(lhs, rhs, options) {
  var theme = themeUtils.normalize(options);
  var invert = options ? options.invert === true : false;
  var lhsCircular = new Circular();
  var rhsCircular = new Circular();
  var maxDepth = options && options.maxDepth || 0;
  var indent = new Indenter(0, '  ');
  var lhsStack = [];
  var rhsStack = [];
  var topIndex = -1;
  var buffer = lineBuilder.buffer();
  var diffStack = [];
  var diffIndex = -1;

  var isCircular = function isCircular(descriptor) {
    return lhsCircular.has(descriptor) || rhsCircular.has(descriptor);
  };

  var format = function format(builder, subject, circular) {
    var depthOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    if (diffIndex >= 0 && !diffStack[diffIndex].shouldFormat(subject)) return;

    if (circular.has(subject)) {
      diffStack[diffIndex].formatter.append(builder.single(theme.circular));
      return;
    }

    var formatStack = [];
    var formatIndex = -1;

    do {
      if (circular.has(subject)) {
        formatStack[formatIndex].formatter.append(builder.single(theme.circular), subject);
      } else {
        var didFormat = false;

        if (typeof subject.formatDeep === 'function') {
          var formatted = subject.formatDeep(themeUtils.applyModifiers(subject, theme), indent);

          if (formatted !== null) {
            didFormat = true;

            if (formatIndex === -1) {
              formatted = builder.setDefaultGutter(formatted);

              if (diffIndex === -1) {
                buffer.append(formatted);
              } else {
                diffStack[diffIndex].formatter.append(formatted, subject);
              }
            } else {
              formatStack[formatIndex].formatter.append(formatted, subject);
            }
          }
        }

        if (!didFormat && typeof subject.formatShallow === 'function') {
          var formatter = subject.formatShallow(themeUtils.applyModifiers(subject, theme), indent);
          var recursor = subject.createRecursor();

          if (formatter.increaseIndent && maxDepth > 0 && indent.level === maxDepth + depthOffset) {
            var isEmpty = recursor() === null;

            var _formatted = !isEmpty && typeof formatter.maxDepth === 'function' ? formatter.maxDepth() : formatter.finalize();

            if (formatIndex === -1) {
              _formatted = builder.setDefaultGutter(_formatted);
              diffStack[diffIndex].formatter.append(_formatted, subject);
            } else {
              formatStack[formatIndex].formatter.append(_formatted, subject);
            }
          } else {
            formatStack.push({
              formatter: formatter,
              recursor: recursor,
              decreaseIndent: formatter.increaseIndent,
              shouldFormat: formatter.shouldFormat || alwaysFormat,
              subject: subject
            });
            formatIndex++;
            if (formatter.increaseIndent) indent = indent.increase();
            circular.add(subject);
          }
        }
      }

      while (formatIndex >= 0) {
        do {
          subject = formatStack[formatIndex].recursor();
        } while (subject && !formatStack[formatIndex].shouldFormat(subject));

        if (subject) {
          break;
        }

        var record = formatStack.pop();
        formatIndex--;
        if (record.decreaseIndent) indent = indent.decrease();
        circular["delete"](record.subject);

        var _formatted2 = record.formatter.finalize();

        if (formatIndex === -1) {
          _formatted2 = builder.setDefaultGutter(_formatted2);

          if (diffIndex === -1) {
            buffer.append(_formatted2);
          } else {
            diffStack[diffIndex].formatter.append(_formatted2, record.subject);
          }
        } else {
          formatStack[formatIndex].formatter.append(_formatted2, record.subject);
        }
      }
    } while (formatIndex >= 0);
  };

  do {
    var compareResult = NOOP;

    if (lhsCircular.has(lhs)) {
      compareResult = lhsCircular.get(lhs) === rhsCircular.get(rhs) ? DEEP_EQUAL : UNEQUAL;
    } else if (rhsCircular.has(rhs)) {
      compareResult = UNEQUAL;
    }

    var firstPassSymbolProperty = false;

    if (lhs.isProperty === true) {
      compareResult = lhs.compare(rhs);

      if (compareResult === AMBIGUOUS) {
        var parent = lhsStack[topIndex].subject;
        firstPassSymbolProperty = parent.isSymbolPropertiesCollector !== true && parent.isSymbolPropertiesComparable !== true;
      }
    }

    var didFormat = false;
    var mustRecurse = false;

    if (compareResult !== DEEP_EQUAL && !firstPassSymbolProperty && typeof lhs.prepareDiff === 'function') {
      var lhsRecursor = topIndex === -1 ? null : lhsStack[topIndex].recursor;
      var rhsRecursor = topIndex === -1 ? null : rhsStack[topIndex].recursor;
      var instructions = lhs.prepareDiff(rhs, lhsRecursor, rhsRecursor, compareComplexShape, isCircular);

      if (instructions !== null) {
        if (topIndex >= 0) {
          if (typeof instructions.lhsRecursor === 'function') {
            lhsStack[topIndex].recursor = instructions.lhsRecursor;
          }

          if (typeof instructions.rhsRecursor === 'function') {
            rhsStack[topIndex].recursor = instructions.rhsRecursor;
          }
        }

        if (instructions.compareResult) {
          compareResult = instructions.compareResult;
        }

        if (instructions.mustRecurse === true) {
          mustRecurse = true;
        } else {
          if (instructions.actualIsExtraneous === true) {
            format(lineBuilder.actual, lhs, lhsCircular);
            didFormat = true;
          } else if (instructions.multipleAreExtraneous === true) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = instructions.descriptors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var extraneous = _step.value;
                format(lineBuilder.actual, extraneous, lhsCircular);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                  _iterator["return"]();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            didFormat = true;
          } else if (instructions.expectedIsMissing === true) {
            format(lineBuilder.expected, rhs, rhsCircular);
            didFormat = true;
          } else if (instructions.multipleAreMissing === true) {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = instructions.descriptors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var missing = _step2.value;
                format(lineBuilder.expected, missing, rhsCircular);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            didFormat = true;
          } else if (instructions.isUnequal === true) {
            format(lineBuilder.actual, lhs, lhsCircular);
            format(lineBuilder.expected, rhs, rhsCircular);
            didFormat = true;
          } else if (!instructions.compareResult) {
            // TODO: Throw a useful, custom error
            throw new Error('Illegal result of prepareDiff()');
          }
        }
      }
    }

    if (!didFormat) {
      if (compareResult === NOOP) {
        compareResult = lhs.compare(rhs);
      }

      if (!mustRecurse) {
        mustRecurse = shouldCompareDeep(compareResult, lhs, rhs);
      }

      if (compareResult === DEEP_EQUAL) {
        format(lineBuilder, lhs, lhsCircular);
      } else if (mustRecurse) {
        if (compareResult === AMBIGUOUS && lhs.isProperty === true) {
          // Replace both sides by a pseudo-descriptor which collects symbol
          // properties instead.
          lhs = new symbolProperties.Collector(lhs, lhsStack[topIndex].recursor);
          rhs = new symbolProperties.Collector(rhs, rhsStack[topIndex].recursor); // Replace the current recursors so they can continue correctly after
          // the collectors have been "compared". This is necessary since the
          // collectors eat the first value after the last symbol property.

          lhsStack[topIndex].recursor = recursorUtils.unshift(lhsStack[topIndex].recursor, lhs.collectAll());
          rhsStack[topIndex].recursor = recursorUtils.unshift(rhsStack[topIndex].recursor, rhs.collectAll());
        }

        if (typeof lhs.diffShallow === 'function') {
          var formatter = lhs.diffShallow(rhs, themeUtils.applyModifiers(lhs, theme), indent);
          diffStack.push({
            formatter: formatter,
            origin: lhs,
            decreaseIndent: formatter.increaseIndent,
            exceedsMaxDepth: formatter.increaseIndent && maxDepth > 0 && indent.level >= maxDepth,
            shouldFormat: formatter.shouldFormat || alwaysFormat
          });
          diffIndex++;
          if (formatter.increaseIndent) indent = indent.increase();
        } else if (typeof lhs.formatShallow === 'function') {
          var _formatter = lhs.formatShallow(themeUtils.applyModifiers(lhs, theme), indent);

          diffStack.push({
            formatter: _formatter,
            decreaseIndent: _formatter.increaseIndent,
            exceedsMaxDepth: _formatter.increaseIndent && maxDepth > 0 && indent.level >= maxDepth,
            shouldFormat: _formatter.shouldFormat || alwaysFormat,
            subject: lhs
          });
          diffIndex++;
          if (_formatter.increaseIndent) indent = indent.increase();
        }

        lhsCircular.add(lhs);
        rhsCircular.add(rhs);
        lhsStack.push({
          diffIndex: diffIndex,
          subject: lhs,
          recursor: lhs.createRecursor()
        });
        rhsStack.push({
          diffIndex: diffIndex,
          subject: rhs,
          recursor: rhs.createRecursor()
        });
        topIndex++;
      } else {
        var diffed = typeof lhs.diffDeep === 'function' ? lhs.diffDeep(rhs, themeUtils.applyModifiers(lhs, theme), indent, invert) : null;

        if (diffed === null) {
          format(lineBuilder.actual, lhs, lhsCircular);
          format(lineBuilder.expected, rhs, rhsCircular);
        } else {
          if (diffIndex === -1) {
            buffer.append(diffed);
          } else {
            diffStack[diffIndex].formatter.append(diffed, lhs);
          }
        }
      }
    }

    while (topIndex >= 0) {
      lhs = lhsStack[topIndex].recursor();
      rhs = rhsStack[topIndex].recursor();

      if (lhs !== null && rhs !== null) {
        break;
      }

      if (lhs === null && rhs === null) {
        var lhsRecord = lhsStack.pop();
        var rhsRecord = rhsStack.pop();
        lhsCircular["delete"](lhsRecord.subject);
        rhsCircular["delete"](rhsRecord.subject);
        topIndex--;

        if (lhsRecord.diffIndex === diffIndex) {
          var record = diffStack.pop();
          diffIndex--;
          if (record.decreaseIndent) indent = indent.decrease();
          var formatted = record.formatter.finalize();

          if (record.exceedsMaxDepth && !formatted.hasGutter) {
            // The record exceeds the max depth, but contains no actual diff.
            // Discard the potentially deep formatting and format just the
            // original subject.
            var subject = lhsRecord.subject;

            var _formatter2 = subject.formatShallow(themeUtils.applyModifiers(subject, theme), indent);

            var isEmpty = subject.createRecursor()() === null;
            formatted = !isEmpty && typeof _formatter2.maxDepth === 'function' ? _formatter2.maxDepth() : _formatter2.finalize();
          }

          if (diffIndex === -1) {
            buffer.append(formatted);
          } else {
            diffStack[diffIndex].formatter.append(formatted, record.subject);
          }
        }
      } else {
        var builder = void 0,
            circular = void 0,
            stack = void 0,
            _subject = void 0;

        if (lhs === null) {
          builder = lineBuilder.expected;
          circular = rhsCircular;
          stack = rhsStack;
          _subject = rhs;
        } else {
          builder = lineBuilder.actual;
          circular = lhsCircular;
          stack = lhsStack;
          _subject = lhs;
        }

        do {
          format(builder, _subject, circular, indent.level);
          _subject = stack[topIndex].recursor();
        } while (_subject !== null);
      }
    }
  } while (topIndex >= 0);

  return buffer.toString({
    diff: true,
    invert: invert,
    theme: theme
  });
}

exports.diffDescriptors = diffDescriptors;

function diff(actual, expected, options) {
  return diffDescriptors(describe(actual, options), describe(expected, options), options);
}

exports.diff = diff;