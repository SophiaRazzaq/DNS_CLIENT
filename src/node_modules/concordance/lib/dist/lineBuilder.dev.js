'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ACTUAL = Symbol('lineBuilder.gutters.ACTUAL');
var EXPECTED = Symbol('lineBuilder.gutters.EXPECTED');

function translateGutter(theme, invert, gutter) {
  if (invert) {
    if (gutter === ACTUAL) return theme.diffGutters.expected;
    if (gutter === EXPECTED) return theme.diffGutters.actual;
  } else {
    if (gutter === ACTUAL) return theme.diffGutters.actual;
    if (gutter === EXPECTED) return theme.diffGutters.expected;
  }

  return theme.diffGutters.padding;
}

var Line =
/*#__PURE__*/
function () {
  function Line(isFirst, isLast, gutter, stringValue) {
    _classCallCheck(this, Line);

    this.isFirst = isFirst;
    this.isLast = isLast;
    this.gutter = gutter;
    this.stringValue = stringValue;
  }

  _createClass(Line, [{
    key: Symbol.iterator,
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function value() {
      return regeneratorRuntime.wrap(function value$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this;

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, value, this);
    })
  }, {
    key: "append",
    value: function append(other) {
      return this.concat(other);
    }
  }, {
    key: "concat",
    value: function concat(other) {
      return new Collection().append(this).append(other);
    }
  }, {
    key: "toString",
    value: function toString(options) {
      if (options.diff === false) return this.stringValue;
      return translateGutter(options.theme, options.invert, this.gutter) + this.stringValue;
    }
  }, {
    key: "mergeWithInfix",
    value: function mergeWithInfix(infix, other) {
      if (other.isLine !== true) {
        return new Collection().append(this).mergeWithInfix(infix, other);
      }

      return new Line(this.isFirst, other.isLast, other.gutter, this.stringValue + infix + other.stringValue);
    }
  }, {
    key: "withFirstPrefixed",
    value: function withFirstPrefixed(prefix) {
      if (!this.isFirst) return this;
      return new Line(true, this.isLast, this.gutter, prefix + this.stringValue);
    }
  }, {
    key: "withLastPostfixed",
    value: function withLastPostfixed(postfix) {
      if (!this.isLast) return this;
      return new Line(this.isFirst, true, this.gutter, this.stringValue + postfix);
    }
  }, {
    key: "stripFlags",
    value: function stripFlags() {
      return new Line(false, false, this.gutter, this.stringValue);
    }
  }, {
    key: "decompose",
    value: function decompose() {
      return new Collection().append(this).decompose();
    }
  }, {
    key: "isEmpty",
    get: function get() {
      return false;
    }
  }, {
    key: "hasGutter",
    get: function get() {
      return this.gutter !== null;
    }
  }, {
    key: "isSingle",
    get: function get() {
      return this.isFirst && this.isLast;
    }
  }]);

  return Line;
}();

Object.defineProperty(Line.prototype, 'isLine', {
  value: true
});

var Collection =
/*#__PURE__*/
function () {
  function Collection() {
    _classCallCheck(this, Collection);

    this.buffer = [];
  }

  _createClass(Collection, [{
    key: Symbol.iterator,
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function value() {
      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, appended, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, line;

      return regeneratorRuntime.wrap(function value$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context2.prev = 3;
              _iterator = this.buffer[Symbol.iterator]();

            case 5:
              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                _context2.next = 36;
                break;
              }

              appended = _step.value;
              _iteratorNormalCompletion2 = true;
              _didIteratorError2 = false;
              _iteratorError2 = undefined;
              _context2.prev = 10;
              _iterator2 = appended[Symbol.iterator]();

            case 12:
              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                _context2.next = 19;
                break;
              }

              line = _step2.value;
              _context2.next = 16;
              return line;

            case 16:
              _iteratorNormalCompletion2 = true;
              _context2.next = 12;
              break;

            case 19:
              _context2.next = 25;
              break;

            case 21:
              _context2.prev = 21;
              _context2.t0 = _context2["catch"](10);
              _didIteratorError2 = true;
              _iteratorError2 = _context2.t0;

            case 25:
              _context2.prev = 25;
              _context2.prev = 26;

              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }

            case 28:
              _context2.prev = 28;

              if (!_didIteratorError2) {
                _context2.next = 31;
                break;
              }

              throw _iteratorError2;

            case 31:
              return _context2.finish(28);

            case 32:
              return _context2.finish(25);

            case 33:
              _iteratorNormalCompletion = true;
              _context2.next = 5;
              break;

            case 36:
              _context2.next = 42;
              break;

            case 38:
              _context2.prev = 38;
              _context2.t1 = _context2["catch"](3);
              _didIteratorError = true;
              _iteratorError = _context2.t1;

            case 42:
              _context2.prev = 42;
              _context2.prev = 43;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 45:
              _context2.prev = 45;

              if (!_didIteratorError) {
                _context2.next = 48;
                break;
              }

              throw _iteratorError;

            case 48:
              return _context2.finish(45);

            case 49:
              return _context2.finish(42);

            case 50:
            case "end":
              return _context2.stop();
          }
        }
      }, value, this, [[3, 38, 42, 50], [10, 21, 25, 33], [26,, 28, 32], [43,, 45, 49]]);
    })
  }, {
    key: "append",
    value: function append(lineOrLines) {
      if (!lineOrLines.isEmpty) this.buffer.push(lineOrLines);
      return this;
    }
  }, {
    key: "concat",
    value: function concat(other) {
      return new Collection().append(this).append(other);
    }
  }, {
    key: "toString",
    value: function toString(options) {
      var lines = this;

      if (options.invert) {
        lines = new Collection();
        var buffer = new Collection();
        var prev = null;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var line = _step3.value;

            if (line.gutter === ACTUAL) {
              if (prev !== null && prev.gutter !== ACTUAL && !buffer.isEmpty) {
                lines.append(buffer);
                buffer = new Collection();
              }

              buffer.append(line);
            } else if (line.gutter === EXPECTED) {
              lines.append(line);
            } else {
              if (!buffer.isEmpty) {
                lines.append(buffer);
                buffer = new Collection();
              }

              lines.append(line);
            }

            prev = line;
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        lines.append(buffer);
      }

      return Array.from(lines, function (line) {
        return line.toString(options);
      }).join('\n');
    }
  }, {
    key: "mergeWithInfix",
    value: function mergeWithInfix(infix, from) {
      if (from.isEmpty) throw new Error('Cannot merge, `from` is empty.');
      var otherLines = Array.from(from);
      if (!otherLines[0].isFirst) throw new Error('Cannot merge, `from` has no first line.');
      var merged = new Collection();
      var seenLast = false;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = this[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var line = _step4.value;
          if (seenLast) throw new Error('Cannot merge line, the last line has already been seen.');

          if (!line.isLast) {
            merged.append(line);
            continue;
          }

          seenLast = true;
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = otherLines[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var other = _step5.value;

              if (other.isFirst) {
                merged.append(line.mergeWithInfix(infix, other));
              } else {
                merged.append(other);
              }
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                _iterator5["return"]();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return merged;
    }
  }, {
    key: "withFirstPrefixed",
    value: function withFirstPrefixed(prefix) {
      return new Collection().append(Array.from(this, function (line) {
        return line.withFirstPrefixed(prefix);
      }));
    }
  }, {
    key: "withLastPostfixed",
    value: function withLastPostfixed(postfix) {
      return new Collection().append(Array.from(this, function (line) {
        return line.withLastPostfixed(postfix);
      }));
    }
  }, {
    key: "stripFlags",
    value: function stripFlags() {
      return new Collection().append(Array.from(this, function (line) {
        return line.stripFlags();
      }));
    }
  }, {
    key: "decompose",
    value: function decompose() {
      var first = {
        actual: new Collection(),
        expected: new Collection()
      };
      var last = {
        actual: new Collection(),
        expected: new Collection()
      };
      var remaining = new Collection();
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = this[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var line = _step6.value;

          if (line.isFirst && line.gutter === ACTUAL) {
            first.actual.append(line);
          } else if (line.isFirst && line.gutter === EXPECTED) {
            first.expected.append(line);
          } else if (line.isLast && line.gutter === ACTUAL) {
            last.actual.append(line);
          } else if (line.isLast && line.gutter === EXPECTED) {
            last.expected.append(line);
          } else {
            remaining.append(line);
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      return {
        first: first,
        last: last,
        remaining: remaining
      };
    }
  }, {
    key: "isEmpty",
    get: function get() {
      return this.buffer.length === 0;
    }
  }, {
    key: "hasGutter",
    get: function get() {
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = this[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var line = _step7.value;
          if (line.hasGutter) return true;
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
            _iterator7["return"]();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      return false;
    }
  }, {
    key: "isSingle",
    get: function get() {
      var iterator = this[Symbol.iterator]();
      iterator.next();
      return iterator.next().done === true;
    }
  }]);

  return Collection;
}();

Object.defineProperty(Collection.prototype, 'isCollection', {
  value: true
});

function _setDefaultGutter(iterable, gutter) {
  return new Collection().append(Array.from(iterable, function (line) {
    return line.gutter === null ? new Line(line.isFirst, line.isLast, gutter, line.stringValue) : line;
  }));
}

module.exports = {
  buffer: function buffer() {
    return new Collection();
  },
  first: function first(stringValue) {
    return new Line(true, false, null, stringValue);
  },
  last: function last(stringValue) {
    return new Line(false, true, null, stringValue);
  },
  line: function line(stringValue) {
    return new Line(false, false, null, stringValue);
  },
  single: function single(stringValue) {
    return new Line(true, true, null, stringValue);
  },
  setDefaultGutter: function setDefaultGutter(lineOrCollection) {
    return lineOrCollection;
  },
  actual: {
    first: function first(stringValue) {
      return new Line(true, false, ACTUAL, stringValue);
    },
    last: function last(stringValue) {
      return new Line(false, true, ACTUAL, stringValue);
    },
    line: function line(stringValue) {
      return new Line(false, false, ACTUAL, stringValue);
    },
    single: function single(stringValue) {
      return new Line(true, true, ACTUAL, stringValue);
    },
    setDefaultGutter: function setDefaultGutter(lineOrCollection) {
      return _setDefaultGutter(lineOrCollection, ACTUAL);
    }
  },
  expected: {
    first: function first(stringValue) {
      return new Line(true, false, EXPECTED, stringValue);
    },
    last: function last(stringValue) {
      return new Line(false, true, EXPECTED, stringValue);
    },
    line: function line(stringValue) {
      return new Line(false, false, EXPECTED, stringValue);
    },
    single: function single(stringValue) {
      return new Line(true, true, EXPECTED, stringValue);
    },
    setDefaultGutter: function setDefaultGutter(lineOrCollection) {
      return _setDefaultGutter(lineOrCollection, EXPECTED);
    }
  }
};