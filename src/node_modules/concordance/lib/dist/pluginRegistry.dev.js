'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var semver = require('semver');

var pkg = require('../package.json');

var object = require('./complexValues/object');

var constants = require('./constants');

var formatUtils = require('./formatUtils');

var lineBuilder = require('./lineBuilder');

var itemDescriptor = require('./metaDescriptors/item');

var propertyDescriptor = require('./metaDescriptors/property');

var stringDescriptor = require('./primitiveValues/string');

var recursorUtils = require('./recursorUtils');

var themeUtils = require('./themeUtils');

var API_VERSION = 1;
var CONCORDANCE_VERSION = pkg.version;
var descriptorRegistry = new Map();
var registry = new Map();

var PluginError =
/*#__PURE__*/
function (_Error) {
  _inherits(PluginError, _Error);

  function PluginError(message, plugin) {
    var _this;

    _classCallCheck(this, PluginError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PluginError).call(this, message));
    _this.name = 'PluginError';
    _this.plugin = plugin;
    return _this;
  }

  return PluginError;
}(_wrapNativeSuper(Error));

var PluginTypeError =
/*#__PURE__*/
function (_TypeError) {
  _inherits(PluginTypeError, _TypeError);

  function PluginTypeError(message, plugin) {
    var _this2;

    _classCallCheck(this, PluginTypeError);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(PluginTypeError).call(this, message));
    _this2.name = 'PluginTypeError';
    _this2.plugin = plugin;
    return _this2;
  }

  return PluginTypeError;
}(_wrapNativeSuper(TypeError));

var UnsupportedApiError =
/*#__PURE__*/
function (_PluginError) {
  _inherits(UnsupportedApiError, _PluginError);

  function UnsupportedApiError(plugin) {
    var _this3;

    _classCallCheck(this, UnsupportedApiError);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(UnsupportedApiError).call(this, 'Plugin requires an unsupported API version', plugin));
    _this3.name = 'UnsupportedApiError';
    return _this3;
  }

  return UnsupportedApiError;
}(PluginError);

var UnsupportedError =
/*#__PURE__*/
function (_PluginError2) {
  _inherits(UnsupportedError, _PluginError2);

  function UnsupportedError(plugin) {
    var _this4;

    _classCallCheck(this, UnsupportedError);

    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(UnsupportedError).call(this, 'Plugin does not support this version of Concordance', plugin));
    _this4.name = 'UnsupportedError';
    return _this4;
  }

  return UnsupportedError;
}(PluginError);

var DuplicateDescriptorTagError =
/*#__PURE__*/
function (_PluginError3) {
  _inherits(DuplicateDescriptorTagError, _PluginError3);

  function DuplicateDescriptorTagError(tag, plugin) {
    var _this5;

    _classCallCheck(this, DuplicateDescriptorTagError);

    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(DuplicateDescriptorTagError).call(this, "Could not add descriptor: tag ".concat(String(tag), " has already been registered"), plugin));
    _this5.name = 'DuplicateDescriptorTagError';
    _this5.tag = tag;
    return _this5;
  }

  return DuplicateDescriptorTagError;
}(PluginError);

var DuplicateDescriptorIdError =
/*#__PURE__*/
function (_PluginError4) {
  _inherits(DuplicateDescriptorIdError, _PluginError4);

  function DuplicateDescriptorIdError(id, plugin) {
    var _this6;

    _classCallCheck(this, DuplicateDescriptorIdError);

    var printed = typeof id === 'number' ? "0x".concat(id.toString(16).toUpperCase()) : String(id);
    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(DuplicateDescriptorIdError).call(this, "Could not add descriptor: id ".concat(printed, " has already been registered"), plugin));
    _this6.name = 'DuplicateDescriptorIdError';
    _this6.id = id;
    return _this6;
  }

  return DuplicateDescriptorIdError;
}(PluginError);

function verify(plugin) {
  if (typeof plugin.name !== 'string' || !plugin.name) {
    throw new PluginTypeError('Plugin must have a `name`', plugin);
  }

  if (plugin.apiVersion !== API_VERSION) {
    throw new UnsupportedApiError(plugin);
  }

  if ('minimalConcordanceVersion' in plugin) {
    if (!semver.valid(plugin.minimalConcordanceVersion)) {
      throw new PluginTypeError('If specified, `minimalConcordanceVersion` must be a valid SemVer version', plugin);
    }

    var range = ">=".concat(plugin.minimalConcordanceVersion);

    if (!semver.satisfies(CONCORDANCE_VERSION, range)) {
      throw new UnsupportedError(plugin);
    }
  }
} // Selectively expose descriptor tags.


var publicDescriptorTags = Object.freeze({
  complexItem: itemDescriptor.complexTag,
  primitiveItem: itemDescriptor.primitiveTag,
  primitiveProperty: propertyDescriptor.primitiveTag,
  string: stringDescriptor.tag
}); // Don't expose `setDefaultGutter()`.

var publicLineBuilder = Object.freeze({
  buffer: lineBuilder.buffer,
  first: lineBuilder.first,
  last: lineBuilder.last,
  line: lineBuilder.line,
  single: lineBuilder.single,
  actual: Object.freeze({
    buffer: lineBuilder.actual.buffer,
    first: lineBuilder.actual.first,
    last: lineBuilder.actual.last,
    line: lineBuilder.actual.line,
    single: lineBuilder.actual.single
  }),
  expected: Object.freeze({
    buffer: lineBuilder.expected.buffer,
    first: lineBuilder.expected.first,
    last: lineBuilder.expected.last,
    line: lineBuilder.expected.line,
    single: lineBuilder.expected.single
  })
});

function modifyTheme(descriptor, modifier) {
  themeUtils.addModifier(descriptor, modifier);
  return descriptor;
}

function add(plugin) {
  verify(plugin);
  var name = plugin.name;
  if (registry.has(name)) return registry.get(name);
  var id2deserialize = new Map();
  var tag2id = new Map();

  var addDescriptor = function addDescriptor(id, tag, deserialize) {
    if (id2deserialize.has(id)) throw new DuplicateDescriptorIdError(id, plugin);
    if (descriptorRegistry.has(tag) || tag2id.has(tag)) throw new DuplicateDescriptorTagError(tag, plugin);
    id2deserialize.set(id, deserialize);
    tag2id.set(tag, id);
  };

  var tryDescribeValue = plugin.register({
    // Concordance makes assumptions about when AMBIGUOUS occurs. Do not expose
    // it to plugins.
    UNEQUAL: constants.UNEQUAL,
    SHALLOW_EQUAL: constants.SHALLOW_EQUAL,
    DEEP_EQUAL: constants.DEEP_EQUAL,
    ObjectValue: object.ObjectValue,
    DescribedMixin: object.DescribedMixin,
    DeserializedMixin: object.DeserializedMixin,
    addDescriptor: addDescriptor,
    applyThemeModifiers: themeUtils.applyModifiers,
    descriptorTags: publicDescriptorTags,
    lineBuilder: publicLineBuilder,
    mapRecursor: recursorUtils.map,
    modifyTheme: modifyTheme,
    wrapFromTheme: formatUtils.wrap
  });
  var registered = {
    id2deserialize: id2deserialize,
    serializerVersion: plugin.serializerVersion,
    name: name,
    tag2id: tag2id,
    theme: plugin.theme || {},
    tryDescribeValue: tryDescribeValue
  };
  registry.set(name, registered);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = tag2id.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var tag = _step.value;
      descriptorRegistry.set(tag, registered);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return registered;
}

exports.add = add;

function getDeserializers(plugins) {
  return plugins.map(function (plugin) {
    var registered = add(plugin);
    return {
      id2deserialize: registered.id2deserialize,
      name: registered.name,
      serializerVersion: registered.serializerVersion
    };
  });
}

exports.getDeserializers = getDeserializers;

function getThemes(plugins) {
  return plugins.map(function (plugin) {
    var registered = add(plugin);
    return {
      name: registered.name,
      theme: registered.theme
    };
  });
}

exports.getThemes = getThemes;

function getTryDescribeValues(plugins) {
  return plugins.map(function (plugin) {
    return add(plugin).tryDescribeValue;
  });
}

exports.getTryDescribeValues = getTryDescribeValues;

function resolveDescriptorRef(tag) {
  if (!descriptorRegistry.has(tag)) return null;
  var registered = descriptorRegistry.get(tag);
  return {
    id: registered.tag2id.get(tag),
    name: registered.name,
    serialization: {
      serializerVersion: registered.serializerVersion
    }
  };
}

exports.resolveDescriptorRef = resolveDescriptorRef;