'use strict';

var Circular = require('./Circular');

var Indenter = require('./Indenter');

var describe = require('./describe');

var lineBuilder = require('./lineBuilder');

var themeUtils = require('./themeUtils');

var alwaysFormat = function alwaysFormat() {
  return true;
};

var fixedIndent = new Indenter(0, '  ');

function formatDescriptor(subject, options) {
  var theme = themeUtils.normalize(options);

  if (subject.isPrimitive === true) {
    var formatted = subject.formatDeep(themeUtils.applyModifiers(subject, theme), fixedIndent);
    return formatted.toString({
      diff: false
    });
  }

  var circular = new Circular();
  var maxDepth = options && options.maxDepth || 0;
  var indent = fixedIndent;
  var buffer = lineBuilder.buffer();
  var stack = [];
  var topIndex = -1;

  do {
    if (circular.has(subject)) {
      stack[topIndex].formatter.append(lineBuilder.single(theme.circular), subject);
    } else {
      var didFormat = false;

      if (typeof subject.formatDeep === 'function') {
        var _formatted = subject.formatDeep(themeUtils.applyModifiers(subject, theme), indent);

        if (_formatted !== null) {
          didFormat = true;

          if (topIndex === -1) {
            buffer.append(_formatted);
          } else {
            stack[topIndex].formatter.append(_formatted, subject);
          }
        }
      }

      if (!didFormat && typeof subject.formatShallow === 'function') {
        var formatter = subject.formatShallow(themeUtils.applyModifiers(subject, theme), indent);
        var recursor = subject.createRecursor();

        if (formatter.increaseIndent && maxDepth > 0 && indent.level === maxDepth) {
          var isEmpty = recursor() === null;

          var _formatted2 = !isEmpty && typeof formatter.maxDepth === 'function' ? formatter.maxDepth() : formatter.finalize();

          stack[topIndex].formatter.append(_formatted2, subject);
        } else {
          stack.push({
            formatter: formatter,
            recursor: recursor,
            decreaseIndent: formatter.increaseIndent,
            shouldFormat: formatter.shouldFormat || alwaysFormat,
            subject: subject
          });
          topIndex++;
          if (formatter.increaseIndent) indent = indent.increase();
          circular.add(subject);
        }
      }
    }

    while (topIndex >= 0) {
      do {
        subject = stack[topIndex].recursor();
      } while (subject && !stack[topIndex].shouldFormat(subject));

      if (subject) {
        break;
      }

      var record = stack.pop();
      topIndex--;
      if (record.decreaseIndent) indent = indent.decrease();
      circular["delete"](record.subject);

      var _formatted3 = record.formatter.finalize();

      if (topIndex === -1) {
        buffer.append(_formatted3);
      } else {
        stack[topIndex].formatter.append(_formatted3, record.subject);
      }
    }
  } while (topIndex >= 0);

  return buffer.toString({
    diff: false
  });
}

exports.formatDescriptor = formatDescriptor;

function format(value, options) {
  return formatDescriptor(describe(value, options), options);
}

exports.format = format;