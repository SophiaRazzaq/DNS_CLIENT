'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var cloneDeep = require('lodash/cloneDeep');

var merge = require('lodash/merge');

var pluginRegistry = require('./pluginRegistry');

function freezeTheme(theme) {
  var queue = [theme];

  while (queue.length > 0) {
    var object = queue.shift();
    Object.freeze(object);

    for (var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      var value = object[key];

      if (value !== null && _typeof(value) === 'object') {
        queue.push(value);
      }
    }
  }

  return theme;
}

var defaultTheme = freezeTheme({
  bigInt: {
    open: '',
    close: ''
  },
  "boolean": {
    open: '',
    close: ''
  },
  circular: '[Circular]',
  date: {
    invalid: 'invalid',
    value: {
      open: '',
      close: ''
    }
  },
  diffGutters: {
    actual: '- ',
    expected: '+ ',
    padding: '  '
  },
  error: {
    ctor: {
      open: '(',
      close: ')'
    },
    name: {
      open: '',
      close: ''
    }
  },
  "function": {
    name: {
      open: '',
      close: ''
    },
    stringTag: {
      open: '',
      close: ''
    }
  },
  global: {
    open: '',
    close: ''
  },
  item: {
    after: ',',
    customFormat: null,
    increaseValueIndent: false
  },
  list: {
    openBracket: '[',
    closeBracket: ']'
  },
  mapEntry: {
    after: ',',
    separator: ' => '
  },
  maxDepth: 'â€¦',
  "null": {
    open: '',
    close: ''
  },
  number: {
    open: '',
    close: ''
  },
  object: {
    openBracket: '{',
    closeBracket: '}',
    ctor: {
      open: '',
      close: ''
    },
    stringTag: {
      open: '@',
      close: ''
    },
    secondaryStringTag: {
      open: '@',
      close: ''
    }
  },
  property: {
    after: ',',
    customFormat: null,
    keyBracket: {
      open: '[',
      close: ']'
    },
    separator: ': ',
    increaseValueIndent: false
  },
  regexp: {
    source: {
      open: '/',
      close: '/'
    },
    flags: {
      open: '',
      close: ''
    },
    separator: '---'
  },
  stats: {
    separator: '---'
  },
  string: {
    open: '',
    close: '',
    line: {
      open: "'",
      close: "'",
      escapeQuote: "'"
    },
    multiline: {
      start: '`',
      end: '`',
      escapeQuote: '`'
    },
    controlPicture: {
      open: '',
      close: ''
    },
    diff: {
      insert: {
        open: '',
        close: ''
      },
      "delete": {
        open: '',
        close: ''
      },
      equal: {
        open: '',
        close: ''
      },
      insertLine: {
        open: '',
        close: ''
      },
      deleteLine: {
        open: '',
        close: ''
      }
    }
  },
  symbol: {
    open: '',
    close: ''
  },
  typedArray: {
    bytes: {
      open: '',
      close: ''
    }
  },
  undefined: {
    open: '',
    close: ''
  }
});
var pluginRefs = new Map();
pluginRefs.count = 0;
var normalizedPluginThemes = new Map();

function normalizePlugins(plugins) {
  if (!Array.isArray(plugins) || plugins.length === 0) return null;
  var refs = [];
  var themes = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = pluginRegistry.getThemes(plugins)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var fromPlugin = _step.value;

      if (!pluginRefs.has(fromPlugin.name)) {
        pluginRefs.set(fromPlugin.name, pluginRefs.count++);
      }

      refs.push(pluginRefs.get(fromPlugin.name));
      themes.push(fromPlugin.theme);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var ref = refs.join('.');

  if (normalizedPluginThemes.has(ref)) {
    return {
      ref: ref,
      theme: normalizedPluginThemes.get(ref)
    };
  }

  var theme = freezeTheme(themes.reduce(function (acc, pluginTheme) {
    return merge(acc, pluginTheme);
  }, cloneDeep(defaultTheme)));
  normalizedPluginThemes.set(ref, theme);
  return {
    ref: ref,
    theme: theme
  };
}

var normalizedCache = new WeakMap();

function normalize(options) {
  options = Object.assign({
    plugins: [],
    theme: null
  }, options);
  var normalizedPlugins = normalizePlugins(options.plugins);

  if (!options.theme) {
    return normalizedPlugins ? normalizedPlugins.theme : defaultTheme;
  }

  var entry = normalizedCache.get(options.theme) || {
    theme: null,
    withPlugins: new Map()
  };
  if (!normalizedCache.has(options.theme)) normalizedCache.set(options.theme, entry);

  if (normalizedPlugins) {
    if (entry.withPlugins.has(normalizedPlugins.ref)) {
      return entry.withPlugins.get(normalizedPlugins.ref);
    }

    var theme = freezeTheme(merge(cloneDeep(normalizedPlugins.theme), options.theme));
    entry.withPlugins.set(normalizedPlugins.ref, theme);
    return theme;
  }

  if (!entry.theme) {
    entry.theme = freezeTheme(merge(cloneDeep(defaultTheme), options.theme));
  }

  return entry.theme;
}

exports.normalize = normalize;
var modifiers = new WeakMap();

function addModifier(descriptor, modifier) {
  if (modifiers.has(descriptor)) {
    modifiers.get(descriptor).add(modifier);
  } else {
    modifiers.set(descriptor, new Set([modifier]));
  }
}

exports.addModifier = addModifier;
var modifierCache = new WeakMap();
var originalCache = new WeakMap();

function applyModifiers(descriptor, theme) {
  if (!modifiers.has(descriptor)) return theme;
  return Array.from(modifiers.get(descriptor)).reduce(function (prev, modifier) {
    var cache = modifierCache.get(modifier) || new WeakMap();
    if (!modifierCache.has(modifier)) modifierCache.set(modifier, cache);
    if (cache.has(prev)) return cache.get(prev);
    var modifiedTheme = cloneDeep(prev);
    modifier(modifiedTheme);
    freezeTheme(modifiedTheme);
    cache.set(prev, modifiedTheme);
    originalCache.set(modifiedTheme, theme);
    return modifiedTheme;
  }, theme);
}

exports.applyModifiers = applyModifiers;

function applyModifiersToOriginal(descriptor, theme) {
  return applyModifiers(descriptor, originalCache.get(theme) || theme);
}

exports.applyModifiersToOriginal = applyModifiersToOriginal;