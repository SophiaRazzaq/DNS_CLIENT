'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var flattenDeep = require('lodash/flattenDeep'); // Indexes are hexadecimal to make reading the binary output easier.


var valueTypes = {
  zero: 0x00,
  int8: 0x01,
  // Note that the hex value equals the number of bytes required
  int16: 0x02,
  // to store the integer.
  int24: 0x03,
  int32: 0x04,
  int40: 0x05,
  int48: 0x06,
  numberString: 0x07,
  negativeZero: 0x08,
  notANumber: 0x09,
  infinity: 0x0A,
  negativeInfinity: 0x0B,
  bigInt: 0x0C,
  undefined: 0x0D,
  "null": 0x0E,
  "true": 0x0F,
  "false": 0x10,
  utf8: 0x11,
  bytes: 0x12,
  list: 0x13,
  descriptor: 0x14
};
var descriptorSymbol = Symbol('descriptor');
exports.descriptorSymbol = descriptorSymbol;

function encodeInteger(type, value) {
  var encoded = Buffer.alloc(type);
  encoded.writeIntLE(value, 0, type);
  return [type, encoded];
}

function encodeValue(value) {
  if (Object.is(value, 0)) return valueTypes.zero;
  if (Object.is(value, -0)) return valueTypes.negativeZero;
  if (Object.is(value, NaN)) return valueTypes.notANumber;
  if (value === Infinity) return valueTypes.infinity;
  if (value === -Infinity) return valueTypes.negativeInfinity;
  if (value === undefined) return valueTypes.undefined;
  if (value === null) return valueTypes["null"];
  if (value === true) return valueTypes["true"];
  if (value === false) return valueTypes["false"];

  var type = _typeof(value);

  if (type === 'number') {
    if (Number.isInteger(value)) {
      // The integer types are signed, so int8 can only store 7 bits, int16
      // only 15, etc.
      if (value >= -0x80 && value < 0x80) return encodeInteger(valueTypes.int8, value);
      if (value >= -0x8000 && value < 0x8000) return encodeInteger(valueTypes.int16, value);
      if (value >= -0x800000 && value < 0x800000) return encodeInteger(valueTypes.int24, value);
      if (value >= -0x80000000 && value < 0x80000000) return encodeInteger(valueTypes.int32, value);
      if (value >= -0x8000000000 && value < 0x8000000000) return encodeInteger(valueTypes.int40, value);
      if (value >= -0x800000000000 && value < 0x800000000000) return encodeInteger(valueTypes.int48, value); // Fall through to encoding the value as a number string.
    }

    var encoded = Buffer.from(String(value), 'utf8');
    return [valueTypes.numberString, encodeValue(encoded.length), encoded];
  }

  if (type === 'string') {
    var _encoded = Buffer.from(value, 'utf8');

    return [valueTypes.utf8, encodeValue(_encoded.length), _encoded];
  }

  if (type === 'bigint') {
    var _encoded2 = Buffer.from(String(value), 'utf8');

    return [valueTypes.bigInt, encodeValue(_encoded2.length), _encoded2];
  }

  if (Buffer.isBuffer(value)) {
    return [valueTypes.bytes, encodeValue(value.byteLength), value];
  }

  if (Array.isArray(value)) {
    return [value[descriptorSymbol] === true ? valueTypes.descriptor : valueTypes.list, encodeValue(value.length), value.map(function (x) {
      return encodeValue(x);
    })];
  }

  var hex = "0x".concat(type.toString(16).toUpperCase());
  throw new TypeError("Unexpected value with type ".concat(hex));
}

function decodeValue(buffer, byteOffset) {
  var type = buffer.readUInt8(byteOffset);
  byteOffset += 1;
  if (type === valueTypes.zero) return {
    byteOffset: byteOffset,
    value: 0
  };
  if (type === valueTypes.negativeZero) return {
    byteOffset: byteOffset,
    value: -0
  };
  if (type === valueTypes.notANumber) return {
    byteOffset: byteOffset,
    value: NaN
  };
  if (type === valueTypes.infinity) return {
    byteOffset: byteOffset,
    value: Infinity
  };
  if (type === valueTypes.negativeInfinity) return {
    byteOffset: byteOffset,
    value: -Infinity
  };
  if (type === valueTypes.undefined) return {
    byteOffset: byteOffset,
    value: undefined
  };
  if (type === valueTypes["null"]) return {
    byteOffset: byteOffset,
    value: null
  };
  if (type === valueTypes["true"]) return {
    byteOffset: byteOffset,
    value: true
  };
  if (type === valueTypes["false"]) return {
    byteOffset: byteOffset,
    value: false
  };

  if (type === valueTypes.int8 || type === valueTypes.int16 || type === valueTypes.int24 || type === valueTypes.int32 || type === valueTypes.int40 || type === valueTypes.int48) {
    var value = buffer.readIntLE(byteOffset, type);
    byteOffset += type;
    return {
      byteOffset: byteOffset,
      value: value
    };
  }

  if (type === valueTypes.numberString || type === valueTypes.utf8 || type === valueTypes.bytes || type === valueTypes.bigInt) {
    var length = decodeValue(buffer, byteOffset);
    var start = length.byteOffset;
    var end = start + length.value;

    if (type === valueTypes.numberString) {
      var _value2 = Number(buffer.toString('utf8', start, end));

      return {
        byteOffset: end,
        value: _value2
      };
    }

    if (type === valueTypes.utf8) {
      var _value3 = buffer.toString('utf8', start, end);

      return {
        byteOffset: end,
        value: _value3
      };
    }

    if (type === valueTypes.bigInt) {
      var _value4 = BigInt(buffer.toString('utf8', start, end)); // eslint-disable-line no-undef


      return {
        byteOffset: end,
        value: _value4
      };
    }

    var _value = buffer.slice(start, end);

    return {
      byteOffset: end,
      value: _value
    };
  }

  if (type === valueTypes.list || type === valueTypes.descriptor) {
    var _length = decodeValue(buffer, byteOffset);

    byteOffset = _length.byteOffset;

    var _value5 = new Array(_length.value);

    if (type === valueTypes.descriptor) {
      _value5[descriptorSymbol] = true;
    }

    for (var index = 0; index < _length.value; index++) {
      var item = decodeValue(buffer, byteOffset);
      byteOffset = item.byteOffset;
      _value5[index] = item.value;
    }

    return {
      byteOffset: byteOffset,
      value: _value5
    };
  }

  var hex = "0x".concat(type.toString(16).toUpperCase());
  throw new TypeError("Could not decode type ".concat(hex));
}

function buildBuffer(numberOrArray) {
  if (typeof numberOrArray === 'number') {
    var _byte = Buffer.alloc(1);

    _byte.writeUInt8(numberOrArray);

    return _byte;
  }

  var array = flattenDeep(numberOrArray);
  var buffers = new Array(array.length);
  var byteLength = 0;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = array.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = _slicedToArray(_step.value, 2),
          index = _step$value[0],
          element = _step$value[1];

      if (typeof element === 'number') {
        byteLength += 1;

        var _byte2 = Buffer.alloc(1);

        _byte2.writeUInt8(element);

        buffers[index] = _byte2;
      } else {
        byteLength += element.byteLength;
        buffers[index] = element;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return Buffer.concat(buffers, byteLength);
}

function encode(serializerVersion, rootRecord, usedPlugins) {
  var buffers = [];
  var byteOffset = 0;
  var versionHeader = Buffer.alloc(2);
  versionHeader.writeUInt16LE(serializerVersion);
  buffers.push(versionHeader);
  byteOffset += versionHeader.byteLength;
  var rootOffset = Buffer.alloc(4);
  buffers.push(rootOffset);
  byteOffset += rootOffset.byteLength;
  var numPlugins = buildBuffer(encodeValue(usedPlugins.size));
  buffers.push(numPlugins);
  byteOffset += numPlugins.byteLength;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = usedPlugins.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var name = _step2.value;
      var plugin = usedPlugins.get(name);

      var _record = buildBuffer([encodeValue(name), encodeValue(plugin.serializerVersion)]);

      buffers.push(_record);
      byteOffset += _record.byteLength;
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var queue = [rootRecord];
  var pointers = [rootOffset];

  while (queue.length > 0) {
    pointers.shift().writeUInt32LE(byteOffset, 0);
    var record = queue.shift();
    var recordHeader = buildBuffer([encodeValue(record.pluginIndex), encodeValue(record.id), encodeValue(record.children.length)]);
    buffers.push(recordHeader);
    byteOffset += recordHeader.byteLength; // Add pointers before encoding the state. This allows, if it ever becomes
    // necessary, for records to be extracted from a buffer without having to
    // parse the (variable length) state field.

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = record.children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var child = _step3.value;
        queue.push(child);
        var pointer = Buffer.alloc(4);
        pointers.push(pointer);
        buffers.push(pointer);
        byteOffset += 4;
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }

    var state = buildBuffer(encodeValue(record.state));
    buffers.push(state);
    byteOffset += state.byteLength;
  }

  return Buffer.concat(buffers, byteOffset);
}

exports.encode = encode;

function decodePlugins(buffer) {
  var $numPlugins = decodeValue(buffer, 0);
  var byteOffset = $numPlugins.byteOffset;
  var usedPlugins = new Map();
  var lastIndex = $numPlugins.value;

  for (var index = 1; index <= lastIndex; index++) {
    var $name = decodeValue(buffer, byteOffset);
    var name = $name.value;
    byteOffset = $name.byteOffset;
    var serializerVersion = decodeValue(buffer, byteOffset).value;
    usedPlugins.set(index, {
      name: name,
      serializerVersion: serializerVersion
    });
  }

  return usedPlugins;
}

exports.decodePlugins = decodePlugins;

function decodeRecord(buffer, byteOffset) {
  var $pluginIndex = decodeValue(buffer, byteOffset);
  var pluginIndex = $pluginIndex.value;
  byteOffset = $pluginIndex.byteOffset;
  var $id = decodeValue(buffer, byteOffset);
  var id = $id.value;
  byteOffset = $id.byteOffset;
  var $numPointers = decodeValue(buffer, byteOffset);
  var numPointers = $numPointers.value;
  byteOffset = $numPointers.byteOffset;
  var pointerAddresses = new Array(numPointers);

  for (var index = 0; index < numPointers; index++) {
    pointerAddresses[index] = buffer.readUInt32LE(byteOffset);
    byteOffset += 4;
  }

  var state = decodeValue(buffer, byteOffset).value;
  return {
    id: id,
    pluginIndex: pluginIndex,
    state: state,
    pointerAddresses: pointerAddresses
  };
}

exports.decodeRecord = decodeRecord;

function extractVersion(buffer) {
  return buffer.readUInt16LE(0);
}

exports.extractVersion = extractVersion;

function decode(buffer) {
  var rootOffset = buffer.readUInt32LE(2);
  var pluginBuffer = buffer.slice(6, rootOffset);
  var rootRecord = decodeRecord(buffer, rootOffset);
  return {
    pluginBuffer: pluginBuffer,
    rootRecord: rootRecord
  };
}

exports.decode = decode;