"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.command = command;
exports.isCommandBuilderDefinition = isCommandBuilderDefinition;
exports.isCommandBuilderCallback = isCommandBuilderCallback;
exports.isCommandHandlerDefinition = isCommandHandlerDefinition;

var _commonTypes = require("./typings/common-types.js");

var _isPromise = require("./utils/is-promise.js");

var _middleware = require("./middleware.js");

var _parseCommand = require("./parse-command.js");

var _yargsFactory = require("./yargs-factory.js");

var _whichModule = _interopRequireDefault(require("./utils/which-module.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var DEFAULT_MARKER = /(^\*)|(^\$0)/;

function command(yargs, usage, validation) {
  var globalMiddleware = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var shim = arguments.length > 4 ? arguments[4] : undefined;
  var self = {};
  var handlers = {};
  var aliasMap = {};
  var defaultCommand;

  self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
    var aliases = [];
    var middlewares = (0, _middleware.commandMiddlewareFactory)(commandMiddleware);

    handler = handler || function () {};

    if (Array.isArray(cmd)) {
      if (isCommandAndAliases(cmd)) {
        var _cmd = cmd;

        var _cmd2 = _toArray(_cmd);

        cmd = _cmd2[0];
        aliases = _cmd2.slice(1);
      } else {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = cmd[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _command = _step.value;
            self.addHandler(_command);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    } else if (isCommandHandlerDefinition(cmd)) {
      var _command2 = Array.isArray(cmd.command) || typeof cmd.command === 'string' ? cmd.command : moduleName(cmd);

      if (cmd.aliases) _command2 = [].concat(_command2).concat(cmd.aliases);
      self.addHandler(_command2, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
      return;
    } else if (isCommandBuilderDefinition(builder)) {
      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
      return;
    }

    if (typeof cmd === 'string') {
      var parsedCommand = (0, _parseCommand.parseCommand)(cmd);
      aliases = aliases.map(function (alias) {
        return (0, _parseCommand.parseCommand)(alias).cmd;
      });
      var isDefault = false;
      var parsedAliases = [parsedCommand.cmd].concat(aliases).filter(function (c) {
        if (DEFAULT_MARKER.test(c)) {
          isDefault = true;
          return false;
        }

        return true;
      });
      if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0');

      if (isDefault) {
        parsedCommand.cmd = parsedAliases[0];
        aliases = parsedAliases.slice(1);
        cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
      }

      aliases.forEach(function (alias) {
        aliasMap[alias] = parsedCommand.cmd;
      });

      if (description !== false) {
        usage.command(cmd, description, isDefault, aliases, deprecated);
      }

      handlers[parsedCommand.cmd] = {
        original: cmd,
        description: description,
        handler: handler,
        builder: builder || {},
        middlewares: middlewares,
        deprecated: deprecated,
        demanded: parsedCommand.demanded,
        optional: parsedCommand.optional
      };
      if (isDefault) defaultCommand = handlers[parsedCommand.cmd];
    }
  };

  self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {
    opts = opts || {};
    if (typeof opts.recurse !== 'boolean') opts.recurse = false;
    if (!Array.isArray(opts.extensions)) opts.extensions = ['js'];
    var parentVisit = typeof opts.visit === 'function' ? opts.visit : function (o) {
      return o;
    };

    opts.visit = function visit(obj, joined, filename) {
      var visited = parentVisit(obj, joined, filename);

      if (visited) {
        if (~context.files.indexOf(joined)) return visited;
        context.files.push(joined);
        self.addHandler(visited);
      }

      return visited;
    };

    shim.requireDirectory({
      require: req,
      filename: callerFile
    }, dir, opts);
  };

  function moduleName(obj) {
    var mod = (0, _whichModule["default"])(obj);
    if (!mod) throw new Error("No command name given for module: ".concat(shim.inspect(obj)));
    return commandFromFilename(mod.filename);
  }

  function commandFromFilename(filename) {
    return shim.path.basename(filename, shim.path.extname(filename));
  }

  function extractDesc(_ref) {
    var describe = _ref.describe,
        description = _ref.description,
        desc = _ref.desc;

    for (var _i = 0, _arr = [describe, description, desc]; _i < _arr.length; _i++) {
      var test = _arr[_i];
      if (typeof test === 'string' || test === false) return test;
      (0, _commonTypes.assertNotStrictEqual)(test, true, shim);
    }

    return false;
  }

  self.getCommands = function () {
    return Object.keys(handlers).concat(Object.keys(aliasMap));
  };

  self.getCommandHandlers = function () {
    return handlers;
  };

  self.hasDefaultCommand = function () {
    return !!defaultCommand;
  };

  self.runCommand = function runCommand(command, yargs, parsed, commandIndex) {
    var aliases = parsed.aliases;
    var commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;
    var currentContext = yargs.getContext();
    var numFiles = currentContext.files.length;
    var parentCommands = currentContext.commands.slice();
    var innerArgv = parsed.argv;
    var positionalMap = {};

    if (command) {
      currentContext.commands.push(command);
      currentContext.fullCommands.push(commandHandler.original);
    }

    var builder = commandHandler.builder;

    if (isCommandBuilderCallback(builder)) {
      var builderOutput = builder(yargs.reset(parsed.aliases));
      var innerYargs = (0, _yargsFactory.isYargsInstance)(builderOutput) ? builderOutput : yargs;

      if (shouldUpdateUsage(innerYargs)) {
        innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
      }

      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);
      aliases = innerYargs.parsed.aliases;
    } else if (isCommandBuilderOptionDefinitions(builder)) {
      var _innerYargs = yargs.reset(parsed.aliases);

      if (shouldUpdateUsage(_innerYargs)) {
        _innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
      }

      Object.keys(commandHandler.builder).forEach(function (key) {
        _innerYargs.option(key, builder[key]);
      });
      innerArgv = _innerYargs._parseArgs(null, null, true, commandIndex);
      aliases = _innerYargs.parsed.aliases;
    }

    if (!yargs._hasOutput()) {
      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);
    }

    var middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares);
    (0, _middleware.applyMiddleware)(innerArgv, yargs, middlewares, true);

    if (!yargs._hasOutput()) {
      yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error, !command);
    }

    if (commandHandler.handler && !yargs._hasOutput()) {
      yargs._setHasOutput();

      var populateDoubleDash = !!yargs.getOptions().configuration['populate--'];

      yargs._postProcess(innerArgv, populateDoubleDash);

      innerArgv = (0, _middleware.applyMiddleware)(innerArgv, yargs, middlewares, false);
      var handlerResult;

      if ((0, _isPromise.isPromise)(innerArgv)) {
        handlerResult = innerArgv.then(function (argv) {
          return commandHandler.handler(argv);
        });
      } else {
        handlerResult = commandHandler.handler(innerArgv);
      }

      var handlerFinishCommand = yargs.getHandlerFinishCommand();

      if ((0, _isPromise.isPromise)(handlerResult)) {
        yargs.getUsageInstance().cacheHelpMessage();
        handlerResult.then(function (value) {
          if (handlerFinishCommand) {
            handlerFinishCommand(value);
          }
        })["catch"](function (error) {
          try {
            yargs.getUsageInstance().fail(null, error);
          } catch (err) {}
        }).then(function () {
          yargs.getUsageInstance().clearCachedHelpMessage();
        });
      } else {
        if (handlerFinishCommand) {
          handlerFinishCommand(handlerResult);
        }
      }
    }

    if (command) {
      currentContext.commands.pop();
      currentContext.fullCommands.pop();
    }

    numFiles = currentContext.files.length - numFiles;
    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles);
    return innerArgv;
  };

  function shouldUpdateUsage(yargs) {
    return !yargs.getUsageInstance().getUsageDisabled() && yargs.getUsageInstance().getUsage().length === 0;
  }

  function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
    var c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original;
    var pc = parentCommands.filter(function (c) {
      return !DEFAULT_MARKER.test(c);
    });
    pc.push(c);
    return "$0 ".concat(pc.join(' '));
  }

  self.runDefaultBuilderOn = function (yargs) {
    (0, _commonTypes.assertNotStrictEqual)(defaultCommand, undefined, shim);

    if (shouldUpdateUsage(yargs)) {
      var commandString = DEFAULT_MARKER.test(defaultCommand.original) ? defaultCommand.original : defaultCommand.original.replace(/^[^[\]<>]*/, '$0 ');
      yargs.getUsageInstance().usage(commandString, defaultCommand.description);
    }

    var builder = defaultCommand.builder;

    if (isCommandBuilderCallback(builder)) {
      builder(yargs);
    } else if (!isCommandBuilderDefinition(builder)) {
      Object.keys(builder).forEach(function (key) {
        yargs.option(key, builder[key]);
      });
    }
  };

  function populatePositionals(commandHandler, argv, context) {
    argv._ = argv._.slice(context.commands.length);
    var demanded = commandHandler.demanded.slice(0);
    var optional = commandHandler.optional.slice(0);
    var positionalMap = {};
    validation.positionalCount(demanded.length, argv._.length);

    while (demanded.length) {
      var demand = demanded.shift();
      populatePositional(demand, argv, positionalMap);
    }

    while (optional.length) {
      var maybe = optional.shift();
      populatePositional(maybe, argv, positionalMap);
    }

    argv._ = context.commands.concat(argv._.map(function (a) {
      return '' + a;
    }));
    postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));
    return positionalMap;
  }

  function populatePositional(positional, argv, positionalMap) {
    var cmd = positional.cmd[0];

    if (positional.variadic) {
      positionalMap[cmd] = argv._.splice(0).map(String);
    } else {
      if (argv._.length) positionalMap[cmd] = [String(argv._.shift())];
    }
  }

  function postProcessPositionals(argv, positionalMap, parseOptions) {
    var options = Object.assign({}, yargs.getOptions());
    options["default"] = Object.assign(parseOptions["default"], options["default"]);

    for (var _i2 = 0, _Object$keys = Object.keys(parseOptions.alias); _i2 < _Object$keys.length; _i2++) {
      var key = _Object$keys[_i2];
      options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
    }

    options.array = options.array.concat(parseOptions.array);
    options.config = {};
    var unparsed = [];
    Object.keys(positionalMap).forEach(function (key) {
      positionalMap[key].map(function (value) {
        if (options.configuration['unknown-options-as-args']) options.key[key] = true;
        unparsed.push("--".concat(key));
        unparsed.push(value);
      });
    });
    if (!unparsed.length) return;
    var config = Object.assign({}, options.configuration, {
      'populate--': true
    });
    var parsed = shim.Parser.detailed(unparsed, Object.assign({}, options, {
      configuration: config
    }));

    if (parsed.error) {
      yargs.getUsageInstance().fail(parsed.error.message, parsed.error);
    } else {
      var positionalKeys = Object.keys(positionalMap);
      Object.keys(positionalMap).forEach(function (key) {
        positionalKeys.push.apply(positionalKeys, _toConsumableArray(parsed.aliases[key]));
      });
      Object.keys(parsed.argv).forEach(function (key) {
        if (positionalKeys.indexOf(key) !== -1) {
          if (!positionalMap[key]) positionalMap[key] = parsed.argv[key];
          argv[key] = parsed.argv[key];
        }
      });
    }
  }

  self.cmdToParseOptions = function (cmdString) {
    var parseOptions = {
      array: [],
      "default": {},
      alias: {},
      demand: {}
    };
    var parsed = (0, _parseCommand.parseCommand)(cmdString);
    parsed.demanded.forEach(function (d) {
      var _d$cmd = _toArray(d.cmd),
          cmd = _d$cmd[0],
          aliases = _d$cmd.slice(1);

      if (d.variadic) {
        parseOptions.array.push(cmd);
        parseOptions["default"][cmd] = [];
      }

      parseOptions.alias[cmd] = aliases;
      parseOptions.demand[cmd] = true;
    });
    parsed.optional.forEach(function (o) {
      var _o$cmd = _toArray(o.cmd),
          cmd = _o$cmd[0],
          aliases = _o$cmd.slice(1);

      if (o.variadic) {
        parseOptions.array.push(cmd);
        parseOptions["default"][cmd] = [];
      }

      parseOptions.alias[cmd] = aliases;
    });
    return parseOptions;
  };

  self.reset = function () {
    handlers = {};
    aliasMap = {};
    defaultCommand = undefined;
    return self;
  };

  var frozens = [];

  self.freeze = function () {
    frozens.push({
      handlers: handlers,
      aliasMap: aliasMap,
      defaultCommand: defaultCommand
    });
  };

  self.unfreeze = function () {
    var frozen = frozens.pop();
    (0, _commonTypes.assertNotStrictEqual)(frozen, undefined, shim);
    handlers = frozen.handlers;
    aliasMap = frozen.aliasMap;
    defaultCommand = frozen.defaultCommand;
  };

  return self;
}

function isCommandBuilderDefinition(builder) {
  return _typeof(builder) === 'object' && !!builder.builder && typeof builder.handler === 'function';
}

function isCommandAndAliases(cmd) {
  if (cmd.every(function (c) {
    return typeof c === 'string';
  })) {
    return true;
  } else {
    return false;
  }
}

function isCommandBuilderCallback(builder) {
  return typeof builder === 'function';
}

function isCommandBuilderOptionDefinitions(builder) {
  return _typeof(builder) === 'object';
}

function isCommandHandlerDefinition(cmd) {
  return _typeof(cmd) === 'object' && !Array.isArray(cmd);
}