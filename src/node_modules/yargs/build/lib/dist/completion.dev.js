"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.completion = completion;

var _command = require("./command.js");

var _commonTypes = require("./typings/common-types.js");

var templates = _interopRequireWildcard(require("./completion-templates.js"));

var _isPromise = require("./utils/is-promise.js");

var _parseCommand = require("./parse-command.js");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function completion(yargs, usage, command, shim) {
  var self = {
    completionKey: 'get-yargs-completions'
  };
  var aliases;

  self.setParsed = function setParsed(parsed) {
    aliases = parsed.aliases;
  };

  var zshShell = shim.getEnv('SHELL') && shim.getEnv('SHELL').indexOf('zsh') !== -1 || shim.getEnv('ZSH_NAME') && shim.getEnv('ZSH_NAME').indexOf('zsh') !== -1;

  self.getCompletion = function getCompletion(args, done) {
    var completions = [];
    var current = args.length ? args[args.length - 1] : '';
    var argv = yargs.parse(args, true);
    var parentCommands = yargs.getContext().commands;

    function runCompletionFunction(argv) {
      (0, _commonTypes.assertNotStrictEqual)(completionFunction, null, shim);

      if (isSyncCompletionFunction(completionFunction)) {
        var result = completionFunction(current, argv);

        if ((0, _isPromise.isPromise)(result)) {
          return result.then(function (list) {
            shim.process.nextTick(function () {
              done(list);
            });
          })["catch"](function (err) {
            shim.process.nextTick(function () {
              throw err;
            });
          });
        }

        return done(result);
      } else {
        return completionFunction(current, argv, function (completions) {
          done(completions);
        });
      }
    }

    if (completionFunction) {
      return (0, _isPromise.isPromise)(argv) ? argv.then(runCompletionFunction) : runCompletionFunction(argv);
    }

    var handlers = command.getCommandHandlers();

    for (var i = 0, ii = args.length; i < ii; ++i) {
      if (handlers[args[i]] && handlers[args[i]].builder) {
        var builder = handlers[args[i]].builder;

        if ((0, _command.isCommandBuilderCallback)(builder)) {
          var y = yargs.reset();
          builder(y);
          return y.argv;
        }
      }
    }

    if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current) {
      usage.getCommands().forEach(function (usageCommand) {
        var commandName = (0, _parseCommand.parseCommand)(usageCommand[0]).cmd;

        if (args.indexOf(commandName) === -1) {
          if (!zshShell) {
            completions.push(commandName);
          } else {
            var desc = usageCommand[1] || '';
            completions.push(commandName.replace(/:/g, '\\:') + ':' + desc);
          }
        }
      });
    }

    if (current.match(/^-/) || current === '' && completions.length === 0) {
      var descs = usage.getDescriptions();
      var options = yargs.getOptions();
      Object.keys(options.key).forEach(function (key) {
        var negable = !!options.configuration['boolean-negation'] && options["boolean"].includes(key);
        var keyAndAliases = [key].concat(aliases[key] || []);
        if (negable) keyAndAliases = keyAndAliases.concat(keyAndAliases.map(function (key) {
          return "no-".concat(key);
        }));

        function completeOptionKey(key) {
          var notInArgs = keyAndAliases.every(function (val) {
            return args.indexOf("--".concat(val)) === -1;
          });

          if (notInArgs) {
            var startsByTwoDashes = function startsByTwoDashes(s) {
              return /^--/.test(s);
            };

            var isShortOption = function isShortOption(s) {
              return /^[^0-9]$/.test(s);
            };

            var dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';

            if (!zshShell) {
              completions.push(dashes + key);
            } else {
              var desc = descs[key] || '';
              completions.push(dashes + "".concat(key.replace(/:/g, '\\:'), ":").concat(desc.replace('__yargsString__:', '')));
            }
          }
        }

        completeOptionKey(key);
        if (negable && !!options["default"][key]) completeOptionKey("no-".concat(key));
      });
    }

    done(completions);
  };

  self.generateCompletionScript = function generateCompletionScript($0, cmd) {
    var script = zshShell ? templates.completionZshTemplate : templates.completionShTemplate;
    var name = shim.path.basename($0);
    if ($0.match(/\.js$/)) $0 = "./".concat($0);
    script = script.replace(/{{app_name}}/g, name);
    script = script.replace(/{{completion_command}}/g, cmd);
    return script.replace(/{{app_path}}/g, $0);
  };

  var completionFunction = null;

  self.registerFunction = function (fn) {
    completionFunction = fn;
  };

  return self;
}

function isSyncCompletionFunction(completionFunction) {
  return completionFunction.length < 3;
}