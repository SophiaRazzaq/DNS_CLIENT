"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = pMap;
exports.pMapIterable = pMapIterable;
exports.pMapSkip = void 0;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _awaitAsyncGenerator(value) { return new _AwaitValue(value); }

function _wrapAsyncGenerator(fn) { return function () { return new _AsyncGenerator(fn.apply(this, arguments)); }; }

function _AsyncGenerator(gen) { var front, back; function send(key, arg) { return new Promise(function (resolve, reject) { var request = { key: key, arg: arg, resolve: resolve, reject: reject, next: null }; if (back) { back = back.next = request; } else { front = back = request; resume(key, arg); } }); } function resume(key, arg) { try { var result = gen[key](arg); var value = result.value; var wrappedAwait = value instanceof _AwaitValue; Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) { if (wrappedAwait) { resume(key === "return" ? "return" : "next", arg); return; } settle(result.done ? "return" : "normal", arg); }, function (err) { resume("throw", err); }); } catch (err) { settle("throw", err); } } function settle(type, value) { switch (type) { case "return": front.resolve({ value: value, done: true }); break; case "throw": front.reject(value); break; default: front.resolve({ value: value, done: false }); break; } front = front.next; if (front) { resume(front.key, front.arg); } else { back = null; } } this._invoke = send; if (typeof gen["return"] !== "function") { this["return"] = undefined; } }

if (typeof Symbol === "function" && Symbol.asyncIterator) { _AsyncGenerator.prototype[Symbol.asyncIterator] = function () { return this; }; }

_AsyncGenerator.prototype.next = function (arg) { return this._invoke("next", arg); };

_AsyncGenerator.prototype["throw"] = function (arg) { return this._invoke("throw", arg); };

_AsyncGenerator.prototype["return"] = function (arg) { return this._invoke("return", arg); };

function _AwaitValue(value) { this.wrapped = value; }

function pMap(iterable, mapper) {
  var _ref,
      _ref$concurrency,
      concurrency,
      _ref$stopOnError,
      stopOnError,
      signal,
      _args4 = arguments;

  return regeneratorRuntime.async(function pMap$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _ref = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {}, _ref$concurrency = _ref.concurrency, concurrency = _ref$concurrency === void 0 ? Number.POSITIVE_INFINITY : _ref$concurrency, _ref$stopOnError = _ref.stopOnError, stopOnError = _ref$stopOnError === void 0 ? true : _ref$stopOnError, signal = _ref.signal;
          return _context4.abrupt("return", new Promise(function (resolve, reject_) {
            if (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {
              throw new TypeError("Expected `input` to be either an `Iterable` or `AsyncIterable`, got (".concat(_typeof(iterable), ")"));
            }

            if (typeof mapper !== 'function') {
              throw new TypeError('Mapper function is required');
            }

            if (!(Number.isSafeInteger(concurrency) && concurrency >= 1 || concurrency === Number.POSITIVE_INFINITY)) {
              throw new TypeError("Expected `concurrency` to be an integer from 1 and up or `Infinity`, got `".concat(concurrency, "` (").concat(_typeof(concurrency), ")"));
            }

            var result = [];
            var errors = [];
            var skippedIndexesMap = new Map();
            var isRejected = false;
            var isResolved = false;
            var isIterableDone = false;
            var resolvingCount = 0;
            var currentIndex = 0;
            var iterator = iterable[Symbol.iterator] === undefined ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();

            var reject = function reject(reason) {
              isRejected = true;
              isResolved = true;
              reject_(reason);
            };

            if (signal) {
              if (signal.aborted) {
                reject(signal.reason);
              }

              signal.addEventListener('abort', function () {
                reject(signal.reason);
              });
            }

            var next = function next() {
              var nextItem, index, pureResult, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _step$value, _index, value;

              return regeneratorRuntime.async(function next$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      if (!isResolved) {
                        _context2.next = 2;
                        break;
                      }

                      return _context2.abrupt("return");

                    case 2:
                      _context2.next = 4;
                      return regeneratorRuntime.awrap(iterator.next());

                    case 4:
                      nextItem = _context2.sent;
                      index = currentIndex;
                      currentIndex++; // Note: `iterator.next()` can be called many times in parallel.
                      // This can cause multiple calls to this `next()` function to
                      // receive a `nextItem` with `done === true`.
                      // The shutdown logic that rejects/resolves must be protected
                      // so it runs only one time as the `skippedIndex` logic is
                      // non-idempotent.

                      if (!nextItem.done) {
                        _context2.next = 47;
                        break;
                      }

                      isIterableDone = true;

                      if (!(resolvingCount === 0 && !isResolved)) {
                        _context2.next = 46;
                        break;
                      }

                      if (!(!stopOnError && errors.length > 0)) {
                        _context2.next = 13;
                        break;
                      }

                      reject(new AggregateError(errors)); // eslint-disable-line unicorn/error-message

                      return _context2.abrupt("return");

                    case 13:
                      isResolved = true;

                      if (!(skippedIndexesMap.size === 0)) {
                        _context2.next = 17;
                        break;
                      }

                      resolve(result);
                      return _context2.abrupt("return");

                    case 17:
                      pureResult = []; // Support multiple `pMapSkip`'s.

                      _iteratorNormalCompletion = true;
                      _didIteratorError = false;
                      _iteratorError = undefined;
                      _context2.prev = 21;
                      _iterator = result.entries()[Symbol.iterator]();

                    case 23:
                      if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                        _context2.next = 31;
                        break;
                      }

                      _step$value = _slicedToArray(_step.value, 2), _index = _step$value[0], value = _step$value[1];

                      if (!(skippedIndexesMap.get(_index) === pMapSkip)) {
                        _context2.next = 27;
                        break;
                      }

                      return _context2.abrupt("continue", 28);

                    case 27:
                      pureResult.push(value);

                    case 28:
                      _iteratorNormalCompletion = true;
                      _context2.next = 23;
                      break;

                    case 31:
                      _context2.next = 37;
                      break;

                    case 33:
                      _context2.prev = 33;
                      _context2.t0 = _context2["catch"](21);
                      _didIteratorError = true;
                      _iteratorError = _context2.t0;

                    case 37:
                      _context2.prev = 37;
                      _context2.prev = 38;

                      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                        _iterator["return"]();
                      }

                    case 40:
                      _context2.prev = 40;

                      if (!_didIteratorError) {
                        _context2.next = 43;
                        break;
                      }

                      throw _iteratorError;

                    case 43:
                      return _context2.finish(40);

                    case 44:
                      return _context2.finish(37);

                    case 45:
                      resolve(pureResult);

                    case 46:
                      return _context2.abrupt("return");

                    case 47:
                      resolvingCount++; // Intentionally detached

                      (function _callee() {
                        var element, _value;

                        return regeneratorRuntime.async(function _callee$(_context) {
                          while (1) {
                            switch (_context.prev = _context.next) {
                              case 0:
                                _context.prev = 0;
                                _context.next = 3;
                                return regeneratorRuntime.awrap(nextItem.value);

                              case 3:
                                element = _context.sent;

                                if (!isResolved) {
                                  _context.next = 6;
                                  break;
                                }

                                return _context.abrupt("return");

                              case 6:
                                _context.next = 8;
                                return regeneratorRuntime.awrap(mapper(element, index));

                              case 8:
                                _value = _context.sent;

                                // Use Map to stage the index of the element.
                                if (_value === pMapSkip) {
                                  skippedIndexesMap.set(index, _value);
                                }

                                result[index] = _value;
                                resolvingCount--;
                                _context.next = 14;
                                return regeneratorRuntime.awrap(next());

                              case 14:
                                _context.next = 32;
                                break;

                              case 16:
                                _context.prev = 16;
                                _context.t0 = _context["catch"](0);

                                if (!stopOnError) {
                                  _context.next = 22;
                                  break;
                                }

                                reject(_context.t0);
                                _context.next = 32;
                                break;

                              case 22:
                                errors.push(_context.t0);
                                resolvingCount--; // In that case we can't really continue regardless of `stopOnError` state
                                // since an iterable is likely to continue throwing after it throws once.
                                // If we continue calling `next()` indefinitely we will likely end up
                                // in an infinite loop of failed iteration.

                                _context.prev = 24;
                                _context.next = 27;
                                return regeneratorRuntime.awrap(next());

                              case 27:
                                _context.next = 32;
                                break;

                              case 29:
                                _context.prev = 29;
                                _context.t1 = _context["catch"](24);
                                reject(_context.t1);

                              case 32:
                              case "end":
                                return _context.stop();
                            }
                          }
                        }, null, null, [[0, 16], [24, 29]]);
                      })();

                    case 49:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, null, null, [[21, 33, 37, 45], [38,, 40, 44]]);
            }; // Create the concurrent runners in a detached (non-awaited)
            // promise. We need this so we can await the `next()` calls
            // to stop creating runners before hitting the concurrency limit
            // if the iterable has already been marked as done.
            // NOTE: We *must* do this for async iterators otherwise we'll spin up
            // infinite `next()` calls by default and never start the event loop.


            (function _callee2() {
              var index;
              return regeneratorRuntime.async(function _callee2$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      index = 0;

                    case 1:
                      if (!(index < concurrency)) {
                        _context3.next = 16;
                        break;
                      }

                      _context3.prev = 2;
                      _context3.next = 5;
                      return regeneratorRuntime.awrap(next());

                    case 5:
                      _context3.next = 11;
                      break;

                    case 7:
                      _context3.prev = 7;
                      _context3.t0 = _context3["catch"](2);
                      reject(_context3.t0);
                      return _context3.abrupt("break", 16);

                    case 11:
                      if (!(isIterableDone || isRejected)) {
                        _context3.next = 13;
                        break;
                      }

                      return _context3.abrupt("break", 16);

                    case 13:
                      index++;
                      _context3.next = 1;
                      break;

                    case 16:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, null, null, [[2, 7]]);
            })();
          }));

        case 2:
        case "end":
          return _context4.stop();
      }
    }
  });
}

function pMapIterable(iterable, mapper) {
  var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$concurrency = _ref2.concurrency,
      concurrency = _ref2$concurrency === void 0 ? Number.POSITIVE_INFINITY : _ref2$concurrency,
      _ref2$backpressure = _ref2.backpressure,
      backpressure = _ref2$backpressure === void 0 ? concurrency : _ref2$backpressure;

  if (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {
    throw new TypeError("Expected `input` to be either an `Iterable` or `AsyncIterable`, got (".concat(_typeof(iterable), ")"));
  }

  if (typeof mapper !== 'function') {
    throw new TypeError('Mapper function is required');
  }

  if (!(Number.isSafeInteger(concurrency) && concurrency >= 1 || concurrency === Number.POSITIVE_INFINITY)) {
    throw new TypeError("Expected `concurrency` to be an integer from 1 and up or `Infinity`, got `".concat(concurrency, "` (").concat(_typeof(concurrency), ")"));
  }

  if (!(Number.isSafeInteger(backpressure) && backpressure >= concurrency || backpressure === Number.POSITIVE_INFINITY)) {
    throw new TypeError("Expected `backpressure` to be an integer from `concurrency` (".concat(concurrency, ") and up or `Infinity`, got `").concat(backpressure, "` (").concat(_typeof(backpressure), ")"));
  }

  return _defineProperty({}, Symbol.asyncIterator, function () {
    return _wrapAsyncGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee4() {
      var iterator, promises, runningMappersCount, isDone, index, trySpawn, _ref4, error, done, value;

      return regeneratorRuntime.wrap(function _callee4$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              trySpawn = function _ref5() {
                if (isDone || !(runningMappersCount < concurrency && promises.length < backpressure)) {
                  return;
                }

                var promise = function _callee3() {
                  var _ref3, done, value, returnValue, _index2;

                  return regeneratorRuntime.async(function _callee3$(_context5) {
                    while (1) {
                      switch (_context5.prev = _context5.next) {
                        case 0:
                          _context5.next = 2;
                          return regeneratorRuntime.awrap(iterator.next());

                        case 2:
                          _ref3 = _context5.sent;
                          done = _ref3.done;
                          value = _ref3.value;

                          if (!done) {
                            _context5.next = 7;
                            break;
                          }

                          return _context5.abrupt("return", {
                            done: true
                          });

                        case 7:
                          runningMappersCount++; // Spawn if still below concurrency and backpressure limit

                          trySpawn();
                          _context5.prev = 9;
                          _context5.t0 = regeneratorRuntime;
                          _context5.t1 = mapper;
                          _context5.next = 14;
                          return regeneratorRuntime.awrap(value);

                        case 14:
                          _context5.t2 = _context5.sent;
                          _context5.t3 = index++;
                          _context5.t4 = (0, _context5.t1)(_context5.t2, _context5.t3);
                          _context5.next = 19;
                          return _context5.t0.awrap.call(_context5.t0, _context5.t4);

                        case 19:
                          returnValue = _context5.sent;
                          runningMappersCount--;

                          if (returnValue === pMapSkip) {
                            _index2 = promises.indexOf(promise);

                            if (_index2 > 0) {
                              promises.splice(_index2, 1);
                            }
                          } // Spawn if still below backpressure limit and just dropped below concurrency limit


                          trySpawn();
                          return _context5.abrupt("return", {
                            done: false,
                            value: returnValue
                          });

                        case 26:
                          _context5.prev = 26;
                          _context5.t5 = _context5["catch"](9);
                          isDone = true;
                          return _context5.abrupt("return", {
                            error: _context5.t5
                          });

                        case 30:
                        case "end":
                          return _context5.stop();
                      }
                    }
                  }, null, null, [[9, 26]]);
                }();

                promises.push(promise);
              };

              iterator = iterable[Symbol.asyncIterator] === undefined ? iterable[Symbol.iterator]() : iterable[Symbol.asyncIterator]();
              promises = [];
              runningMappersCount = 0;
              isDone = false;
              index = 0;
              trySpawn();

            case 7:
              if (!(promises.length > 0)) {
                _context6.next = 26;
                break;
              }

              _context6.next = 10;
              return _awaitAsyncGenerator(promises[0]);

            case 10:
              _ref4 = _context6.sent;
              error = _ref4.error;
              done = _ref4.done;
              value = _ref4.value;
              // eslint-disable-line no-await-in-loop
              promises.shift();

              if (!error) {
                _context6.next = 17;
                break;
              }

              throw error;

            case 17:
              if (!done) {
                _context6.next = 19;
                break;
              }

              return _context6.abrupt("return");

            case 19:
              // Spawn if just dropped below backpressure limit and below the concurrency limit
              trySpawn();

              if (!(value === pMapSkip)) {
                _context6.next = 22;
                break;
              }

              return _context6.abrupt("continue", 7);

            case 22:
              _context6.next = 24;
              return value;

            case 24:
              _context6.next = 7;
              break;

            case 26:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee4);
    }))();
  });
}

var pMapSkip = Symbol('skip');
exports.pMapSkip = pMapSkip;