"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _nodeFs = _interopRequireDefault(require("node:fs"));

var _nodePath = _interopRequireDefault(require("node:path"));

var _writeFileAtomic = _interopRequireDefault(require("write-file-atomic"));

var _isCi = _interopRequireDefault(require("./is-ci.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var FILENAME = 'failing-tests.json';
var scheduler = {
  storeFailedTestFiles: function storeFailedTestFiles(runStatus, cacheDir) {
    if (_isCi["default"] || !cacheDir) {
      return;
    }

    var filename = _nodePath["default"].join(cacheDir, FILENAME); // Given that we're writing to a cache directory, consider this file
    // temporary.


    var temporaryFiles = [filename];

    try {
      _writeFileAtomic["default"].sync(filename, JSON.stringify(runStatus.getFailedTestFiles()), {
        tmpfileCreated: function tmpfileCreated(tmpfile) {
          temporaryFiles.push(tmpfile);
        }
      });
    } catch (_unused) {}

    return {
      changedFiles: [],
      temporaryFiles: temporaryFiles
    };
  },
  // Order test-files, so that files with failing tests come first
  failingTestsFirst: function failingTestsFirst(selectedFiles, cacheDir, cacheEnabled) {
    if (_isCi["default"] || cacheEnabled === false) {
      return selectedFiles;
    }

    var filePath = _nodePath["default"].join(cacheDir, FILENAME);

    var failedTestFiles;

    try {
      failedTestFiles = JSON.parse(_nodeFs["default"].readFileSync(filePath));
    } catch (_unused2) {
      return selectedFiles;
    }

    return _toConsumableArray(selectedFiles).sort(function (f, s) {
      if (failedTestFiles.includes(f) && failedTestFiles.includes(s)) {
        return 0;
      }

      if (failedTestFiles.includes(f)) {
        return -1;
      }

      if (failedTestFiles.includes(s)) {
        return 1;
      }

      return 0;
    });
  }
};
var _default = scheduler;
exports["default"] = _default;