"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tagWorkerError = tagWorkerError;
exports["default"] = serializeError;

var _nodePath = _interopRequireDefault(require("node:path"));

var _nodeUrl = require("node:url");

var _types = require("node:util/types");

var _concordance = _interopRequireDefault(require("concordance"));

var _stackUtils = _interopRequireDefault(require("stack-utils"));

var _assert = require("./assert.js");

var _concordanceOptions = _interopRequireDefault(require("./concordance-options.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function isAvaAssertionError(source) {
  return source instanceof _assert.AssertionError;
}

function normalizeFile(file) {
  for (var _len = arguments.length, base = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    base[_key - 1] = arguments[_key];
  }

  return file.startsWith('file://') ? file : (0, _nodeUrl.pathToFileURL)(_nodePath["default"].resolve.apply(_nodePath["default"], base.concat([file]))).toString();
}

var stackUtils = new _stackUtils["default"]();

function extractSource(stack, testFile) {
  if (!stack || !testFile) {
    return null;
  }

  testFile = normalizeFile(testFile);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = stack.split('\n')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var line = _step.value;
      var callSite = stackUtils.parseLine(line);

      if (callSite && normalizeFile(callSite.file) === testFile) {
        return {
          isDependency: false,
          isWithinProject: true,
          file: testFile,
          line: callSite.line
        };
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return null;
}

var workerErrors = new WeakSet();

function tagWorkerError(error) {
  // Track worker errors, which aren't native due to https://github.com/nodejs/node/issues/48716.
  // Still include the check for isNativeError() in case the issue is fixed in the future.
  if ((0, _types.isNativeError)(error) || error instanceof Error) {
    workerErrors.add(error);
  }

  return error;
}

var isWorkerError = function isWorkerError(error) {
  return workerErrors.has(error);
};

function serializeError(error) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$testFile = _ref.testFile,
      testFile = _ref$testFile === void 0 ? null : _ref$testFile;

  if (!(0, _types.isNativeError)(error) && !isWorkerError(error)) {
    return {
      type: 'unknown',
      originalError: error,
      // Note that the main process receives a structured clone.
      formattedError: _concordance["default"].formatDescriptor(_concordance["default"].describe(error, _concordanceOptions["default"]), _concordanceOptions["default"])
    };
  }

  var message = error.message,
      name = error.name,
      stack = error.stack;
  var base = {
    message: message,
    name: name,
    originalError: error,
    // Note that the main process receives a structured clone.
    stack: stack
  };

  if (!isAvaAssertionError(error)) {
    if (name === 'AggregateError') {
      return _objectSpread({}, base, {
        type: 'aggregate',
        errors: error.errors.map(function (error) {
          return serializeError(error, {
            testFile: testFile
          });
        })
      });
    }

    return _objectSpread({}, base, {
      type: 'native',
      source: extractSource(error.stack, testFile)
    });
  }

  return _objectSpread({}, base, {
    type: 'ava',
    assertion: error.assertion,
    improperUsage: error.improperUsage,
    formattedCause: error.cause ? _concordance["default"].formatDescriptor(_concordance["default"].describe(error.cause, _concordanceOptions["default"]), _concordanceOptions["default"]) : null,
    formattedDetails: error.formattedDetails,
    source: extractSource(error.assertionStack, testFile),
    stack: (0, _types.isNativeError)(error.cause) ? error.cause.stack : error.assertionStack
  });
}