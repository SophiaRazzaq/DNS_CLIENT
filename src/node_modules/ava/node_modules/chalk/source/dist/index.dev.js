"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "modifierNames", {
  enumerable: true,
  get: function get() {
    return _index.modifierNames;
  }
});
Object.defineProperty(exports, "foregroundColorNames", {
  enumerable: true,
  get: function get() {
    return _index.foregroundColorNames;
  }
});
Object.defineProperty(exports, "backgroundColorNames", {
  enumerable: true,
  get: function get() {
    return _index.backgroundColorNames;
  }
});
Object.defineProperty(exports, "colorNames", {
  enumerable: true,
  get: function get() {
    return _index.colorNames;
  }
});
Object.defineProperty(exports, "modifiers", {
  enumerable: true,
  get: function get() {
    return _index.modifierNames;
  }
});
Object.defineProperty(exports, "foregroundColors", {
  enumerable: true,
  get: function get() {
    return _index.foregroundColorNames;
  }
});
Object.defineProperty(exports, "backgroundColors", {
  enumerable: true,
  get: function get() {
    return _index.backgroundColorNames;
  }
});
Object.defineProperty(exports, "colors", {
  enumerable: true,
  get: function get() {
    return _index.colorNames;
  }
});
exports["default"] = exports.supportsColorStderr = exports.supportsColor = exports.chalkStderr = exports.Chalk = void 0;

var _ansiStyles = _interopRequireDefault(require("#ansi-styles"));

var _supportsColor = _interopRequireDefault(require("#supports-color"));

var _utilities = require("./utilities.js");

var _index = require("./vendor/ansi-styles/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var stdoutColor = _supportsColor["default"].stdout,
    stderrColor = _supportsColor["default"].stderr;
exports.supportsColorStderr = stderrColor;
exports.supportsColor = stdoutColor;
var GENERATOR = Symbol('GENERATOR');
var STYLER = Symbol('STYLER');
var IS_EMPTY = Symbol('IS_EMPTY'); // `supportsColor.level` â†’ `ansiStyles.color[name]` mapping

var levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
var styles = Object.create(null);

var applyOptions = function applyOptions(object) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
    throw new Error('The `level` option should be an integer from 0 to 3');
  } // Detect level if not set manually


  var colorLevel = stdoutColor ? stdoutColor.level : 0;
  object.level = options.level === undefined ? colorLevel : options.level;
};

var Chalk = function Chalk(options) {
  _classCallCheck(this, Chalk);

  // eslint-disable-next-line no-constructor-return
  return chalkFactory(options);
};

exports.Chalk = Chalk;

var chalkFactory = function chalkFactory(options) {
  var chalk = function chalk() {
    for (var _len = arguments.length, strings = new Array(_len), _key = 0; _key < _len; _key++) {
      strings[_key] = arguments[_key];
    }

    return strings.join(' ');
  };

  applyOptions(chalk, options);
  Object.setPrototypeOf(chalk, createChalk.prototype);
  return chalk;
};

function createChalk(options) {
  return chalkFactory(options);
}

Object.setPrototypeOf(createChalk.prototype, Function.prototype);

var _loop = function _loop() {
  var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      styleName = _Object$entries$_i[0],
      style = _Object$entries$_i[1];

  styles[styleName] = {
    get: function get() {
      var builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
      Object.defineProperty(this, styleName, {
        value: builder
      });
      return builder;
    }
  };
};

for (var _i = 0, _Object$entries = Object.entries(_ansiStyles["default"]); _i < _Object$entries.length; _i++) {
  _loop();
}

styles.visible = {
  get: function get() {
    var builder = createBuilder(this, this[STYLER], true);
    Object.defineProperty(this, 'visible', {
      value: builder
    });
    return builder;
  }
};

var getModelAnsi = function getModelAnsi(model, level, type) {
  var _ansiStyles$type2;

  for (var _len2 = arguments.length, arguments_ = new Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {
    arguments_[_key2 - 3] = arguments[_key2];
  }

  if (model === 'rgb') {
    if (level === 'ansi16m') {
      var _ansiStyles$type;

      return (_ansiStyles$type = _ansiStyles["default"][type]).ansi16m.apply(_ansiStyles$type, arguments_);
    }

    if (level === 'ansi256') {
      return _ansiStyles["default"][type].ansi256(_ansiStyles["default"].rgbToAnsi256.apply(_ansiStyles["default"], arguments_));
    }

    return _ansiStyles["default"][type].ansi(_ansiStyles["default"].rgbToAnsi.apply(_ansiStyles["default"], arguments_));
  }

  if (model === 'hex') {
    return getModelAnsi.apply(void 0, ['rgb', level, type].concat(_toConsumableArray(_ansiStyles["default"].hexToRgb.apply(_ansiStyles["default"], arguments_))));
  }

  return (_ansiStyles$type2 = _ansiStyles["default"][type])[model].apply(_ansiStyles$type2, arguments_);
};

var usedModels = ['rgb', 'hex', 'ansi256'];

var _loop2 = function _loop2() {
  var model = _usedModels[_i2];
  styles[model] = {
    get: function get() {
      var level = this.level;
      return function () {
        for (var _len4 = arguments.length, arguments_ = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          arguments_[_key4] = arguments[_key4];
        }

        var styler = createStyler(getModelAnsi.apply(void 0, [model, levelMapping[level], 'color'].concat(arguments_)), _ansiStyles["default"].color.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
  var bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
  styles[bgModel] = {
    get: function get() {
      var level = this.level;
      return function () {
        for (var _len5 = arguments.length, arguments_ = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          arguments_[_key5] = arguments[_key5];
        }

        var styler = createStyler(getModelAnsi.apply(void 0, [model, levelMapping[level], 'bgColor'].concat(arguments_)), _ansiStyles["default"].bgColor.close, this[STYLER]);
        return createBuilder(this, styler, this[IS_EMPTY]);
      };
    }
  };
};

for (var _i2 = 0, _usedModels = usedModels; _i2 < _usedModels.length; _i2++) {
  _loop2();
}

var proto = Object.defineProperties(function () {}, _objectSpread({}, styles, {
  level: {
    enumerable: true,
    get: function get() {
      return this[GENERATOR].level;
    },
    set: function set(level) {
      this[GENERATOR].level = level;
    }
  }
}));

var createStyler = function createStyler(open, close, parent) {
  var openAll;
  var closeAll;

  if (parent === undefined) {
    openAll = open;
    closeAll = close;
  } else {
    openAll = parent.openAll + open;
    closeAll = close + parent.closeAll;
  }

  return {
    open: open,
    close: close,
    openAll: openAll,
    closeAll: closeAll,
    parent: parent
  };
};

var createBuilder = function createBuilder(self, _styler, _isEmpty) {
  // Single argument is hot path, implicit coercion is faster than anything
  // eslint-disable-next-line no-implicit-coercion
  var builder = function builder() {
    for (var _len3 = arguments.length, arguments_ = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      arguments_[_key3] = arguments[_key3];
    }

    return applyStyle(builder, arguments_.length === 1 ? '' + arguments_[0] : arguments_.join(' '));
  }; // We alter the prototype because we must return a function, but there is
  // no way to create a function with a different prototype


  Object.setPrototypeOf(builder, proto);
  builder[GENERATOR] = self;
  builder[STYLER] = _styler;
  builder[IS_EMPTY] = _isEmpty;
  return builder;
};

var applyStyle = function applyStyle(self, string) {
  if (self.level <= 0 || !string) {
    return self[IS_EMPTY] ? '' : string;
  }

  var styler = self[STYLER];

  if (styler === undefined) {
    return string;
  }

  var _styler2 = styler,
      openAll = _styler2.openAll,
      closeAll = _styler2.closeAll;

  if (string.includes("\x1B")) {
    while (styler !== undefined) {
      // Replace any instances already present with a re-opening code
      // otherwise only the part of the string until said closing code
      // will be colored, and the rest will simply be 'plain'.
      string = (0, _utilities.stringReplaceAll)(string, styler.close, styler.open);
      styler = styler.parent;
    }
  } // We can move both next actions out of loop, because remaining actions in loop won't have
  // any/visible effect on parts we add here. Close the styling before a linebreak and reopen
  // after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92


  var lfIndex = string.indexOf('\n');

  if (lfIndex !== -1) {
    string = (0, _utilities.stringEncaseCRLFWithFirstIndex)(string, closeAll, openAll, lfIndex);
  }

  return openAll + string + closeAll;
};

Object.defineProperties(createChalk.prototype, styles);
var chalk = createChalk();
var chalkStderr = createChalk({
  level: stderrColor ? stderrColor.level : 0
});
exports.chalkStderr = chalkStderr;
var _default = chalk;
exports["default"] = _default;