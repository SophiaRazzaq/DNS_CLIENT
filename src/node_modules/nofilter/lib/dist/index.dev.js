'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var stream = require('stream');

var _require = require('buffer'),
    Buffer = _require.Buffer;

var td = new TextDecoder('utf8', {
  fatal: true,
  ignoreBOM: true
});
/**
 * @typedef {object} NoFilterOptions
 * @property {string|Buffer} [input=null] Input source data.
 * @property {BufferEncoding} [inputEncoding=null] Encoding name for input,
 *   ignored if input is not a String.
 * @property {number} [highWaterMark=16384] The maximum number of bytes to
 *   store in the internal buffer before ceasing to read from the underlying
 *   resource. Default=16kb, or 16 for objectMode streams.
 * @property {BufferEncoding} [encoding=null] If specified, then buffers
 *   will be decoded to strings using the specified encoding.
 * @property {boolean} [objectMode=false] Whether this stream should behave
 *   as a stream of objects. Meaning that stream.read(n) returns a single
 *   value instead of a Buffer of size n.
 * @property {boolean} [decodeStrings=true] Whether or not to decode
 *   strings into Buffers before passing them to _write().
 * @property {boolean} [watchPipe=true] Whether to watch for 'pipe' events,
 *   setting this stream's objectMode based on the objectMode of the input
 *   stream.
 * @property {boolean} [readError=false] If true, when a read() underflows,
 *   throw an error.
 * @property {boolean} [allowHalfOpen=true] If set to false, then the
 *   stream will automatically end the writable side when the readable side
 *   ends.
 * @property {boolean} [autoDestroy=true] Whether this stream should
 *   automatically call .destroy() on itself after ending.
 * @property {BufferEncoding} [defaultEncoding='utf8'] The default encoding
 *   that is used when no encoding is specified as an argument to
 *   stream.write().
 * @property {boolean} [emitClose=true] Whether or not the stream should
 *   emit 'close' after it has been destroyed.
 * @property {number} [readableHighWaterMark] Sets highWaterMark for the
 *   readable side of the stream. Has no effect if highWaterMark is provided.
 * @property {boolean} [readableObjectMode=false] Sets objectMode for
 *   readable side of the stream. Has no effect if objectMode is true.
 * @property {number} [writableHighWaterMark] Sets highWaterMark for the
 *   writable side of the stream. Has no effect if highWaterMark is provided.
 * @property {boolean} [writableObjectMode=false] Sets objectMode for
 *   writable side of the stream. Has no effect if objectMode is true.
 */

/**
 * NoFilter stream.  Can be used to sink or source data to and from
 * other node streams.  Implemented as the "identity" Transform stream
 * (hence the name), but allows for inspecting data that is in-flight.
 *
 * Allows passing in source data (input, inputEncoding) at creation
 * time.  Source data can also be passed in the options object.
 *
 * @example <caption>source and sink</caption>
 * const source = new NoFilter('Zm9v', 'base64')
 * source.pipe(process.stdout)
 * const sink = new Nofilter()
 * // NOTE: 'finish' fires when the input is done writing
 * sink.on('finish', () => console.log(n.toString('base64')))
 * process.stdin.pipe(sink)
 */

var NoFilter =
/*#__PURE__*/
function (_stream$Transform) {
  _inherits(NoFilter, _stream$Transform);

  /**
   * Create an instance of NoFilter.
   *
   * @param {string|Buffer|BufferEncoding|NoFilterOptions} [input] Source data.
   * @param {BufferEncoding|NoFilterOptions} [inputEncoding] Encoding
   *   name for input, ignored if input is not a String.
   * @param {NoFilterOptions} [options] Other options.
   */
  function NoFilter(input, inputEncoding) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, NoFilter);

    var inp = null;
    var inpE =
    /** @type {BufferEncoding?} */
    null;

    switch (_typeof(input)) {
      case 'object':
        if (Buffer.isBuffer(input)) {
          inp = input;
        } else if (input) {
          options = input;
        }

        break;

      case 'string':
        inp = input;
        break;

      case 'undefined':
        break;

      default:
        throw new TypeError('Invalid input');
    }

    switch (_typeof(inputEncoding)) {
      case 'object':
        if (inputEncoding) {
          options = inputEncoding;
        }

        break;

      case 'string':
        inpE =
        /** @type {BufferEncoding} */
        inputEncoding;
        break;

      case 'undefined':
        break;

      default:
        throw new TypeError('Invalid inputEncoding');
    }

    if (!options || _typeof(options) !== 'object') {
      throw new TypeError('Invalid options');
    }

    if (inp == null) {
      inp = options.input;
    }

    if (inpE == null) {
      inpE = options.inputEncoding;
    }

    delete options.input;
    delete options.inputEncoding;
    var watchPipe = options.watchPipe == null ? true : options.watchPipe;
    delete options.watchPipe;
    var readError = Boolean(options.readError);
    delete options.readError;
    _this = _possibleConstructorReturn(this, _getPrototypeOf(NoFilter).call(this, options));
    _this.readError = readError;

    if (watchPipe) {
      _this.on('pipe', function (readable) {
        // @ts-ignore: TS2339 (using internal interface)
        var om = readable._readableState.objectMode; // @ts-ignore: TS2339 (using internal interface)

        if (_this.length > 0 && om !== _this._readableState.objectMode) {
          throw new Error('Do not switch objectMode in the middle of the stream');
        } // @ts-ignore: TS2339 (using internal interface)


        _this._readableState.objectMode = om; // @ts-ignore: TS2339 (using internal interface)

        _this._writableState.objectMode = om;
      });
    }

    if (inp != null) {
      _this.end(inp, inpE);
    }

    return _this;
  }
  /**
   * Is the given object a {NoFilter}?
   *
   * @param {object} obj The object to test.
   * @returns {boolean} True if obj is a NoFilter.
   */


  _createClass(NoFilter, [{
    key: "_transform",

    /**
     * @ignore
     */
    value: function _transform(chunk, encoding, callback) {
      // @ts-ignore: TS2339 (using internal interface)
      if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {
        chunk = Buffer.from(chunk, encoding);
      }

      this.push(chunk);
      callback();
    }
    /**
     * @returns {Buffer[]} The current internal buffers.  They are layed out
     *   end to end.
     * @ignore
     */

  }, {
    key: "_bufArray",
    value: function _bufArray() {
      // @ts-ignore: TS2339 (using internal interface)
      var bufs = this._readableState.buffer; // HACK: replace with something else one day.  This is what I get for
      // relying on internals.

      if (!Array.isArray(bufs)) {
        var b = bufs.head;
        bufs = [];

        while (b != null) {
          bufs.push(b.data);
          b = b.next;
        }
      }

      return bufs;
    }
    /**
     * Pulls some data out of the internal buffer and returns it.
     * If there is no data available, then it will return null.
     *
     * If you pass in a size argument, then it will return that many bytes. If
     * size bytes are not available, then it will return null, unless we've
     * ended, in which case it will return the data remaining in the buffer.
     *
     * If you do not specify a size argument, then it will return all the data in
     * the internal buffer.
     *
     * @param {number} [size=null] Number of bytes to read.
     * @returns {string|Buffer|null} If no data or not enough data, null.  If
     *   decoding output a string, otherwise a Buffer.
     * @throws Error If readError is true and there was underflow.
     * @fires NoFilter#read When read from.
     */

  }, {
    key: "read",
    value: function read(size) {
      var buf = _get(_getPrototypeOf(NoFilter.prototype), "read", this).call(this, size);

      if (buf != null) {
        /**
         * Read event. Fired whenever anything is read from the stream.
         *
         * @event NoFilter#read
         * @param {Buffer|string|object} buf What was read.
         */
        this.emit('read', buf);

        if (this.readError && buf.length < size) {
          throw new Error("Read ".concat(buf.length, ", wanted ").concat(size));
        }
      } else if (this.readError) {
        throw new Error("No data available, wanted ".concat(size));
      }

      return buf;
    }
    /**
     * Read the full number of bytes asked for, no matter how long it takes.
     * Fail if an error occurs in the meantime, or if the stream finishes before
     * enough data is available.
     *
     * Note: This function won't work fully correctly if you are using
     * stream-browserify (for example, on the Web).
     *
     * @param {number} size The number of bytes to read.
     * @returns {Promise<string|Buffer>} A promise for the data read.
     */

  }, {
    key: "readFull",
    value: function readFull(size) {
      var _this2 = this;

      var onReadable = null;
      var onFinish = null;
      var onError = null;
      return new Promise(function (resolve, reject) {
        if (_this2.length >= size) {
          resolve(_this2.read(size));
          return;
        } // Added in Node 12.19.  This won't work with stream-browserify yet.
        // If it's needed, file a bug, and I'll do a work-around.


        if (_this2.writableFinished) {
          // Already finished writing, so no more coming.
          reject(new Error("Stream finished before ".concat(size, " bytes were available")));
          return;
        }

        onReadable = function onReadable(chunk) {
          if (_this2.length >= size) {
            resolve(_this2.read(size));
          }
        };

        onFinish = function onFinish() {
          reject(new Error("Stream finished before ".concat(size, " bytes were available")));
        };

        onError = reject;

        _this2.on('readable', onReadable);

        _this2.on('error', onError);

        _this2.on('finish', onFinish);
      })["finally"](function () {
        if (onReadable) {
          _this2.removeListener('readable', onReadable);

          _this2.removeListener('error', onError);

          _this2.removeListener('finish', onFinish);
        }
      });
    }
    /**
     * Return a promise fulfilled with the full contents, after the 'finish'
     * event fires.  Errors on the stream cause the promise to be rejected.
     *
     * @param {Function} [cb=null] Finished/error callback used in *addition*
     *   to the promise.
     * @returns {Promise<Buffer|string>} Fulfilled when complete.
     */

  }, {
    key: "promise",
    value: function promise(cb) {
      var _this3 = this;

      var done = false;
      return new Promise(function (resolve, reject) {
        _this3.on('finish', function () {
          var data = _this3.read();

          if (cb != null && !done) {
            done = true;
            cb(null, data);
          }

          resolve(data);
        });

        _this3.on('error', function (er) {
          if (cb != null && !done) {
            done = true;
            cb(er);
          }

          reject(er);
        });
      });
    }
    /**
     * Returns a number indicating whether this comes before or after or is the
     * same as the other NoFilter in sort order.
     *
     * @param {NoFilter} other The other object to compare.
     * @returns {number} -1, 0, 1 for less, equal, greater.
     * @throws {TypeError} Arguments must be NoFilters.
     */

  }, {
    key: "compare",
    value: function compare(other) {
      if (!(other instanceof NoFilter)) {
        throw new TypeError('Arguments must be NoFilters');
      }

      if (this === other) {
        return 0;
      }

      var buf1 = this.slice();
      var buf2 = other.slice(); // These will both be buffers because of the check above.

      if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {
        return buf1.compare(buf2);
      }

      throw new Error('Cannot compare streams in object mode');
    }
    /**
     * Do these NoFilter's contain the same bytes?  Doesn't work if either is
     * in object mode.
     *
     * @param {NoFilter} other Other NoFilter to compare against.
     * @returns {boolean} Equal?
     */

  }, {
    key: "equals",
    value: function equals(other) {
      return this.compare(other) === 0;
    }
    /**
     * Read bytes or objects without consuming them.  Useful for diagnostics.
     * Note: as a side-effect, concatenates multiple writes together into what
     * looks like a single write, so that this concat doesn't have to happen
     * multiple times when you're futzing with the same NoFilter.
     *
     * @param {number} [start=0] Beginning offset.
     * @param {number} [end=length] Ending offset.
     * @returns {Buffer|Array} If in object mode, an array of objects.  Otherwise,
     *   concatenated array of contents.
     */

  }, {
    key: "slice",
    value: function slice(start, end) {
      // @ts-ignore: TS2339 (using internal interface)
      if (this._readableState.objectMode) {
        return this._bufArray().slice(start, end);
      }

      var bufs = this._bufArray();

      switch (bufs.length) {
        case 0:
          return Buffer.alloc(0);

        case 1:
          return bufs[0].slice(start, end);

        default:
          {
            var b = Buffer.concat(bufs); // TODO: store the concatented bufs back
            // @_readableState.buffer = [b]

            return b.slice(start, end);
          }
      }
    }
    /**
     * Get a byte by offset.  I didn't want to get into metaprogramming
     * to give you the `NoFilter[0]` syntax.
     *
     * @param {number} index The byte to retrieve.
     * @returns {number} 0-255.
     */

  }, {
    key: "get",
    value: function get(index) {
      return this.slice()[index];
    }
    /**
     * Return an object compatible with Buffer's toJSON implementation, so that
     * round-tripping will produce a Buffer.
     *
     * @returns {string|Array|{type: 'Buffer',data: number[]}} If in object mode,
     *   the objects.  Otherwise, JSON text.
     * @example <caption>output for 'foo', not in object mode</caption>
     * ({
     *   type: 'Buffer',
     *   data: [102, 111, 111],
     * })
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var b = this.slice();

      if (Buffer.isBuffer(b)) {
        return b.toJSON();
      }

      return b;
    }
    /**
     * Decodes and returns a string from buffer data encoded using the specified
     * character set encoding. If encoding is undefined or null, then encoding
     * defaults to 'utf8'. The start and end parameters default to 0 and
     * NoFilter.length when undefined.
     *
     * @param {BufferEncoding} [encoding='utf8'] Which to use for decoding?
     * @param {number} [start=0] Start offset.
     * @param {number} [end=length] End offset.
     * @returns {string} String version of the contents.
     */

  }, {
    key: "toString",
    value: function toString(encoding, start, end) {
      var buf = this.slice(start, end);

      if (!Buffer.isBuffer(buf)) {
        return JSON.stringify(buf);
      }

      if (!encoding || encoding === 'utf8') {
        return td.decode(buf);
      }

      return buf.toString(encoding);
    }
    /**
     * @ignore
     */

  }, {
    key: Symbol["for"]('nodejs.util.inspect.custom'),
    value: function value(depth, options) {
      var bufs = this._bufArray();

      var hex = bufs.map(function (b) {
        if (Buffer.isBuffer(b)) {
          return options.stylize(b.toString('hex'), 'string');
        }

        return JSON.stringify(b);
      }).join(', ');
      return "".concat(this.constructor.name, " [").concat(hex, "]");
    }
    /**
     * Current readable length, in bytes.
     *
     * @returns {number} Length of the contents.
     */

  }, {
    key: "writeBigInt",

    /**
     * Write a JavaScript BigInt to the stream.  Negative numbers will be
     * written as their 2's complement version.
     *
     * @param {bigint} val The value to write.
     * @returns {boolean} True on success.
     */
    value: function writeBigInt(val) {
      var str = val.toString(16);

      if (val < 0) {
        // Two's complement
        // Note: str always starts with '-' here.
        var sz = BigInt(Math.floor(str.length / 2));
        var mask = BigInt(1) << sz * BigInt(8);
        val = mask + val;
        str = val.toString(16);
      }

      if (str.length % 2) {
        str = "0".concat(str);
      }

      return this.push(Buffer.from(str, 'hex'));
    }
    /**
     * Read a variable-sized JavaScript unsigned BigInt from the stream.
     *
     * @param {number} [len=null] Number of bytes to read or all remaining
     *   if null.
     * @returns {bigint} A BigInt.
     */

  }, {
    key: "readUBigInt",
    value: function readUBigInt(len) {
      var b = this.read(len);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return BigInt("0x".concat(b.toString('hex')));
    }
    /**
     * Read a variable-sized JavaScript signed BigInt from the stream in 2's
     * complement format.
     *
     * @param {number} [len=null] Number of bytes to read or all remaining
     *   if null.
     * @returns {bigint} A BigInt.
     */

  }, {
    key: "readBigInt",
    value: function readBigInt(len) {
      var b = this.read(len);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      var ret = BigInt("0x".concat(b.toString('hex'))); // Negative?

      if (b[0] & 0x80) {
        // Two's complement
        var mask = BigInt(1) << BigInt(b.length) * BigInt(8);
        ret -= mask;
      }

      return ret;
    }
    /**
     * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.
     *
     * @param {number} value 0..255.
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeUInt8",
    value: function writeUInt8(value) {
      var b = Buffer.from([value]);
      return this.push(b);
    }
    /**
     * Write a little-endian 16-bit unsigned integer to the stream.  Adds
     * 2 bytes.
     *
     * @param {number} value 0..65535.
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeUInt16LE",
    value: function writeUInt16LE(value) {
      var b = Buffer.alloc(2);
      b.writeUInt16LE(value);
      return this.push(b);
    }
    /**
     * Write a big-endian 16-bit unsigned integer to the stream.  Adds
     * 2 bytes.
     *
     * @param {number} value 0..65535.
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeUInt16BE",
    value: function writeUInt16BE(value) {
      var b = Buffer.alloc(2);
      b.writeUInt16BE(value);
      return this.push(b);
    }
    /**
     * Write a little-endian 32-bit unsigned integer to the stream.  Adds
     * 4 bytes.
     *
     * @param {number} value 0..2**32-1.
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeUInt32LE",
    value: function writeUInt32LE(value) {
      var b = Buffer.alloc(4);
      b.writeUInt32LE(value);
      return this.push(b);
    }
    /**
     * Write a big-endian 32-bit unsigned integer to the stream.  Adds
     * 4 bytes.
     *
     * @param {number} value 0..2**32-1.
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeUInt32BE",
    value: function writeUInt32BE(value) {
      var b = Buffer.alloc(4);
      b.writeUInt32BE(value);
      return this.push(b);
    }
    /**
     * Write a signed 8-bit integer to the stream.  Adds 1 byte.
     *
     * @param {number} value (-128)..127.
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeInt8",
    value: function writeInt8(value) {
      var b = Buffer.from([value]);
      return this.push(b);
    }
    /**
     * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.
     *
     * @param {number} value (-32768)..32767.
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeInt16LE",
    value: function writeInt16LE(value) {
      var b = Buffer.alloc(2);
      b.writeUInt16LE(value);
      return this.push(b);
    }
    /**
     * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.
     *
     * @param {number} value (-32768)..32767.
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeInt16BE",
    value: function writeInt16BE(value) {
      var b = Buffer.alloc(2);
      b.writeUInt16BE(value);
      return this.push(b);
    }
    /**
     * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.
     *
     * @param {number} value (-2**31)..(2**31-1).
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeInt32LE",
    value: function writeInt32LE(value) {
      var b = Buffer.alloc(4);
      b.writeUInt32LE(value);
      return this.push(b);
    }
    /**
     * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.
     *
     * @param {number} value (-2**31)..(2**31-1).
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeInt32BE",
    value: function writeInt32BE(value) {
      var b = Buffer.alloc(4);
      b.writeUInt32BE(value);
      return this.push(b);
    }
    /**
     * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.
     *
     * @param {number} value 32-bit float.
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeFloatLE",
    value: function writeFloatLE(value) {
      var b = Buffer.alloc(4);
      b.writeFloatLE(value);
      return this.push(b);
    }
    /**
     * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.
     *
     * @param {number} value 32-bit float.
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeFloatBE",
    value: function writeFloatBE(value) {
      var b = Buffer.alloc(4);
      b.writeFloatBE(value);
      return this.push(b);
    }
    /**
     * Write a little-endian 64-bit double to the stream.  Adds 8 bytes.
     *
     * @param {number} value 64-bit float.
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeDoubleLE",
    value: function writeDoubleLE(value) {
      var b = Buffer.alloc(8);
      b.writeDoubleLE(value);
      return this.push(b);
    }
    /**
     * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.
     *
     * @param {number} value 64-bit float.
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeDoubleBE",
    value: function writeDoubleBE(value) {
      var b = Buffer.alloc(8);
      b.writeDoubleBE(value);
      return this.push(b);
    }
    /**
     * Write a signed little-endian 64-bit BigInt to the stream.  Adds 8 bytes.
     *
     * @param {bigint} value BigInt.
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeBigInt64LE",
    value: function writeBigInt64LE(value) {
      var b = Buffer.alloc(8);
      b.writeBigInt64LE(value);
      return this.push(b);
    }
    /**
     * Write a signed big-endian 64-bit BigInt to the stream.  Adds 8 bytes.
     *
     * @param {bigint} value BigInt.
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeBigInt64BE",
    value: function writeBigInt64BE(value) {
      var b = Buffer.alloc(8);
      b.writeBigInt64BE(value);
      return this.push(b);
    }
    /**
     * Write an unsigned little-endian 64-bit BigInt to the stream.  Adds 8 bytes.
     *
     * @param {bigint} value Non-negative BigInt.
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeBigUInt64LE",
    value: function writeBigUInt64LE(value) {
      var b = Buffer.alloc(8);
      b.writeBigUInt64LE(value);
      return this.push(b);
    }
    /**
     * Write an unsigned big-endian 64-bit BigInt to the stream.  Adds 8 bytes.
     *
     * @param {bigint} value Non-negative BigInt.
     * @returns {boolean} True on success.
     */

  }, {
    key: "writeBigUInt64BE",
    value: function writeBigUInt64BE(value) {
      var b = Buffer.alloc(8);
      b.writeBigUInt64BE(value);
      return this.push(b);
    }
    /**
     * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.
     *
     * @returns {number} Value read.
     */

  }, {
    key: "readUInt8",
    value: function readUInt8() {
      var b = this.read(1);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readUInt8();
    }
    /**
     * Read a little-endian unsigned 16-bit integer from the stream.
     * Consumes 2 bytes.
     *
     * @returns {number} Value read.
     */

  }, {
    key: "readUInt16LE",
    value: function readUInt16LE() {
      var b = this.read(2);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readUInt16LE();
    }
    /**
     * Read a little-endian unsigned 16-bit integer from the stream.
     * Consumes 2 bytes.
     *
     * @returns {number} Value read.
     */

  }, {
    key: "readUInt16BE",
    value: function readUInt16BE() {
      var b = this.read(2);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readUInt16BE();
    }
    /**
     * Read a little-endian unsigned 32-bit integer from the stream.
     * Consumes 4 bytes.
     *
     * @returns {number} Value read.
     */

  }, {
    key: "readUInt32LE",
    value: function readUInt32LE() {
      var b = this.read(4);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readUInt32LE();
    }
    /**
     * Read a little-endian unsigned 16-bit integer from the stream.
     * Consumes 4 bytes.
     *
     * @returns {number} Value read.
     */

  }, {
    key: "readUInt32BE",
    value: function readUInt32BE() {
      var b = this.read(4);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readUInt32BE();
    }
    /**
     * Read a signed 8-bit integer from the stream.  Consumes 1 byte.
     *
     * @returns {number} Value read.
     */

  }, {
    key: "readInt8",
    value: function readInt8() {
      var b = this.read(1);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readInt8();
    }
    /**
     * Read a little-endian signed 16-bit integer from the stream.
     * Consumes 2 bytes.
     *
     * @returns {number} Value read.
     */

  }, {
    key: "readInt16LE",
    value: function readInt16LE() {
      var b = this.read(2);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readInt16LE();
    }
    /**
     * Read a little-endian signed 16-bit integer from the stream.
     * Consumes 2 bytes.
     *
     * @returns {number} Value read.
     */

  }, {
    key: "readInt16BE",
    value: function readInt16BE() {
      var b = this.read(2);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readInt16BE();
    }
    /**
     * Read a little-endian signed 32-bit integer from the stream.
     * Consumes 4 bytes.
     *
     * @returns {number} Value read.
     */

  }, {
    key: "readInt32LE",
    value: function readInt32LE() {
      var b = this.read(4);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readInt32LE();
    }
    /**
     * Read a little-endian signed 16-bit integer from the stream.
     * Consumes 4 bytes.
     *
     * @returns {number} Value read.
     */

  }, {
    key: "readInt32BE",
    value: function readInt32BE() {
      var b = this.read(4);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readInt32BE();
    }
    /**
     * Read a 32-bit little-endian float from the stream.
     * Consumes 4 bytes.
     *
     * @returns {number} Value read.
     */

  }, {
    key: "readFloatLE",
    value: function readFloatLE() {
      var b = this.read(4);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readFloatLE();
    }
    /**
     * Read a 32-bit big-endian float from the stream.
     * Consumes 4 bytes.
     *
     * @returns {number} Value read.
     */

  }, {
    key: "readFloatBE",
    value: function readFloatBE() {
      var b = this.read(4);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readFloatBE();
    }
    /**
     * Read a 64-bit little-endian float from the stream.
     * Consumes 8 bytes.
     *
     * @returns {number} Value read.
     */

  }, {
    key: "readDoubleLE",
    value: function readDoubleLE() {
      var b = this.read(8);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readDoubleLE();
    }
    /**
     * Read a 64-bit big-endian float from the stream.
     * Consumes 8 bytes.
     *
     * @returns {number} Value read.
     */

  }, {
    key: "readDoubleBE",
    value: function readDoubleBE() {
      var b = this.read(8);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readDoubleBE();
    }
    /**
     * Read a signed 64-bit little-endian BigInt from the stream.
     * Consumes 8 bytes.
     *
     * @returns {bigint} Value read.
     */

  }, {
    key: "readBigInt64LE",
    value: function readBigInt64LE() {
      var b = this.read(8);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readBigInt64LE();
    }
    /**
     * Read a signed 64-bit big-endian BigInt from the stream.
     * Consumes 8 bytes.
     *
     * @returns {bigint} Value read.
     */

  }, {
    key: "readBigInt64BE",
    value: function readBigInt64BE() {
      var b = this.read(8);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readBigInt64BE();
    }
    /**
     * Read an unsigned 64-bit little-endian BigInt from the stream.
     * Consumes 8 bytes.
     *
     * @returns {bigint} Value read.
     */

  }, {
    key: "readBigUInt64LE",
    value: function readBigUInt64LE() {
      var b = this.read(8);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readBigUInt64LE();
    }
    /**
     * Read an unsigned 64-bit big-endian BigInt from the stream.
     * Consumes 8 bytes.
     *
     * @returns {bigint} Value read.
     */

  }, {
    key: "readBigUInt64BE",
    value: function readBigUInt64BE() {
      var b = this.read(8);

      if (!Buffer.isBuffer(b)) {
        return null;
      }

      return b.readBigUInt64BE();
    }
  }, {
    key: "length",
    get: function get() {
      // @ts-ignore: TS2339 (using internal interface)
      return this._readableState.length;
    }
  }], [{
    key: "isNoFilter",
    value: function isNoFilter(obj) {
      return obj instanceof this;
    }
    /**
     * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.
     *
     * @param {NoFilter} nf1 The first object to compare.
     * @param {NoFilter} nf2 The second object to compare.
     * @returns {number} -1, 0, 1 for less, equal, greater.
     * @throws {TypeError} Arguments not NoFilter instances.
     * @example
     * const arr = [new NoFilter('1234'), new NoFilter('0123')]
     * arr.sort(NoFilter.compare)
     */

  }, {
    key: "compare",
    value: function compare(nf1, nf2) {
      if (!(nf1 instanceof this)) {
        throw new TypeError('Arguments must be NoFilters');
      }

      if (nf1 === nf2) {
        return 0;
      }

      return nf1.compare(nf2);
    }
    /**
     * Returns a buffer which is the result of concatenating all the
     * NoFilters in the list together. If the list has no items, or if
     * the totalLength is 0, then it returns a zero-length buffer.
     *
     * If length is not provided, it is read from the buffers in the
     * list. However, this adds an additional loop to the function, so
     * it is faster to provide the length explicitly if you already know it.
     *
     * @param {Array<NoFilter>} list Inputs.  Must not be all either in object
     *   mode, or all not in object mode.
     * @param {number} [length=null] Number of bytes or objects to read.
     * @returns {Buffer|Array} The concatenated values as an array if in object
     *   mode, otherwise a Buffer.
     * @throws {TypeError} List not array of NoFilters.
     */

  }, {
    key: "concat",
    value: function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('list argument must be an Array of NoFilters');
      }

      if (list.length === 0 || length === 0) {
        return Buffer.alloc(0);
      }

      if (length == null) {
        length = list.reduce(function (tot, nf) {
          if (!(nf instanceof NoFilter)) {
            throw new TypeError('list argument must be an Array of NoFilters');
          }

          return tot + nf.length;
        }, 0);
      }

      var allBufs = true;
      var allObjs = true;
      var bufs = list.map(function (nf) {
        if (!(nf instanceof NoFilter)) {
          throw new TypeError('list argument must be an Array of NoFilters');
        }

        var buf = nf.slice();

        if (Buffer.isBuffer(buf)) {
          allObjs = false;
        } else {
          allBufs = false;
        }

        return buf;
      });

      if (allBufs) {
        // @ts-ignore: TS2322, tsc can't see the type checking above
        return Buffer.concat(bufs, length);
      }

      if (allObjs) {
        var _ref;

        return (_ref = []).concat.apply(_ref, _toConsumableArray(bufs)).slice(0, length);
      } // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays
      // counting objects?  I can't imagine why that would be useful.


      throw new Error('Concatenating mixed object and byte streams not supported');
    }
  }]);

  return NoFilter;
}(stream.Transform);

module.exports = NoFilter;