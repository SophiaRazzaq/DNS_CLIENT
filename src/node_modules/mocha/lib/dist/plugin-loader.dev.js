/**
 * Provides a way to load "plugins" as provided by the user.
 *
 * Currently supports:
 *
 * - Root hooks
 * - Global fixtures (setup/teardown)
 * @private
 * @module plugin
 */
'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError("Object is not async iterable"); }

var debug = require('debug')('mocha:plugin-loader');

var _require = require('./errors'),
    createInvalidPluginDefinitionError = _require.createInvalidPluginDefinitionError,
    createInvalidPluginImplementationError = _require.createInvalidPluginImplementationError;

var _require2 = require('./utils'),
    castArray = _require2.castArray;
/**
 * Built-in plugin definitions.
 */


var MochaPlugins = [
/**
 * Root hook plugin definition
 * @type {PluginDefinition}
 */
{
  exportName: 'mochaHooks',
  optionName: 'rootHooks',
  validate: function validate(value) {
    if (Array.isArray(value) || typeof value !== 'function' && _typeof(value) !== 'object') {
      throw createInvalidPluginImplementationError("mochaHooks must be an object or a function returning (or fulfilling with) an object");
    }
  },
  finalize: function finalize(rootHooks) {
    var rootHookObjects;
    return regeneratorRuntime.async(function finalize$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!rootHooks.length) {
              _context2.next = 5;
              break;
            }

            _context2.next = 3;
            return regeneratorRuntime.awrap(Promise.all(rootHooks.map(function _callee(hook) {
              return regeneratorRuntime.async(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      return _context.abrupt("return", typeof hook === 'function' ? hook() : hook);

                    case 1:
                    case "end":
                      return _context.stop();
                  }
                }
              });
            })));

          case 3:
            rootHookObjects = _context2.sent;
            return _context2.abrupt("return", rootHookObjects.reduce(function (acc, hook) {
              hook = _objectSpread({
                beforeAll: [],
                beforeEach: [],
                afterAll: [],
                afterEach: []
              }, hook);
              return {
                beforeAll: [].concat(_toConsumableArray(acc.beforeAll), _toConsumableArray(castArray(hook.beforeAll))),
                beforeEach: [].concat(_toConsumableArray(acc.beforeEach), _toConsumableArray(castArray(hook.beforeEach))),
                afterAll: [].concat(_toConsumableArray(acc.afterAll), _toConsumableArray(castArray(hook.afterAll))),
                afterEach: [].concat(_toConsumableArray(acc.afterEach), _toConsumableArray(castArray(hook.afterEach)))
              };
            }, {
              beforeAll: [],
              beforeEach: [],
              afterAll: [],
              afterEach: []
            }));

          case 5:
          case "end":
            return _context2.stop();
        }
      }
    });
  }
},
/**
 * Global setup fixture plugin definition
 * @type {PluginDefinition}
 */
{
  exportName: 'mochaGlobalSetup',
  optionName: 'globalSetup',
  validate: function validate(value) {
    var isValid = true;

    if (Array.isArray(value)) {
      if (value.some(function (item) {
        return typeof item !== 'function';
      })) {
        isValid = false;
      }
    } else if (typeof value !== 'function') {
      isValid = false;
    }

    if (!isValid) {
      throw createInvalidPluginImplementationError("mochaGlobalSetup must be a function or an array of functions", {
        pluginDef: this,
        pluginImpl: value
      });
    }
  }
},
/**
 * Global teardown fixture plugin definition
 * @type {PluginDefinition}
 */
{
  exportName: 'mochaGlobalTeardown',
  optionName: 'globalTeardown',
  validate: function validate(value) {
    var isValid = true;

    if (Array.isArray(value)) {
      if (value.some(function (item) {
        return typeof item !== 'function';
      })) {
        isValid = false;
      }
    } else if (typeof value !== 'function') {
      isValid = false;
    }

    if (!isValid) {
      throw createInvalidPluginImplementationError("mochaGlobalTeardown must be a function or an array of functions", {
        pluginDef: this,
        pluginImpl: value
      });
    }
  }
}];
/**
 * Contains a registry of [plugin definitions]{@link PluginDefinition} and discovers plugin implementations in user-supplied code.
 *
 * - [load()]{@link #load} should be called for all required modules
 * - The result of [finalize()]{@link #finalize} should be merged into the options for the [Mocha]{@link Mocha} constructor.
 * @private
 */

var PluginLoader =
/*#__PURE__*/
function () {
  /**
   * Initializes plugin names, plugin map, etc.
   * @param {PluginLoaderOptions} [opts] - Options
   */
  function PluginLoader() {
    var _this = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$pluginDefs = _ref.pluginDefs,
        pluginDefs = _ref$pluginDefs === void 0 ? MochaPlugins : _ref$pluginDefs,
        _ref$ignore = _ref.ignore,
        ignore = _ref$ignore === void 0 ? [] : _ref$ignore;

    _classCallCheck(this, PluginLoader);

    /**
     * Map of registered plugin defs
     * @type {Map<string,PluginDefinition>}
     */
    this.registered = new Map();
    /**
     * Cache of known `optionName` values for checking conflicts
     * @type {Set<string>}
     */

    this.knownOptionNames = new Set();
    /**
     * Cache of known `exportName` values for checking conflicts
     * @type {Set<string>}
     */

    this.knownExportNames = new Set();
    /**
     * Map of user-supplied plugin implementations
     * @type {Map<string,Array<*>>}
     */

    this.loaded = new Map();
    /**
     * Set of ignored plugins by export name
     * @type {Set<string>}
     */

    this.ignoredExportNames = new Set(castArray(ignore));
    castArray(pluginDefs).forEach(function (pluginDef) {
      _this.register(pluginDef);
    });
    debug('registered %d plugin defs (%d ignored)', this.registered.size, this.ignoredExportNames.size);
  }
  /**
   * Register a plugin
   * @param {PluginDefinition} pluginDef - Plugin definition
   */


  _createClass(PluginLoader, [{
    key: "register",
    value: function register(pluginDef) {
      if (!pluginDef || _typeof(pluginDef) !== 'object') {
        throw createInvalidPluginDefinitionError('pluginDef is non-object or falsy', pluginDef);
      }

      if (!pluginDef.exportName) {
        throw createInvalidPluginDefinitionError("exportName is expected to be a non-empty string", pluginDef);
      }

      var exportName = pluginDef.exportName;

      if (this.ignoredExportNames.has(exportName)) {
        debug('refusing to register ignored plugin with export name "%s"', exportName);
        return;
      }

      exportName = String(exportName);
      pluginDef.optionName = String(pluginDef.optionName || exportName);

      if (this.knownExportNames.has(exportName)) {
        throw createInvalidPluginDefinitionError("Plugin definition conflict: ".concat(exportName, "; exportName must be unique"), pluginDef);
      }

      this.loaded.set(exportName, []);
      this.registered.set(exportName, pluginDef);
      this.knownExportNames.add(exportName);
      this.knownOptionNames.add(pluginDef.optionName);
      debug('registered plugin def "%s"', exportName);
    }
    /**
     * Inspects a module's exports for known plugins and keeps them in memory.
     *
     * @param {*} requiredModule - The exports of a module loaded via `--require`
     * @returns {boolean} If one or more plugins was found, return `true`.
     */

  }, {
    key: "load",
    value: function load(requiredModule) {
      var _this2 = this;

      // we should explicitly NOT fail if other stuff is exported.
      // we only care about the plugins we know about.
      if (requiredModule && _typeof(requiredModule) === 'object') {
        return Array.from(this.knownExportNames).reduce(function (pluginImplFound, pluginName) {
          var pluginImpl = requiredModule[pluginName];

          if (pluginImpl) {
            var plugin = _this2.registered.get(pluginName);

            if (typeof plugin.validate === 'function') {
              plugin.validate(pluginImpl);
            }

            _this2.loaded.set(pluginName, [].concat(_toConsumableArray(_this2.loaded.get(pluginName)), _toConsumableArray(castArray(pluginImpl))));

            return true;
          }

          return pluginImplFound;
        }, false);
      }

      return false;
    }
    /**
     * Call the `finalize()` function of each known plugin definition on the plugins found by [load()]{@link PluginLoader#load}.
     *
     * Output suitable for passing as input into {@link Mocha} constructor.
     * @returns {Promise<object>} Object having keys corresponding to registered plugin definitions' `optionName` prop (or `exportName`, if none), and the values are the implementations as provided by a user.
     */

  }, {
    key: "finalize",
    value: function finalize() {
      var finalizedPlugins, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, _value2, _value3, exportName, pluginImpls, plugin;

      return regeneratorRuntime.async(function finalize$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              finalizedPlugins = Object.create(null);
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _context3.prev = 3;
              _iterator = _asyncIterator(this.loaded.entries());

            case 5:
              _context3.next = 7;
              return regeneratorRuntime.awrap(_iterator.next());

            case 7:
              _step = _context3.sent;
              _iteratorNormalCompletion = _step.done;
              _context3.next = 11;
              return regeneratorRuntime.awrap(_step.value);

            case 11:
              _value = _context3.sent;

              if (_iteratorNormalCompletion) {
                _context3.next = 27;
                break;
              }

              _value2 = _value, _value3 = _slicedToArray(_value2, 2), exportName = _value3[0], pluginImpls = _value3[1];

              if (!pluginImpls.length) {
                _context3.next = 24;
                break;
              }

              plugin = this.registered.get(exportName);

              if (!(typeof plugin.finalize === 'function')) {
                _context3.next = 22;
                break;
              }

              _context3.next = 19;
              return regeneratorRuntime.awrap(plugin.finalize(pluginImpls));

            case 19:
              _context3.t0 = _context3.sent;
              _context3.next = 23;
              break;

            case 22:
              _context3.t0 = pluginImpls;

            case 23:
              finalizedPlugins[plugin.optionName] = _context3.t0;

            case 24:
              _iteratorNormalCompletion = true;
              _context3.next = 5;
              break;

            case 27:
              _context3.next = 33;
              break;

            case 29:
              _context3.prev = 29;
              _context3.t1 = _context3["catch"](3);
              _didIteratorError = true;
              _iteratorError = _context3.t1;

            case 33:
              _context3.prev = 33;
              _context3.prev = 34;

              if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
                _context3.next = 38;
                break;
              }

              _context3.next = 38;
              return regeneratorRuntime.awrap(_iterator["return"]());

            case 38:
              _context3.prev = 38;

              if (!_didIteratorError) {
                _context3.next = 41;
                break;
              }

              throw _iteratorError;

            case 41:
              return _context3.finish(38);

            case 42:
              return _context3.finish(33);

            case 43:
              debug('finalized plugins: %O', finalizedPlugins);
              return _context3.abrupt("return", finalizedPlugins);

            case 45:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this, [[3, 29, 33, 43], [34,, 38, 42]]);
    }
    /**
     * Constructs a {@link PluginLoader}
     * @param {PluginLoaderOptions} [opts] - Plugin loader options
     */

  }], [{
    key: "create",
    value: function create() {
      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref2$pluginDefs = _ref2.pluginDefs,
          pluginDefs = _ref2$pluginDefs === void 0 ? MochaPlugins : _ref2$pluginDefs,
          _ref2$ignore = _ref2.ignore,
          ignore = _ref2$ignore === void 0 ? [] : _ref2$ignore;

      return new PluginLoader({
        pluginDefs: pluginDefs,
        ignore: ignore
      });
    }
  }]);

  return PluginLoader;
}();

module.exports = PluginLoader;
/**
 * Options for {@link PluginLoader}
 * @typedef {Object} PluginLoaderOptions
 * @property {PluginDefinition[]} [pluginDefs] - Plugin definitions
 * @property {string[]} [ignore] - A list of plugins to ignore when loading
 */