'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var fs = require('fs');

var path = require('path');

var ansi = require('ansi-colors');

var debug = require('debug')('mocha:cli:run:helpers');

var minimatch = require('minimatch');

var NO_FILES_MATCH_PATTERN = require('../errors').constants.NO_FILES_MATCH_PATTERN;

var lookupFiles = require('./lookup-files');

var _require = require('../utils'),
    castArray = _require.castArray;
/**
 * Exports a function that collects test files from CLI parameters.
 * @see module:lib/cli/run-helpers
 * @see module:lib/cli/watch-run
 * @module
 * @private
 */

/**
 * Smash together an array of test files in the correct order
 * @param {FileCollectionOptions} [opts] - Options
 * @returns {FileCollectionResponse} An object containing a list of files to test and unmatched files.
 * @private
 */


module.exports = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      ignore = _ref.ignore,
      extension = _ref.extension,
      fileArgs = _ref.file,
      recursive = _ref.recursive,
      sort = _ref.sort,
      spec = _ref.spec;

  var unmatchedSpecFiles = [];
  var specFiles = spec.reduce(function (specFiles, arg) {
    try {
      var moreSpecFiles = castArray(lookupFiles(arg, extension, recursive)).filter(function (filename) {
        return ignore.every(function (pattern) {
          return !minimatch(filename, pattern, {
            windowsPathsNoEscape: true
          });
        });
      }).map(function (filename) {
        return path.resolve(filename);
      });
      return [].concat(_toConsumableArray(specFiles), _toConsumableArray(moreSpecFiles));
    } catch (err) {
      if (err.code === NO_FILES_MATCH_PATTERN) {
        unmatchedSpecFiles.push({
          message: err.message,
          pattern: err.pattern
        });
        return specFiles;
      }

      throw err;
    }
  }, []); // check that each file passed in to --file exists

  var unmatchedFiles = [];
  fileArgs.forEach(function (file) {
    var fileAbsolutePath = path.resolve(file);

    try {
      // Used instead of fs.existsSync to ensure that file-ending less files are still resolved correctly
      require.resolve(fileAbsolutePath);
    } catch (err) {
      if (err.code === 'MODULE_NOT_FOUND') {
        unmatchedFiles.push({
          pattern: file,
          absolutePath: fileAbsolutePath
        });
        return;
      }

      throw err;
    }
  }); // ensure we don't sort the stuff from fileArgs; order is important!

  if (sort) {
    specFiles.sort();
  } // add files given through --file to be ran first


  var files = [].concat(_toConsumableArray(fileArgs.map(function (filepath) {
    return path.resolve(filepath);
  })), _toConsumableArray(specFiles));
  debug('test files (in order): ', files);

  if (!files.length) {
    // give full message details when only 1 file is missing
    var noneFoundMsg = unmatchedSpecFiles.length === 1 ? "Error: No test files found: ".concat(JSON.stringify(unmatchedSpecFiles[0].pattern)) // stringify to print escaped characters raw
    : 'Error: No test files found';
    console.error(ansi.red(noneFoundMsg));
    process.exit(1);
  } else {
    // print messages as a warning
    unmatchedSpecFiles.forEach(function (warning) {
      console.warn(ansi.yellow("Warning: ".concat(warning.message)));
    });
  }

  return {
    files: files,
    unmatchedFiles: unmatchedFiles
  };
};
/**
 * An object to configure how Mocha gathers test files
 * @private
 * @typedef {Object} FileCollectionOptions
 * @property {string[]} extension - File extensions to use
 * @property {string[]} spec - Files, dirs, globs to run
 * @property {string[]} ignore - Files, dirs, globs to ignore
 * @property {string[]} file - List of additional files to include
 * @property {boolean} recursive - Find files recursively
 * @property {boolean} sort - Sort test files
 */

/**
 * Diagnostic object containing unmatched files
 * @typedef {Object} UnmatchedFile -
 * @property {string} absolutePath - A list of unmatched files derived from the file arguments passed in.
 * @property {string} pattern - A list of unmatched files derived from the file arguments passed in.
 *
 */

/**
 * Response object containing a list of files to test and unmatched files.
 * @typedef {Object} FileCollectionResponse
 * @property {string[]} files - A list of files to test
 * @property {UnmatchedFile[]} unmatchedFiles - A list of unmatched files derived from the file arguments passed in.
 */