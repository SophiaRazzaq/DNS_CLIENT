'use strict';
/**
 * Helper scripts for the `run` command
 * @see module:lib/cli/run
 * @module
 * @private
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _asyncIterator(iterable) { var method; if (typeof Symbol !== "undefined") { if (Symbol.asyncIterator) { method = iterable[Symbol.asyncIterator]; if (method != null) return method.call(iterable); } if (Symbol.iterator) { method = iterable[Symbol.iterator]; if (method != null) return method.call(iterable); } } throw new TypeError("Object is not async iterable"); }

var fs = require('fs');

var path = require('path');

var ansi = require('ansi-colors');

var debug = require('debug')('mocha:cli:run:helpers');

var _require = require('./watch-run'),
    watchRun = _require.watchRun,
    watchParallelRun = _require.watchParallelRun;

var collectFiles = require('./collect-files');

var _require2 = require('util'),
    format = _require2.format;

var _require3 = require('../errors'),
    createInvalidLegacyPluginError = _require3.createInvalidLegacyPluginError;

var _require4 = require('../nodejs/esm-utils'),
    requireOrImport = _require4.requireOrImport;

var PluginLoader = require('../plugin-loader');

var _require5 = require('./collect-files'),
    UnmatchedFile = _require5.UnmatchedFile;
/**
 * Exits Mocha when tests + code under test has finished execution (default)
 * @param {number} code - Exit code; typically # of failures
 * @ignore
 * @private
 */


var exitMochaLater = function exitMochaLater(code) {
  process.on('exit', function () {
    process.exitCode = Math.min(code, 255);
  });
};
/**
 * Exits Mocha when Mocha itself has finished execution, regardless of
 * what the tests or code under test is doing.
 * @param {number} code - Exit code; typically # of failures
 * @ignore
 * @private
 */


var exitMocha = function exitMocha(code) {
  var clampedCode = Math.min(code, 255);
  var draining = 0; // Eagerly set the process's exit code in case stream.write doesn't
  // execute its callback before the process terminates.

  process.exitCode = clampedCode; // flush output for Node.js Windows pipe bug
  // https://github.com/joyent/node/issues/6247 is just one bug example
  // https://github.com/visionmedia/mocha/issues/333 has a good discussion

  var done = function done() {
    if (!draining--) {
      process.exit(clampedCode);
    }
  };

  var streams = [process.stdout, process.stderr];
  streams.forEach(function (stream) {
    // submit empty write request and wait for completion
    draining += 1;
    stream.write('', done);
  });
  done();
};
/**
 * Coerce a comma-delimited string (or array thereof) into a flattened array of
 * strings
 * @param {string|string[]} str - Value to coerce
 * @returns {string[]} Array of strings
 * @private
 */


exports.list = function (str) {
  return Array.isArray(str) ? exports.list(str.join(',')) : str.split(/ *, */);
};
/**
 * `require()` the modules as required by `--require <require>`.
 *
 * Returns array of `mochaHooks` exports, if any.
 * @param {string[]} requires - Modules to require
 * @returns {Promise<object>} Plugin implementations
 * @private
 */


exports.handleRequires = function _callee() {
  var requires,
      _ref,
      _ref$ignoredPlugins,
      ignoredPlugins,
      pluginLoader,
      _iteratorNormalCompletion,
      _didIteratorError,
      _iteratorError,
      _iterator,
      _step,
      _value,
      mod,
      modpath,
      requiredModule,
      plugins,
      _args = arguments;

  return regeneratorRuntime.async(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          requires = _args.length > 0 && _args[0] !== undefined ? _args[0] : [];
          _ref = _args.length > 1 && _args[1] !== undefined ? _args[1] : {}, _ref$ignoredPlugins = _ref.ignoredPlugins, ignoredPlugins = _ref$ignoredPlugins === void 0 ? [] : _ref$ignoredPlugins;
          pluginLoader = PluginLoader.create({
            ignore: ignoredPlugins
          });
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _context.prev = 5;
          _iterator = _asyncIterator(requires);

        case 7:
          _context.next = 9;
          return regeneratorRuntime.awrap(_iterator.next());

        case 9:
          _step = _context.sent;
          _iteratorNormalCompletion = _step.done;
          _context.next = 13;
          return regeneratorRuntime.awrap(_step.value);

        case 13:
          _value = _context.sent;

          if (_iteratorNormalCompletion) {
            _context.next = 26;
            break;
          }

          mod = _value;
          modpath = mod; // this is relative to cwd

          if (fs.existsSync(mod) || fs.existsSync("".concat(mod, ".js"))) {
            modpath = path.resolve(mod);
            debug('resolved required file %s to %s', mod, modpath);
          }

          _context.next = 20;
          return regeneratorRuntime.awrap(requireOrImport(modpath));

        case 20:
          requiredModule = _context.sent;

          if (requiredModule && _typeof(requiredModule) === 'object') {
            if (pluginLoader.load(requiredModule)) {
              debug('found one or more plugin implementations in %s', modpath);
            }
          }

          debug('loaded required module "%s"', mod);

        case 23:
          _iteratorNormalCompletion = true;
          _context.next = 7;
          break;

        case 26:
          _context.next = 32;
          break;

        case 28:
          _context.prev = 28;
          _context.t0 = _context["catch"](5);
          _didIteratorError = true;
          _iteratorError = _context.t0;

        case 32:
          _context.prev = 32;
          _context.prev = 33;

          if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
            _context.next = 37;
            break;
          }

          _context.next = 37;
          return regeneratorRuntime.awrap(_iterator["return"]());

        case 37:
          _context.prev = 37;

          if (!_didIteratorError) {
            _context.next = 40;
            break;
          }

          throw _iteratorError;

        case 40:
          return _context.finish(37);

        case 41:
          return _context.finish(32);

        case 42:
          _context.next = 44;
          return regeneratorRuntime.awrap(pluginLoader.finalize());

        case 44:
          plugins = _context.sent;

          if (Object.keys(plugins).length) {
            debug('finalized plugin implementations: %O', plugins);
          }

          return _context.abrupt("return", plugins);

        case 47:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[5, 28, 32, 42], [33,, 37, 41]]);
};
/**
 * Logs errors and exits the app if unmatched files exist
 * @param {Mocha} mocha - Mocha instance
 * @param {UnmatchedFile} unmatchedFiles - object containing unmatched file paths
 * @returns {Promise<Runner>}
 * @private
 */


var handleUnmatchedFiles = function handleUnmatchedFiles(mocha, unmatchedFiles) {
  if (unmatchedFiles.length === 0) {
    return;
  }

  unmatchedFiles.forEach(function (_ref2) {
    var pattern = _ref2.pattern,
        absolutePath = _ref2.absolutePath;
    console.error(ansi.yellow("Warning: Cannot find any files matching pattern \"".concat(pattern, "\" at the absolute path \"").concat(absolutePath, "\"")));
  });
  console.log('No test file(s) found with the given pattern, exiting with code 1');
  return mocha.run(exitMocha(1));
};
/**
 * Collect and load test files, then run mocha instance.
 * @param {Mocha} mocha - Mocha instance
 * @param {Options} [opts] - Command line options
 * @param {boolean} [opts.exit] - Whether or not to force-exit after tests are complete
 * @param {Object} fileCollectParams - Parameters that control test
 *   file collection. See `lib/cli/collect-files.js`.
 * @returns {Promise<Runner>}
 * @private
 */


var singleRun = function singleRun(mocha, _ref3, fileCollectParams) {
  var exit, fileCollectionObj;
  return regeneratorRuntime.async(function singleRun$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          exit = _ref3.exit;
          fileCollectionObj = collectFiles(fileCollectParams);

          if (!(fileCollectionObj.unmatchedFiles.length > 0)) {
            _context2.next = 4;
            break;
          }

          return _context2.abrupt("return", handleUnmatchedFiles(mocha, fileCollectionObj.unmatchedFiles));

        case 4:
          debug('single run with %d file(s)', fileCollectionObj.files.length);
          mocha.files = fileCollectionObj.files; // handles ESM modules

          _context2.next = 8;
          return regeneratorRuntime.awrap(mocha.loadFilesAsync());

        case 8:
          return _context2.abrupt("return", mocha.run(exit ? exitMocha : exitMochaLater));

        case 9:
        case "end":
          return _context2.stop();
      }
    }
  });
};
/**
 * Collect files and run tests (using `BufferedRunner`).
 *
 * This is `async` for consistency.
 *
 * @param {Mocha} mocha - Mocha instance
 * @param {Options} options - Command line options
 * @param {Object} fileCollectParams - Parameters that control test
 *   file collection. See `lib/cli/collect-files.js`.
 * @returns {Promise<BufferedRunner>}
 * @ignore
 * @private
 */


var parallelRun = function parallelRun(mocha, options, fileCollectParams) {
  var fileCollectionObj;
  return regeneratorRuntime.async(function parallelRun$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          fileCollectionObj = collectFiles(fileCollectParams);

          if (!(fileCollectionObj.unmatchedFiles.length > 0)) {
            _context3.next = 3;
            break;
          }

          return _context3.abrupt("return", handleUnmatchedFiles(mocha, fileCollectionObj.unmatchedFiles));

        case 3:
          debug('executing %d test file(s) in parallel mode', fileCollectionObj.files.length);
          mocha.files = fileCollectionObj.files; // note that we DO NOT load any files here; this is handled by the worker

          return _context3.abrupt("return", mocha.run(options.exit ? exitMocha : exitMochaLater));

        case 6:
        case "end":
          return _context3.stop();
      }
    }
  });
};
/**
 * Actually run tests.  Delegates to one of four different functions:
 * - `singleRun`: run tests in serial & exit
 * - `watchRun`: run tests in serial, rerunning as files change
 * - `parallelRun`: run tests in parallel & exit
 * - `watchParallelRun`: run tests in parallel, rerunning as files change
 * @param {Mocha} mocha - Mocha instance
 * @param {Options} opts - Command line options
 * @private
 * @returns {Promise<Runner>}
 */


exports.runMocha = function _callee2(mocha, options) {
  var _options$watch, watch, _options$extension, extension, _options$ignore, ignore, _options$file, file, _options$parallel, parallel, _options$recursive, recursive, _options$sort, sort, _options$spec, spec, fileCollectParams, run;

  return regeneratorRuntime.async(function _callee2$(_context4) {
    while (1) {
      switch (_context4.prev = _context4.next) {
        case 0:
          _options$watch = options.watch, watch = _options$watch === void 0 ? false : _options$watch, _options$extension = options.extension, extension = _options$extension === void 0 ? [] : _options$extension, _options$ignore = options.ignore, ignore = _options$ignore === void 0 ? [] : _options$ignore, _options$file = options.file, file = _options$file === void 0 ? [] : _options$file, _options$parallel = options.parallel, parallel = _options$parallel === void 0 ? false : _options$parallel, _options$recursive = options.recursive, recursive = _options$recursive === void 0 ? false : _options$recursive, _options$sort = options.sort, sort = _options$sort === void 0 ? false : _options$sort, _options$spec = options.spec, spec = _options$spec === void 0 ? [] : _options$spec;
          fileCollectParams = {
            ignore: ignore,
            extension: extension,
            file: file,
            recursive: recursive,
            sort: sort,
            spec: spec
          };

          if (watch) {
            run = parallel ? watchParallelRun : watchRun;
          } else {
            run = parallel ? parallelRun : singleRun;
          }

          return _context4.abrupt("return", run(mocha, options, fileCollectParams));

        case 4:
        case "end":
          return _context4.stop();
      }
    }
  });
};
/**
 * Used for `--reporter` and `--ui`.  Ensures there's only one, and asserts that
 * it actually exists. This must be run _after_ requires are processed (see
 * {@link handleRequires}), as it'll prevent interfaces from loading otherwise.
 * @param {Object} opts - Options object
 * @param {"reporter"|"ui"} pluginType - Type of plugin.
 * @param {Object} [map] - Used as a cache of sorts;
 * `Mocha.reporters` where each key corresponds to a reporter name,
 * `Mocha.interfaces` where each key corresponds to an interface name.
 * @private
 */


exports.validateLegacyPlugin = function (opts, pluginType) {
  var map = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  /**
   * This should be a unique identifier; either a string (present in `map`),
   * or a resolvable (via `require.resolve`) module ID/path.
   * @type {string}
   */
  var pluginId = opts[pluginType];

  if (Array.isArray(pluginId)) {
    throw createInvalidLegacyPluginError("\"--".concat(pluginType, "\" can only be specified once"), pluginType);
  }

  var createUnknownError = function createUnknownError(err) {
    return createInvalidLegacyPluginError(format('Could not load %s "%s":\n\n %O', pluginType, pluginId, err), pluginType, pluginId);
  }; // if this exists, then it's already loaded, so nothing more to do.


  if (!map[pluginId]) {
    var foundId;

    try {
      foundId = require.resolve(pluginId);
      map[pluginId] = require(foundId);
    } catch (err) {
      if (foundId) throw createUnknownError(err); // Try to load reporters from a cwd-relative path

      try {
        map[pluginId] = require(path.resolve(pluginId));
      } catch (e) {
        throw createUnknownError(e);
      }
    }
  }
};