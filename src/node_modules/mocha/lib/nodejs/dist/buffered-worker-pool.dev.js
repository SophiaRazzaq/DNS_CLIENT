/**
 * A wrapper around a third-party child process worker pool implementation.
 * Used by {@link module:buffered-runner}.
 * @private
 * @module buffered-worker-pool
 */
'use strict';

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var serializeJavascript = require('serialize-javascript');

var workerpool = require('workerpool');

var _require = require('./serializer'),
    deserialize = _require.deserialize;

var debug = require('debug')('mocha:parallel:buffered-worker-pool');

var _require2 = require('../errors'),
    createInvalidArgumentTypeError = _require2.createInvalidArgumentTypeError;

var WORKER_PATH = require.resolve('./worker.js');
/**
 * A mapping of Mocha `Options` objects to serialized values.
 *
 * This is helpful because we tend to same the same options over and over
 * over IPC.
 * @type {WeakMap<Options,string>}
 */


var optionsCache = new WeakMap();
/**
 * These options are passed into the [workerpool](https://npm.im/workerpool) module.
 * @type {Partial<WorkerPoolOptions>}
 */

var WORKER_POOL_DEFAULT_OPTS = {
  // use child processes, not worker threads!
  workerType: 'process',
  // ensure the same flags sent to `node` for this `mocha` invocation are passed
  // along to children
  forkOpts: {
    execArgv: process.execArgv
  },
  maxWorkers: workerpool.cpus - 1
};
/**
 * A wrapper around a third-party worker pool implementation.
 * @private
 */

var BufferedWorkerPool =
/*#__PURE__*/
function () {
  /**
   * Creates an underlying worker pool instance; determines max worker count
   * @param {Partial<WorkerPoolOptions>} [opts] - Options
   */
  function BufferedWorkerPool() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, BufferedWorkerPool);

    var maxWorkers = Math.max(1, typeof opts.maxWorkers === 'undefined' ? WORKER_POOL_DEFAULT_OPTS.maxWorkers : opts.maxWorkers);
    /* istanbul ignore next */

    if (workerpool.cpus < 2) {
      // TODO: decide whether we should warn
      debug('not enough CPU cores available to run multiple jobs; avoid --parallel on this machine');
    } else if (maxWorkers >= workerpool.cpus) {
      // TODO: decide whether we should warn
      debug('%d concurrent job(s) requested, but only %d core(s) available', maxWorkers, workerpool.cpus);
    }
    /* istanbul ignore next */


    debug('run(): starting worker pool of max size %d, using node args: %s', maxWorkers, process.execArgv.join(' '));
    var counter = 0;

    var onCreateWorker = function onCreateWorker(_ref) {
      var forkOpts = _ref.forkOpts;
      return {
        forkOpts: _objectSpread({}, forkOpts, {
          // adds an incremental id to all workers, which can be useful to allocate resources for each process
          env: _objectSpread({}, process.env, {
            MOCHA_WORKER_ID: counter++
          })
        })
      };
    };

    this.options = _objectSpread({}, WORKER_POOL_DEFAULT_OPTS, {}, opts, {
      maxWorkers: maxWorkers,
      onCreateWorker: onCreateWorker
    });
    this._pool = workerpool.pool(WORKER_PATH, this.options);
  }
  /**
   * Terminates all workers in the pool.
   * @param {boolean} [force] - Whether to force-kill workers. By default, lets workers finish their current task before termination.
   * @private
   * @returns {Promise<void>}
   */


  _createClass(BufferedWorkerPool, [{
    key: "terminate",
    value: function terminate() {
      var force,
          _args = arguments;
      return regeneratorRuntime.async(function terminate$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              force = _args.length > 0 && _args[0] !== undefined ? _args[0] : false;

              /* istanbul ignore next */
              debug('terminate(): terminating with force = %s', force);
              return _context.abrupt("return", this._pool.terminate(force));

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
    /**
     * Adds a test file run to the worker pool queue for execution by a worker process.
     *
     * Handles serialization/deserialization.
     *
     * @param {string} filepath - Filepath of test
     * @param {Options} [options] - Options for Mocha instance
     * @private
     * @returns {Promise<SerializedWorkerResult>}
     */

  }, {
    key: "run",
    value: function run(filepath) {
      var options,
          serializedOptions,
          result,
          _args2 = arguments;
      return regeneratorRuntime.async(function run$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};

              if (!(!filepath || typeof filepath !== 'string')) {
                _context2.next = 3;
                break;
              }

              throw createInvalidArgumentTypeError('Expected a non-empty filepath', 'filepath', 'string');

            case 3:
              serializedOptions = BufferedWorkerPool.serializeOptions(options);
              _context2.next = 6;
              return regeneratorRuntime.awrap(this._pool.exec('run', [filepath, serializedOptions]));

            case 6:
              result = _context2.sent;
              return _context2.abrupt("return", deserialize(result));

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
    /**
     * Returns stats about the state of the worker processes in the pool.
     *
     * Used for debugging.
     *
     * @private
     */

  }, {
    key: "stats",
    value: function stats() {
      return this._pool.stats();
    }
    /**
     * Instantiates a {@link WorkerPool}.
     * @private
     */

  }], [{
    key: "create",
    value: function create() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _construct(BufferedWorkerPool, args);
    }
    /**
     * Given Mocha options object `opts`, serialize into a format suitable for
     * transmission over IPC.
     *
     * @param {Options} [opts] - Mocha options
     * @private
     * @returns {string} Serialized options
     */

  }, {
    key: "serializeOptions",
    value: function serializeOptions() {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (!optionsCache.has(opts)) {
        var serialized = serializeJavascript(opts, {
          unsafe: true,
          // this means we don't care about XSS
          ignoreFunction: true // do not serialize functions

        });
        optionsCache.set(opts, serialized);
        /* istanbul ignore next */

        debug('serializeOptions(): serialized options %O to: %s', opts, serialized);
      }

      return optionsCache.get(opts);
    }
    /**
     * Resets internal cache of serialized options objects.
     *
     * For testing/debugging
     * @private
     */

  }, {
    key: "resetOptionsCache",
    value: function resetOptionsCache() {
      optionsCache = new WeakMap();
    }
  }]);

  return BufferedWorkerPool;
}();

exports.BufferedWorkerPool = BufferedWorkerPool;