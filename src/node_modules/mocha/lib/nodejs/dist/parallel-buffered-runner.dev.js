/**
 * A test Runner that uses a {@link module:buffered-worker-pool}.
 * @module parallel-buffered-runner
 * @private
 */
'use strict';

var _createMap;

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Runner = require('../runner');

var _Runner$constants = Runner.constants,
    EVENT_RUN_BEGIN = _Runner$constants.EVENT_RUN_BEGIN,
    EVENT_RUN_END = _Runner$constants.EVENT_RUN_END;

var debug = require('debug')('mocha:parallel:parallel-buffered-runner');

var _require = require('./buffered-worker-pool'),
    BufferedWorkerPool = _require.BufferedWorkerPool;

var _global = global,
    setInterval = _global.setInterval,
    clearInterval = _global.clearInterval;

var _require2 = require('../utils'),
    createMap = _require2.createMap,
    constants = _require2.constants;

var MOCHA_ID_PROP_NAME = constants.MOCHA_ID_PROP_NAME;

var _require3 = require('../errors'),
    createFatalError = _require3.createFatalError;

var DEFAULT_WORKER_REPORTER = require.resolve('./reporters/parallel-buffered');
/**
 * List of options to _not_ serialize for transmission to workers
 */


var DENY_OPTIONS = ['globalSetup', 'globalTeardown', 'parallel', 'p', 'jobs', 'j'];
/**
 * Outputs a debug statement with worker stats
 * @param {BufferedWorkerPool} pool - Worker pool
 */

/* istanbul ignore next */

var debugStats = function debugStats(pool) {
  var _pool$stats = pool.stats(),
      totalWorkers = _pool$stats.totalWorkers,
      busyWorkers = _pool$stats.busyWorkers,
      idleWorkers = _pool$stats.idleWorkers,
      pendingTasks = _pool$stats.pendingTasks;

  debug('%d/%d busy workers; %d idle; %d tasks queued', busyWorkers, totalWorkers, idleWorkers, pendingTasks);
};
/**
 * The interval at which we will display stats for worker processes in debug mode
 */


var DEBUG_STATS_INTERVAL = 5000;
var ABORTED = 'ABORTED';
var IDLE = 'IDLE';
var ABORTING = 'ABORTING';
var RUNNING = 'RUNNING';
var BAILING = 'BAILING';
var BAILED = 'BAILED';
var COMPLETE = 'COMPLETE';
var states = createMap((_createMap = {}, _defineProperty(_createMap, IDLE, new Set([RUNNING, ABORTING])), _defineProperty(_createMap, RUNNING, new Set([COMPLETE, BAILING, ABORTING])), _defineProperty(_createMap, COMPLETE, new Set()), _defineProperty(_createMap, ABORTED, new Set()), _defineProperty(_createMap, ABORTING, new Set([ABORTED])), _defineProperty(_createMap, BAILING, new Set([BAILED, ABORTING])), _defineProperty(_createMap, BAILED, new Set([COMPLETE, ABORTING])), _createMap));
/**
 * This `Runner` delegates tests runs to worker threads.  Does not execute any
 * {@link Runnable}s by itself!
 * @public
 */

var ParallelBufferedRunner =
/*#__PURE__*/
function (_Runner) {
  _inherits(ParallelBufferedRunner, _Runner);

  function ParallelBufferedRunner() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, ParallelBufferedRunner);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ParallelBufferedRunner)).call.apply(_getPrototypeOf2, [this].concat(args)));
    var state = IDLE;
    Object.defineProperty(_assertThisInitialized(_this), '_state', {
      get: function get() {
        return state;
      },
      set: function set(newState) {
        if (states[state].has(newState)) {
          state = newState;
        } else {
          throw new Error("invalid state transition: ".concat(state, " => ").concat(newState));
        }
      }
    });
    _this._workerReporter = DEFAULT_WORKER_REPORTER;
    _this._linkPartialObjects = false;
    _this._linkedObjectMap = new Map();

    _this.once(Runner.constants.EVENT_RUN_END, function () {
      _this._state = COMPLETE;
    });

    return _this;
  }
  /**
   * Returns a mapping function to enqueue a file in the worker pool and return results of its execution.
   * @param {BufferedWorkerPool} pool - Worker pool
   * @param {Options} options - Mocha options
   * @returns {FileRunner} Mapping function
   * @private
   */


  _createClass(ParallelBufferedRunner, [{
    key: "_createFileRunner",
    value: function _createFileRunner(pool, options) {
      var _this2 = this;

      /**
       * Emits event and sets `BAILING` state, if necessary.
       * @param {Object} event - Event having `eventName`, maybe `data` and maybe `error`
       * @param {number} failureCount - Failure count
       */
      var emitEvent = function emitEvent(event, failureCount) {
        _this2.emit(event.eventName, event.data, event.error);

        if (_this2._state !== BAILING && event.data && event.data._bail && (failureCount || event.error)) {
          debug('run(): nonzero failure count & found bail flag'); // we need to let the events complete for this file, as the worker
          // should run any cleanup hooks

          _this2._state = BAILING;
        }
      };
      /**
       * Given an event, recursively find any objects in its data that have ID's, and create object references to already-seen objects.
       * @param {Object} event - Event having `eventName`, maybe `data` and maybe `error`
       */


      var linkEvent = function linkEvent(event) {
        var stack = [{
          parent: event,
          prop: 'data'
        }];

        var _loop = function _loop() {
          var _stack$pop = stack.pop(),
              parent = _stack$pop.parent,
              prop = _stack$pop.prop;

          var obj = parent[prop];
          var newObj = void 0;

          if (obj && _typeof(obj) === 'object') {
            if (obj[MOCHA_ID_PROP_NAME]) {
              var id = obj[MOCHA_ID_PROP_NAME];
              newObj = _this2._linkedObjectMap.has(id) ? Object.assign(_this2._linkedObjectMap.get(id), obj) : obj;

              _this2._linkedObjectMap.set(id, newObj);

              parent[prop] = newObj;
            } else {
              throw createFatalError('Object missing ID received in event data', obj);
            }
          }

          Object.keys(newObj).forEach(function (key) {
            var value = obj[key];

            if (value && _typeof(value) === 'object' && value[MOCHA_ID_PROP_NAME]) {
              stack.push({
                obj: value,
                parent: newObj,
                prop: key
              });
            }
          });
        };

        while (stack.length) {
          _loop();
        }
      };

      return function _callee(file) {
        var _ref, failureCount, events, event;

        return regeneratorRuntime.async(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                debug('run(): enqueueing test file %s', file);
                _context.prev = 1;
                _context.next = 4;
                return regeneratorRuntime.awrap(pool.run(file, options));

              case 4:
                _ref = _context.sent;
                failureCount = _ref.failureCount;
                events = _ref.events;

                if (!(_this2._state === BAILED)) {
                  _context.next = 9;
                  break;
                }

                return _context.abrupt("return");

              case 9:
                debug('run(): completed run of file %s; %d failures / %d events', file, failureCount, events.length);
                _this2.failures += failureCount; // can this ever be non-numeric?

                event = events.shift();

                if (_this2._linkPartialObjects) {
                  while (event) {
                    linkEvent(event);
                    emitEvent(event, failureCount);
                    event = events.shift();
                  }
                } else {
                  while (event) {
                    emitEvent(event, failureCount);
                    event = events.shift();
                  }
                }

                if (!(_this2._state === BAILING)) {
                  _context.next = 18;
                  break;
                }

                debug('run(): terminating pool due to "bail" flag');
                _this2._state = BAILED;
                _context.next = 18;
                return regeneratorRuntime.awrap(pool.terminate());

              case 18:
                _context.next = 32;
                break;

              case 20:
                _context.prev = 20;
                _context.t0 = _context["catch"](1);

                if (!(_this2._state === BAILED || _this2._state === ABORTING)) {
                  _context.next = 26;
                  break;
                }

                debug('run(): worker pool terminated with intent; skipping file %s', file);
                _context.next = 32;
                break;

              case 26:
                // this is an uncaught exception
                debug('run(): encountered uncaught exception: %O', _context.t0);

                if (!_this2.allowUncaught) {
                  _context.next = 31;
                  break;
                }

                // still have to clean up
                _this2._state = ABORTING;
                _context.next = 31;
                return regeneratorRuntime.awrap(pool.terminate(true));

              case 31:
                throw _context.t0;

              case 32:
                _context.prev = 32;
                debug('run(): done running file %s', file);
                return _context.finish(32);

              case 35:
              case "end":
                return _context.stop();
            }
          }
        }, null, null, [[1, 20, 32, 35]]);
      };
    }
    /**
     * Listen on `Process.SIGINT`; terminate pool if caught.
     * Returns the listener for later call to `process.removeListener()`.
     * @param {BufferedWorkerPool} pool - Worker pool
     * @returns {SigIntListener} Listener
     * @private
     */

  }, {
    key: "_bindSigIntListener",
    value: function _bindSigIntListener(pool) {
      var _this3 = this;

      var sigIntListener = function sigIntListener() {
        return regeneratorRuntime.async(function sigIntListener$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                debug('run(): caught a SIGINT');
                _this3._state = ABORTING;
                _context2.prev = 2;
                debug('run(): force-terminating worker pool');
                _context2.next = 6;
                return regeneratorRuntime.awrap(pool.terminate(true));

              case 6:
                _context2.next = 12;
                break;

              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](2);
                console.error("Error while attempting to force-terminate worker pool: ".concat(_context2.t0));
                process.exitCode = 1;

              case 12:
                _context2.prev = 12;
                process.nextTick(function () {
                  debug('run(): imminent death');
                  _this3._state = ABORTED;
                  process.kill(process.pid, 'SIGINT');
                });
                return _context2.finish(12);

              case 15:
              case "end":
                return _context2.stop();
            }
          }
        }, null, null, [[2, 8, 12, 15]]);
      };

      process.once('SIGINT', sigIntListener);
      return sigIntListener;
    }
    /**
     * Runs Mocha tests by creating a thread pool, then delegating work to the
     * worker threads.
     *
     * Each worker receives one file, and as workers become available, they take a
     * file from the queue and run it. The worker thread execution is treated like
     * an RPC--it returns a `Promise` containing serialized information about the
     * run.  The information is processed as it's received, and emitted to a
     * {@link Reporter}, which is likely listening for these events.
     *
     * @param {Function} callback - Called with an exit code corresponding to
     * number of test failures.
     * @param {Object} [opts] - options
     * @param {string[]} opts.files - Files to run
     * @param {Options} opts.options - command-line options
     */

  }, {
    key: "run",
    value: function run(callback) {
      var _this4 = this;

      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          files = _ref2.files,
          _ref2$options = _ref2.options,
          options = _ref2$options === void 0 ? {} : _ref2$options;

      /**
       * Listener on `Process.SIGINT` which tries to cleanly terminate the worker pool.
       */
      var sigIntListener; // assign the reporter the worker will use, which will be different than the
      // main process' reporter

      options = _objectSpread({}, options, {
        reporter: this._workerReporter
      }); // This function should _not_ return a `Promise`; its parent (`Runner#run`)
      // returns this instance, so this should do the same. However, we want to make
      // use of `async`/`await`, so we use this IIFE.

      (function _callee2() {
        var debugInterval, pool, results;
        return regeneratorRuntime.async(function _callee2$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.prev = 0;
                pool = BufferedWorkerPool.create({
                  maxWorkers: options.jobs
                });
                sigIntListener = _this4._bindSigIntListener(pool);
                /* istanbul ignore next */

                debugInterval = setInterval(function () {
                  return debugStats(pool);
                }, DEBUG_STATS_INTERVAL).unref(); // this is set for uncaught exception handling in `Runner#uncaught`
                // TODO: `Runner` should be using a state machine instead.

                _this4.started = true;
                _this4._state = RUNNING;

                _this4.emit(EVENT_RUN_BEGIN);

                options = _objectSpread({}, options);
                DENY_OPTIONS.forEach(function (opt) {
                  delete options[opt];
                });
                _context3.next = 11;
                return regeneratorRuntime.awrap(Promise.allSettled(files.map(_this4._createFileRunner(pool, options))));

              case 11:
                results = _context3.sent;
                _context3.next = 14;
                return regeneratorRuntime.awrap(pool.terminate());

              case 14:
                results.filter(function (_ref3) {
                  var status = _ref3.status;
                  return status === 'rejected';
                }).forEach(function (_ref4) {
                  var reason = _ref4.reason;

                  if (_this4.allowUncaught) {
                    // yep, just the first one.
                    throw reason;
                  } // "rejected" will correspond to uncaught exceptions.
                  // unlike the serial runner, the parallel runner can always recover.


                  _this4.uncaught(reason);
                });

                if (!(_this4._state === ABORTING)) {
                  _context3.next = 17;
                  break;
                }

                return _context3.abrupt("return");

              case 17:
                _this4.emit(EVENT_RUN_END);

                debug('run(): completing with failure count %d', _this4.failures);
                callback(_this4.failures);
                _context3.next = 25;
                break;

              case 22:
                _context3.prev = 22;
                _context3.t0 = _context3["catch"](0);
                // this `nextTick` takes us out of the `Promise` scope, so the
                // exception will not be caught and returned as a rejected `Promise`,
                // which would lead to an `unhandledRejection` event.
                process.nextTick(function () {
                  debug('run(): re-throwing uncaught exception');
                  throw _context3.t0;
                });

              case 25:
                _context3.prev = 25;
                clearInterval(debugInterval);
                process.removeListener('SIGINT', sigIntListener);
                return _context3.finish(25);

              case 29:
              case "end":
                return _context3.stop();
            }
          }
        }, null, null, [[0, 22, 25, 29]]);
      })();

      return this;
    }
    /**
     * Toggle partial object linking behavior; used for building object references from
     * unique ID's.
     * @param {boolean} [value] - If `true`, enable partial object linking, otherwise disable
     * @returns {Runner}
     * @chainable
     * @public
     * @example
     * // this reporter needs proper object references when run in parallel mode
     * class MyReporter() {
     *   constructor(runner) {
     *     this.runner.linkPartialObjects(true)
     *       .on(EVENT_SUITE_BEGIN, suite => {
               // this Suite may be the same object...
    *       })
    *       .on(EVENT_TEST_BEGIN, test => {
    *         // ...as the `test.parent` property
    *       });
    *   }
    * }
    */

  }, {
    key: "linkPartialObjects",
    value: function linkPartialObjects(value) {
      this._linkPartialObjects = Boolean(value);
      return _get(_getPrototypeOf(ParallelBufferedRunner.prototype), "linkPartialObjects", this).call(this, value);
    }
    /**
     * If this class is the `Runner` in use, then this is going to return `true`.
     *
     * For use by reporters.
     * @returns {true}
     * @public
     */

  }, {
    key: "isParallelMode",
    value: function isParallelMode() {
      return true;
    }
    /**
     * Configures an alternate reporter for worker processes to use. Subclasses
     * using worker processes should implement this.
     * @public
     * @param {string} path - Absolute path to alternate reporter for worker processes to use
     * @returns {Runner}
     * @throws When in serial mode
     * @chainable
     */

  }, {
    key: "workerReporter",
    value: function workerReporter(reporter) {
      this._workerReporter = reporter;
      return this;
    }
  }]);

  return ParallelBufferedRunner;
}(Runner);

module.exports = ParallelBufferedRunner;
/**
 * Listener function intended to be bound to `Process.SIGINT` event
 * @private
 * @callback SigIntListener
 * @returns {Promise<void>}
 */

/**
 * A function accepting a test file path and returning the results of a test run
 * @private
 * @callback FileRunner
 * @param {string} filename - File to run
 * @returns {Promise<SerializedWorkerResult>}
 */