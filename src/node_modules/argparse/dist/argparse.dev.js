// Port of python's argparse module, version 3.9.0:
// https://github.com/python/cpython/blob/v3.9.0rc1/Lib/argparse.py
'use strict'; // Copyright (C) 2010-2020 Python Software Foundation.
// Copyright (C) 2020 argparse.js authors

/*
 * Command-line parsing library
 *
 * This module is an optparse-inspired command-line parsing library that:
 *
 *     - handles both optional and positional arguments
 *     - produces highly informative usage messages
 *     - supports parsers that dispatch to sub-parsers
 *
 * The following is a simple usage example that sums integers from the
 * command-line and writes the result to a file::
 *
 *     parser = argparse.ArgumentParser(
 *         description='sum the integers at the command line')
 *     parser.add_argument(
 *         'integers', metavar='int', nargs='+', type=int,
 *         help='an integer to be summed')
 *     parser.add_argument(
 *         '--log', default=sys.stdout, type=argparse.FileType('w'),
 *         help='the file where the sum should be written')
 *     args = parser.parse_args()
 *     args.log.write('%s' % sum(args.integers))
 *     args.log.close()
 *
 * The module contains the following public classes:
 *
 *     - ArgumentParser -- The main entry point for command-line parsing. As the
 *         example above shows, the add_argument() method is used to populate
 *         the parser with actions for optional and positional arguments. Then
 *         the parse_args() method is invoked to convert the args at the
 *         command-line into an object with attributes.
 *
 *     - ArgumentError -- The exception raised by ArgumentParser objects when
 *         there are errors with the parser's actions. Errors raised while
 *         parsing the command-line are caught by ArgumentParser and emitted
 *         as command-line messages.
 *
 *     - FileType -- A factory for defining types of files to be created. As the
 *         example above shows, instances of FileType are typically passed as
 *         the type= argument of add_argument() calls.
 *
 *     - Action -- The base class for parser actions. Typically actions are
 *         selected by passing strings like 'store_true' or 'append_const' to
 *         the action= argument of add_argument(). However, for greater
 *         customization of ArgumentParser actions, subclasses of Action may
 *         be defined and passed as the action= argument.
 *
 *     - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,
 *         ArgumentDefaultsHelpFormatter -- Formatter classes which
 *         may be passed as the formatter_class= argument to the
 *         ArgumentParser constructor. HelpFormatter is the default,
 *         RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser
 *         not to change the formatting for help text, and
 *         ArgumentDefaultsHelpFormatter adds information about argument defaults
 *         to the help.
 *
 * All other classes in this module are considered implementation details.
 * (Also note that HelpFormatter and RawDescriptionHelpFormatter are only
 * considered public as object names -- the API of the formatter objects is
 * still considered an implementation detail.)
 */

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var SUPPRESS = '==SUPPRESS==';
var OPTIONAL = '?';
var ZERO_OR_MORE = '*';
var ONE_OR_MORE = '+';
var PARSER = 'A...';
var REMAINDER = '...';
var _UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'; // ==================================
// Utility functions used for porting
// ==================================

var assert = require('assert');

var util = require('util');

var fs = require('fs');

var sub = require('./lib/sub');

var path = require('path');

var repr = util.inspect;

function get_argv() {
  // omit first argument (which is assumed to be interpreter - `node`, `coffee`, `ts-node`, etc.)
  return process.argv.slice(1);
}

function get_terminal_size() {
  return {
    columns: +process.env.COLUMNS || process.stdout.columns || 80
  };
}

function hasattr(object, name) {
  return Object.prototype.hasOwnProperty.call(object, name);
}

function getattr(object, name, value) {
  return hasattr(object, name) ? object[name] : value;
}

function setattr(object, name, value) {
  object[name] = value;
}

function setdefault(object, name, value) {
  if (!hasattr(object, name)) object[name] = value;
  return object[name];
}

function delattr(object, name) {
  delete object[name];
}

function range(from, to) {
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

  // range(10) is equivalent to range(0, 10)
  if (arguments.length === 1) {
    var _ref = [from, 0];
    to = _ref[0];
    from = _ref[1];
  }

  if (typeof from !== 'number' || typeof to !== 'number' || typeof step !== 'number') {
    throw new TypeError('argument cannot be interpreted as an integer');
  }

  if (step === 0) throw new TypeError('range() arg 3 must not be zero');
  var result = [];

  if (step > 0) {
    for (var i = from; i < to; i += step) {
      result.push(i);
    }
  } else {
    for (var _i = from; _i > to; _i += step) {
      result.push(_i);
    }
  }

  return result;
}

function splitlines(str) {
  var keepends = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var result;

  if (!keepends) {
    result = str.split(/\r\n|[\n\r\v\f\x1c\x1d\x1e\x85\u2028\u2029]/);
  } else {
    result = [];
    var parts = str.split(/(\r\n|[\n\r\v\f\x1c\x1d\x1e\x85\u2028\u2029])/);

    for (var i = 0; i < parts.length; i += 2) {
      result.push(parts[i] + (i + 1 < parts.length ? parts[i + 1] : ''));
    }
  }

  if (!result[result.length - 1]) result.pop();
  return result;
}

function _string_lstrip(string, prefix_chars) {
  var idx = 0;

  while (idx < string.length && prefix_chars.includes(string[idx])) {
    idx++;
  }

  return idx ? string.slice(idx) : string;
}

function _string_split(string, sep, maxsplit) {
  var result = string.split(sep);

  if (result.length > maxsplit) {
    result = result.slice(0, maxsplit).concat([result.slice(maxsplit).join(sep)]);
  }

  return result;
}

function _array_equal(array1, array2) {
  if (array1.length !== array2.length) return false;

  for (var i = 0; i < array1.length; i++) {
    if (array1[i] !== array2[i]) return false;
  }

  return true;
}

function _array_remove(array, item) {
  var idx = array.indexOf(item);
  if (idx === -1) throw new TypeError(sub('%r not in list', item));
  array.splice(idx, 1);
} // normalize choices to array;
// this isn't required in python because `in` and `map` operators work with anything,
// but in js dealing with multiple types here is too clunky


function _choices_to_array(choices) {
  if (choices === undefined) {
    return [];
  } else if (Array.isArray(choices)) {
    return choices;
  } else if (choices !== null && typeof choices[Symbol.iterator] === 'function') {
    return Array.from(choices);
  } else if (_typeof(choices) === 'object' && choices !== null) {
    return Object.keys(choices);
  } else {
    throw new Error(sub('invalid choices value: %r', choices));
  }
} // decorator that allows a class to be called without new


function _callable(cls) {
  var result = _defineProperty({}, cls.name, function _target() {
    var this_class = (this instanceof _target ? this.constructor : void 0) === result || !(this instanceof _target ? this.constructor : void 0);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return Reflect.construct(cls, args, this_class ? cls : this instanceof _target ? this.constructor : void 0);
  });

  result[cls.name].prototype = cls.prototype; // fix default tag for toString, e.g. [object Action] instead of [object Object]

  cls.prototype[Symbol.toStringTag] = cls.name;
  return result[cls.name];
}

function _alias(object, from, to) {
  try {
    var name = object.constructor.name;
    Object.defineProperty(object, from, {
      value: util.deprecate(object[to], sub('%s.%s() is renamed to %s.%s()', name, from, name, to)),
      enumerable: false
    });
  } catch (_unused) {}
} // decorator that allows snake_case class methods to be called with camelCase and vice versa


function _camelcase_alias(_class) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.getOwnPropertyNames(_class.prototype)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var name = _step.value;
      var camelcase = name.replace(/\w_[a-z]/g, function (s) {
        return s[0] + s[2].toUpperCase();
      });
      if (camelcase !== name) _alias(_class.prototype, camelcase, name);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return _class;
}

function _to_legacy_name(key) {
  key = key.replace(/\w_[a-z]/g, function (s) {
    return s[0] + s[2].toUpperCase();
  });
  if (key === 'default') key = 'defaultValue';
  if (key === 'const') key = 'constant';
  return key;
}

function _to_new_name(key) {
  if (key === 'defaultValue') key = 'default';
  if (key === 'constant') key = 'const';
  key = key.replace(/[A-Z]/g, function (c) {
    return '_' + c.toLowerCase();
  });
  return key;
} // parse options


var no_default = Symbol('no_default_value');

function _parse_opts(args, descriptor) {
  function get_name() {
    var stack = new Error().stack.split('\n').map(function (x) {
      return x.match(/^    at (.*) \(.*\)$/);
    }).filter(Boolean).map(function (m) {
      return m[1];
    }).map(function (fn) {
      return fn.match(/[^ .]*$/)[0];
    });
    if (stack.length && stack[0] === get_name.name) stack.shift();
    if (stack.length && stack[0] === _parse_opts.name) stack.shift();
    return stack.length ? stack[0] : '';
  }

  args = Array.from(args);
  var kwargs = {};
  var result = [];
  var last_opt = args.length && args[args.length - 1];

  if (_typeof(last_opt) === 'object' && last_opt !== null && !Array.isArray(last_opt) && (!last_opt.constructor || last_opt.constructor.name === 'Object')) {
    kwargs = Object.assign({}, args.pop());
  } // LEGACY (v1 compatibility): camelcase


  var renames = [];

  for (var _i2 = 0, _Object$keys = Object.keys(descriptor); _i2 < _Object$keys.length; _i2++) {
    var key = _Object$keys[_i2];

    var old_name = _to_legacy_name(key);

    if (old_name !== key && old_name in kwargs) {
      if (key in kwargs) {// default and defaultValue specified at the same time, happens often in old tests
        //throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), key))
      } else {
        kwargs[key] = kwargs[old_name];
      }

      renames.push([old_name, key]);
      delete kwargs[old_name];
    }
  }

  if (renames.length) {
    var name = get_name();
    deprecate('camelcase_' + name, sub('%s(): following options are renamed: %s', name, renames.map(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
          a = _ref3[0],
          b = _ref3[1];

      return sub('%r -> %r', a, b);
    })));
  } // end


  var missing_positionals = [];
  var positional_count = args.length;

  for (var _i3 = 0, _Object$entries = Object.entries(descriptor); _i3 < _Object$entries.length; _i3++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2),
        _key2 = _Object$entries$_i[0],
        def = _Object$entries$_i[1];

    if (_key2[0] === '*') {
      if (_key2.length > 0 && _key2[1] === '*') {
        // LEGACY (v1 compatibility): camelcase
        var _renames = [];

        for (var _i4 = 0, _Object$keys2 = Object.keys(kwargs); _i4 < _Object$keys2.length; _i4++) {
          var _key3 = _Object$keys2[_i4];

          var new_name = _to_new_name(_key3);

          if (new_name !== _key3 && _key3 in kwargs) {
            if (new_name in kwargs) {// default and defaultValue specified at the same time, happens often in old tests
              //throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), new_name))
            } else {
              kwargs[new_name] = kwargs[_key3];
            }

            _renames.push([_key3, new_name]);

            delete kwargs[_key3];
          }
        }

        if (_renames.length) {
          var _name = get_name();

          deprecate('camelcase_' + _name, sub('%s(): following options are renamed: %s', _name, _renames.map(function (_ref8) {
            var _ref9 = _slicedToArray(_ref8, 2),
                a = _ref9[0],
                b = _ref9[1];

            return sub('%r -> %r', a, b);
          })));
        } // end


        result.push(kwargs);
        kwargs = {};
      } else {
        result.push(args);
        args = [];
      }
    } else if (_key2 in kwargs && args.length > 0) {
      throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), _key2));
    } else if (_key2 in kwargs) {
      result.push(kwargs[_key2]);
      delete kwargs[_key2];
    } else if (args.length > 0) {
      result.push(args.shift());
    } else if (def !== no_default) {
      result.push(def);
    } else {
      missing_positionals.push(_key2);
    }
  }

  if (Object.keys(kwargs).length) {
    throw new TypeError(sub('%s() got an unexpected keyword argument %r', get_name(), Object.keys(kwargs)[0]));
  }

  if (args.length) {
    var from = Object.entries(descriptor).filter(function (_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
          k = _ref5[0],
          v = _ref5[1];

      return k[0] !== '*' && v !== no_default;
    }).length;
    var to = Object.entries(descriptor).filter(function (_ref6) {
      var _ref7 = _slicedToArray(_ref6, 1),
          k = _ref7[0];

      return k[0] !== '*';
    }).length;
    throw new TypeError(sub('%s() takes %s positional argument%s but %s %s given', get_name(), from === to ? sub('from %s to %s', from, to) : to, from === to && to === 1 ? '' : 's', positional_count, positional_count === 1 ? 'was' : 'were'));
  }

  if (missing_positionals.length) {
    var strs = missing_positionals.map(repr);
    if (strs.length > 1) strs[strs.length - 1] = 'and ' + strs[strs.length - 1];
    var str_joined = strs.join(strs.length === 2 ? '' : ', ');
    throw new TypeError(sub('%s() missing %i required positional argument%s: %s', get_name(), strs.length, strs.length === 1 ? '' : 's', str_joined));
  }

  return result;
}

var _deprecations = {};

function deprecate(id, string) {
  _deprecations[id] = _deprecations[id] || util.deprecate(function () {}, string);

  _deprecations[id]();
} // =============================
// Utility functions and classes
// =============================


function _AttributeHolder() {
  var cls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object;

  /*
   *  Abstract base class that provides __repr__.
   *
   *  The __repr__ method returns a string in the format::
   *      ClassName(attr=name, attr=name, ...)
   *  The attributes are determined either by a class-level attribute,
   *  '_kwarg_names', or by inspecting the instance __dict__.
   */
  return (
    /*#__PURE__*/
    function (_cls) {
      _inherits(_AttributeHolder, _cls);

      function _AttributeHolder() {
        _classCallCheck(this, _AttributeHolder);

        return _possibleConstructorReturn(this, _getPrototypeOf(_AttributeHolder).apply(this, arguments));
      }

      _createClass(_AttributeHolder, [{
        key: util.inspect.custom,
        value: function value() {
          var type_name = this.constructor.name;
          var arg_strings = [];
          var star_args = {};
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = this._get_args()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var arg = _step2.value;
              arg_strings.push(repr(arg));
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = this._get_kwargs()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _step3$value = _slicedToArray(_step3.value, 2),
                  name = _step3$value[0],
                  value = _step3$value[1];

              if (/^[a-z_][a-z0-9_$]*$/i.test(name)) {
                arg_strings.push(sub('%s=%r', name, value));
              } else {
                star_args[name] = value;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                _iterator3["return"]();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          if (Object.keys(star_args).length) {
            arg_strings.push(sub('**%s', repr(star_args)));
          }

          return sub('%s(%s)', type_name, arg_strings.join(', '));
        }
      }, {
        key: "toString",
        value: function toString() {
          return this[util.inspect.custom]();
        }
      }, {
        key: "_get_kwargs",
        value: function _get_kwargs() {
          return Object.entries(this);
        }
      }, {
        key: "_get_args",
        value: function _get_args() {
          return [];
        }
      }]);

      return _AttributeHolder;
    }(cls)
  );
}

function _copy_items(items) {
  if (items === undefined) {
    return [];
  }

  return items.slice(0);
} // ===============
// Formatting Help
// ===============


var HelpFormatter = _camelcase_alias(_callable(
/*#__PURE__*/
function () {
  /*
   *  Formatter for generating usage messages and argument help strings.
   *
   *  Only the name of this class is considered a public API. All the methods
   *  provided by the class are considered an implementation detail.
   */
  function HelpFormatter() {
    _classCallCheck(this, HelpFormatter);

    var _parse_opts2 = _parse_opts(arguments, {
      prog: no_default,
      indent_increment: 2,
      max_help_position: 24,
      width: undefined
    }),
        _parse_opts3 = _slicedToArray(_parse_opts2, 4),
        prog = _parse_opts3[0],
        indent_increment = _parse_opts3[1],
        max_help_position = _parse_opts3[2],
        width = _parse_opts3[3]; // default setting for width


    if (width === undefined) {
      width = get_terminal_size().columns;
      width -= 2;
    }

    this._prog = prog;
    this._indent_increment = indent_increment;
    this._max_help_position = Math.min(max_help_position, Math.max(width - 20, indent_increment * 2));
    this._width = width;
    this._current_indent = 0;
    this._level = 0;
    this._action_max_length = 0;
    this._root_section = this._Section(this, undefined);
    this._current_section = this._root_section;
    this._whitespace_matcher = /[ \t\n\r\f\v]+/g; // equivalent to python /\s+/ with ASCII flag

    this._long_break_matcher = /\n\n\n+/g;
  } // ===============================
  // Section and indentation methods
  // ===============================


  _createClass(HelpFormatter, [{
    key: "_indent",
    value: function _indent() {
      this._current_indent += this._indent_increment;
      this._level += 1;
    }
  }, {
    key: "_dedent",
    value: function _dedent() {
      this._current_indent -= this._indent_increment;
      assert(this._current_indent >= 0, 'Indent decreased below 0.');
      this._level -= 1;
    }
  }, {
    key: "_add_item",
    value: function _add_item(func, args) {
      this._current_section.items.push([func, args]);
    } // ========================
    // Message building methods
    // ========================

  }, {
    key: "start_section",
    value: function start_section(heading) {
      this._indent();

      var section = this._Section(this, this._current_section, heading);

      this._add_item(section.format_help.bind(section), []);

      this._current_section = section;
    }
  }, {
    key: "end_section",
    value: function end_section() {
      this._current_section = this._current_section.parent;

      this._dedent();
    }
  }, {
    key: "add_text",
    value: function add_text(text) {
      if (text !== SUPPRESS && text !== undefined) {
        this._add_item(this._format_text.bind(this), [text]);
      }
    }
  }, {
    key: "add_usage",
    value: function add_usage(usage, actions, groups) {
      var prefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;

      if (usage !== SUPPRESS) {
        var args = [usage, actions, groups, prefix];

        this._add_item(this._format_usage.bind(this), args);
      }
    }
  }, {
    key: "add_argument",
    value: function add_argument(action) {
      if (action.help !== SUPPRESS) {
        // find all invocations
        var invocations = [this._format_action_invocation(action)];
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = this._iter_indented_subactions(action)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var subaction = _step4.value;
            invocations.push(this._format_action_invocation(subaction));
          } // update the maximum item length

        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        var invocation_length = Math.max.apply(Math, _toConsumableArray(invocations.map(function (invocation) {
          return invocation.length;
        })));
        var action_length = invocation_length + this._current_indent;
        this._action_max_length = Math.max(this._action_max_length, action_length); // add the item to the list

        this._add_item(this._format_action.bind(this), [action]);
      }
    }
  }, {
    key: "add_arguments",
    value: function add_arguments(actions) {
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = actions[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var action = _step5.value;
          this.add_argument(action);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    } // =======================
    // Help-formatting methods
    // =======================

  }, {
    key: "format_help",
    value: function format_help() {
      var help = this._root_section.format_help();

      if (help) {
        help = help.replace(this._long_break_matcher, '\n\n');
        help = help.replace(/^\n+|\n+$/g, '') + '\n';
      }

      return help;
    }
  }, {
    key: "_join_parts",
    value: function _join_parts(part_strings) {
      return part_strings.filter(function (part) {
        return part && part !== SUPPRESS;
      }).join('');
    }
  }, {
    key: "_format_usage",
    value: function _format_usage(usage, actions, groups, prefix) {
      if (prefix === undefined) {
        prefix = 'usage: ';
      } // if usage is specified, use that


      if (usage !== undefined) {
        usage = sub(usage, {
          prog: this._prog
        }); // if no optionals or positionals are available, usage is just prog
      } else if (usage === undefined && !actions.length) {
        usage = sub('%(prog)s', {
          prog: this._prog
        }); // if optionals and positionals are available, calculate usage
      } else if (usage === undefined) {
        var prog = sub('%(prog)s', {
          prog: this._prog
        }); // split optionals from positionals

        var optionals = [];
        var positionals = [];
        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = actions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var action = _step6.value;

            if (action.option_strings.length) {
              optionals.push(action);
            } else {
              positionals.push(action);
            }
          } // build full usage string

        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
              _iterator6["return"]();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }

        var action_usage = this._format_actions_usage([].concat(optionals).concat(positionals), groups);

        usage = [prog, action_usage].map(String).join(' '); // wrap the usage parts if it's too long

        var text_width = this._width - this._current_indent;

        if (prefix.length + usage.length > text_width) {
          // break usage into wrappable parts
          var part_regexp = /\(.*?\)+(?=\s|$)|\[.*?\]+(?=\s|$)|\S+/g;

          var opt_usage = this._format_actions_usage(optionals, groups);

          var pos_usage = this._format_actions_usage(positionals, groups);

          var opt_parts = opt_usage.match(part_regexp) || [];
          var pos_parts = pos_usage.match(part_regexp) || [];
          assert(opt_parts.join(' ') === opt_usage);
          assert(pos_parts.join(' ') === pos_usage); // helper for wrapping lines

          var get_lines = function get_lines(parts, indent) {
            var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
            var lines = [];
            var line = [];
            var line_len;

            if (prefix !== undefined) {
              line_len = prefix.length - 1;
            } else {
              line_len = indent.length - 1;
            }

            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
              for (var _iterator7 = parts[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var part = _step7.value;

                if (line_len + 1 + part.length > text_width && line) {
                  lines.push(indent + line.join(' '));
                  line = [];
                  line_len = indent.length - 1;
                }

                line.push(part);
                line_len += part.length + 1;
              }
            } catch (err) {
              _didIteratorError7 = true;
              _iteratorError7 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
                  _iterator7["return"]();
                }
              } finally {
                if (_didIteratorError7) {
                  throw _iteratorError7;
                }
              }
            }

            if (line.length) {
              lines.push(indent + line.join(' '));
            }

            if (prefix !== undefined) {
              lines[0] = lines[0].slice(indent.length);
            }

            return lines;
          };

          var lines; // if prog is short, follow it with optionals or positionals

          if (prefix.length + prog.length <= 0.75 * text_width) {
            var indent = ' '.repeat(prefix.length + prog.length + 1);

            if (opt_parts.length) {
              lines = get_lines([prog].concat(opt_parts), indent, prefix);
              lines = lines.concat(get_lines(pos_parts, indent));
            } else if (pos_parts.length) {
              lines = get_lines([prog].concat(pos_parts), indent, prefix);
            } else {
              lines = [prog];
            } // if prog is long, put it on its own line

          } else {
            var _indent2 = ' '.repeat(prefix.length);

            var parts = [].concat(opt_parts).concat(pos_parts);
            lines = get_lines(parts, _indent2);

            if (lines.length > 1) {
              lines = [];
              lines = lines.concat(get_lines(opt_parts, _indent2));
              lines = lines.concat(get_lines(pos_parts, _indent2));
            }

            lines = [prog].concat(lines);
          } // join lines into usage


          usage = lines.join('\n');
        }
      } // prefix with 'usage:'


      return sub('%s%s\n\n', prefix, usage);
    }
  }, {
    key: "_format_actions_usage",
    value: function _format_actions_usage(actions, groups) {
      // find group indices and identify actions in groups
      var group_actions = new Set();
      var inserts = {};
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = groups[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var group = _step8.value;
          var start = actions.indexOf(group._group_actions[0]);

          if (start === -1) {
            continue;
          } else {
            var end = start + group._group_actions.length;

            if (_array_equal(actions.slice(start, end), group._group_actions)) {
              var _iteratorNormalCompletion10 = true;
              var _didIteratorError10 = false;
              var _iteratorError10 = undefined;

              try {
                for (var _iterator10 = group._group_actions[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                  var action = _step10.value;
                  group_actions.add(action);
                }
              } catch (err) {
                _didIteratorError10 = true;
                _iteratorError10 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
                    _iterator10["return"]();
                  }
                } finally {
                  if (_didIteratorError10) {
                    throw _iteratorError10;
                  }
                }
              }

              if (!group.required) {
                if (start in inserts) {
                  inserts[start] += ' [';
                } else {
                  inserts[start] = '[';
                }

                if (end in inserts) {
                  inserts[end] += ']';
                } else {
                  inserts[end] = ']';
                }
              } else {
                if (start in inserts) {
                  inserts[start] += ' (';
                } else {
                  inserts[start] = '(';
                }

                if (end in inserts) {
                  inserts[end] += ')';
                } else {
                  inserts[end] = ')';
                }
              }

              var _iteratorNormalCompletion11 = true;
              var _didIteratorError11 = false;
              var _iteratorError11 = undefined;

              try {
                for (var _iterator11 = range(start + 1, end)[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                  var i = _step11.value;
                  inserts[i] = '|';
                }
              } catch (err) {
                _didIteratorError11 = true;
                _iteratorError11 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
                    _iterator11["return"]();
                  }
                } finally {
                  if (_didIteratorError11) {
                    throw _iteratorError11;
                  }
                }
              }
            }
          }
        } // collect all actions format strings

      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      var parts = [];

      for (var _i5 = 0, _Object$entries2 = Object.entries(actions); _i5 < _Object$entries2.length; _i5++) {
        var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i5], 2),
            _i6 = _Object$entries2$_i[0],
            _action = _Object$entries2$_i[1];

        // suppressed arguments are marked with None
        // remove | separators for suppressed arguments
        if (_action.help === SUPPRESS) {
          parts.push(undefined);

          if (inserts[+_i6] === '|') {
            delete inserts[+_i6];
          } else if (inserts[+_i6 + 1] === '|') {
            delete inserts[+_i6 + 1];
          } // produce all arg strings

        } else if (!_action.option_strings.length) {
          var default_value = this._get_default_metavar_for_positional(_action);

          var part = this._format_args(_action, default_value); // if it's in a group, strip the outer []


          if (group_actions.has(_action)) {
            if (part[0] === '[' && part[part.length - 1] === ']') {
              part = part.slice(1, -1);
            }
          } // add the action string to the list


          parts.push(part); // produce the first way to invoke the option in brackets
        } else {
          var option_string = _action.option_strings[0];

          var _part = void 0; // if the Optional doesn't take a value, format is:
          //    -s or --long


          if (_action.nargs === 0) {
            _part = _action.format_usage(); // if the Optional takes a value, format is:
            //    -s ARGS or --long ARGS
          } else {
            var _default_value = this._get_default_metavar_for_optional(_action);

            var args_string = this._format_args(_action, _default_value);

            _part = sub('%s %s', option_string, args_string);
          } // make it look optional if it's not required or in a group


          if (!_action.required && !group_actions.has(_action)) {
            _part = sub('[%s]', _part);
          } // add the action string to the list


          parts.push(_part);
        }
      } // insert things at the necessary indices


      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = Object.keys(inserts).map(Number).sort(function (a, b) {
          return b - a;
        })[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var _i7 = _step9.value;
          parts.splice(+_i7, 0, inserts[+_i7]);
        } // join all the action items with spaces

      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
            _iterator9["return"]();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }

      var text = parts.filter(Boolean).join(' '); // clean up separators for mutually exclusive groups

      text = text.replace(/([\[(]) /g, '$1');
      text = text.replace(/ ([\])])/g, '$1');
      text = text.replace(/[\[(] *[\])]/g, '');
      text = text.replace(/\(([^|]*)\)/g, '$1', text);
      text = text.trim(); // return the text

      return text;
    }
  }, {
    key: "_format_text",
    value: function _format_text(text) {
      if (text.includes('%(prog)')) {
        text = sub(text, {
          prog: this._prog
        });
      }

      var text_width = Math.max(this._width - this._current_indent, 11);
      var indent = ' '.repeat(this._current_indent);
      return this._fill_text(text, text_width, indent) + '\n\n';
    }
  }, {
    key: "_format_action",
    value: function _format_action(action) {
      // determine the required width and the entry label
      var help_position = Math.min(this._action_max_length + 2, this._max_help_position);
      var help_width = Math.max(this._width - help_position, 11);
      var action_width = help_position - this._current_indent - 2;

      var action_header = this._format_action_invocation(action);

      var indent_first; // no help; start on same line and add a final newline

      if (!action.help) {
        var tup = [this._current_indent, '', action_header];
        action_header = sub.apply(void 0, ['%*s%s\n'].concat(tup)); // short action name; start on the same line and pad two spaces
      } else if (action_header.length <= action_width) {
        var _tup = [this._current_indent, '', action_width, action_header];
        action_header = sub.apply(void 0, ['%*s%-*s  '].concat(_tup));
        indent_first = 0; // long action name; start on the next line
      } else {
        var _tup2 = [this._current_indent, '', action_header];
        action_header = sub.apply(void 0, ['%*s%s\n'].concat(_tup2));
        indent_first = help_position;
      } // collect the pieces of the action help


      var parts = [action_header]; // if there was help for the action, add lines of help text

      if (action.help) {
        var help_text = this._expand_help(action);

        var help_lines = this._split_lines(help_text, help_width);

        parts.push(sub('%*s%s\n', indent_first, '', help_lines[0]));
        var _iteratorNormalCompletion12 = true;
        var _didIteratorError12 = false;
        var _iteratorError12 = undefined;

        try {
          for (var _iterator12 = help_lines.slice(1)[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
            var line = _step12.value;
            parts.push(sub('%*s%s\n', help_position, '', line));
          } // or add a newline if the description doesn't end with one

        } catch (err) {
          _didIteratorError12 = true;
          _iteratorError12 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
              _iterator12["return"]();
            }
          } finally {
            if (_didIteratorError12) {
              throw _iteratorError12;
            }
          }
        }
      } else if (!action_header.endsWith('\n')) {
        parts.push('\n');
      } // if there are any sub-actions, add their help as well


      var _iteratorNormalCompletion13 = true;
      var _didIteratorError13 = false;
      var _iteratorError13 = undefined;

      try {
        for (var _iterator13 = this._iter_indented_subactions(action)[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
          var subaction = _step13.value;
          parts.push(this._format_action(subaction));
        } // return a single string

      } catch (err) {
        _didIteratorError13 = true;
        _iteratorError13 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
            _iterator13["return"]();
          }
        } finally {
          if (_didIteratorError13) {
            throw _iteratorError13;
          }
        }
      }

      return this._join_parts(parts);
    }
  }, {
    key: "_format_action_invocation",
    value: function _format_action_invocation(action) {
      if (!action.option_strings.length) {
        var default_value = this._get_default_metavar_for_positional(action);

        var metavar = this._metavar_formatter(action, default_value)(1)[0];

        return metavar;
      } else {
        var parts = []; // if the Optional doesn't take a value, format is:
        //    -s, --long

        if (action.nargs === 0) {
          parts = parts.concat(action.option_strings); // if the Optional takes a value, format is:
          //    -s ARGS, --long ARGS
        } else {
          var _default_value2 = this._get_default_metavar_for_optional(action);

          var args_string = this._format_args(action, _default_value2);

          var _iteratorNormalCompletion14 = true;
          var _didIteratorError14 = false;
          var _iteratorError14 = undefined;

          try {
            for (var _iterator14 = action.option_strings[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
              var option_string = _step14.value;
              parts.push(sub('%s %s', option_string, args_string));
            }
          } catch (err) {
            _didIteratorError14 = true;
            _iteratorError14 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
                _iterator14["return"]();
              }
            } finally {
              if (_didIteratorError14) {
                throw _iteratorError14;
              }
            }
          }
        }

        return parts.join(', ');
      }
    }
  }, {
    key: "_metavar_formatter",
    value: function _metavar_formatter(action, default_metavar) {
      var result;

      if (action.metavar !== undefined) {
        result = action.metavar;
      } else if (action.choices !== undefined) {
        var choice_strs = _choices_to_array(action.choices).map(String);

        result = sub('{%s}', choice_strs.join(','));
      } else {
        result = default_metavar;
      }

      function format(tuple_size) {
        if (Array.isArray(result)) {
          return result;
        } else {
          return Array(tuple_size).fill(result);
        }
      }

      return format;
    }
  }, {
    key: "_format_args",
    value: function _format_args(action, default_metavar) {
      var get_metavar = this._metavar_formatter(action, default_metavar);

      var result;

      if (action.nargs === undefined) {
        result = sub.apply(void 0, ['%s'].concat(_toConsumableArray(get_metavar(1))));
      } else if (action.nargs === OPTIONAL) {
        result = sub.apply(void 0, ['[%s]'].concat(_toConsumableArray(get_metavar(1))));
      } else if (action.nargs === ZERO_OR_MORE) {
        var metavar = get_metavar(1);

        if (metavar.length === 2) {
          result = sub.apply(void 0, ['[%s [%s ...]]'].concat(_toConsumableArray(metavar)));
        } else {
          result = sub.apply(void 0, ['[%s ...]'].concat(_toConsumableArray(metavar)));
        }
      } else if (action.nargs === ONE_OR_MORE) {
        result = sub.apply(void 0, ['%s [%s ...]'].concat(_toConsumableArray(get_metavar(2))));
      } else if (action.nargs === REMAINDER) {
        result = '...';
      } else if (action.nargs === PARSER) {
        result = sub.apply(void 0, ['%s ...'].concat(_toConsumableArray(get_metavar(1))));
      } else if (action.nargs === SUPPRESS) {
        result = '';
      } else {
        var formats;

        try {
          formats = range(action.nargs).map(function () {
            return '%s';
          });
        } catch (err) {
          throw new TypeError('invalid nargs value');
        }

        result = sub.apply(void 0, [formats.join(' ')].concat(_toConsumableArray(get_metavar(action.nargs))));
      }

      return result;
    }
  }, {
    key: "_expand_help",
    value: function _expand_help(action) {
      var params = Object.assign({
        prog: this._prog
      }, action);

      for (var _i8 = 0, _Object$keys3 = Object.keys(params); _i8 < _Object$keys3.length; _i8++) {
        var name = _Object$keys3[_i8];

        if (params[name] === SUPPRESS) {
          delete params[name];
        }
      }

      for (var _i9 = 0, _Object$keys4 = Object.keys(params); _i9 < _Object$keys4.length; _i9++) {
        var _name2 = _Object$keys4[_i9];

        if (params[_name2] && params[_name2].name) {
          params[_name2] = params[_name2].name;
        }
      }

      if (params.choices !== undefined) {
        var choices_str = _choices_to_array(params.choices).map(String).join(', ');

        params.choices = choices_str;
      } // LEGACY (v1 compatibility): camelcase


      for (var _i10 = 0, _Object$keys5 = Object.keys(params); _i10 < _Object$keys5.length; _i10++) {
        var key = _Object$keys5[_i10];

        var old_name = _to_legacy_name(key);

        if (old_name !== key) {
          params[old_name] = params[key];
        }
      } // end


      return sub(this._get_help_string(action), params);
    }
  }, {
    key: "_iter_indented_subactions",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function _iter_indented_subactions(action) {
      return regeneratorRuntime.wrap(function _iter_indented_subactions$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(typeof action._get_subactions === 'function')) {
                _context.next = 4;
                break;
              }

              this._indent();

              return _context.delegateYield(action._get_subactions(), "t0", 3);

            case 3:
              this._dedent();

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _iter_indented_subactions, this);
    })
  }, {
    key: "_split_lines",
    value: function _split_lines(text, width) {
      text = text.replace(this._whitespace_matcher, ' ').trim(); // The textwrap module is used only for formatting help.
      // Delay its import for speeding up the common usage of argparse.

      var textwrap = require('./lib/textwrap');

      return textwrap.wrap(text, {
        width: width
      });
    }
  }, {
    key: "_fill_text",
    value: function _fill_text(text, width, indent) {
      text = text.replace(this._whitespace_matcher, ' ').trim();

      var textwrap = require('./lib/textwrap');

      return textwrap.fill(text, {
        width: width,
        initial_indent: indent,
        subsequent_indent: indent
      });
    }
  }, {
    key: "_get_help_string",
    value: function _get_help_string(action) {
      return action.help;
    }
  }, {
    key: "_get_default_metavar_for_optional",
    value: function _get_default_metavar_for_optional(action) {
      return action.dest.toUpperCase();
    }
  }, {
    key: "_get_default_metavar_for_positional",
    value: function _get_default_metavar_for_positional(action) {
      return action.dest;
    }
  }]);

  return HelpFormatter;
}()));

HelpFormatter.prototype._Section = _callable(
/*#__PURE__*/
function () {
  function _Section(formatter, parent) {
    var heading = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

    _classCallCheck(this, _Section);

    this.formatter = formatter;
    this.parent = parent;
    this.heading = heading;
    this.items = [];
  }

  _createClass(_Section, [{
    key: "format_help",
    value: function format_help() {
      // format the indented section
      if (this.parent !== undefined) {
        this.formatter._indent();
      }

      var item_help = this.formatter._join_parts(this.items.map(function (_ref10) {
        var _ref11 = _slicedToArray(_ref10, 2),
            func = _ref11[0],
            args = _ref11[1];

        return func.apply(null, args);
      }));

      if (this.parent !== undefined) {
        this.formatter._dedent();
      } // return nothing if the section was empty


      if (!item_help) {
        return '';
      } // add the heading if the section was non-empty


      var heading;

      if (this.heading !== SUPPRESS && this.heading !== undefined) {
        var current_indent = this.formatter._current_indent;
        heading = sub('%*s%s:\n', current_indent, '', this.heading);
      } else {
        heading = '';
      } // join the section-initial newline, the heading and the help


      return this.formatter._join_parts(['\n', heading, item_help, '\n']);
    }
  }]);

  return _Section;
}());

var RawDescriptionHelpFormatter = _camelcase_alias(_callable(
/*#__PURE__*/
function (_HelpFormatter) {
  _inherits(RawDescriptionHelpFormatter, _HelpFormatter);

  function RawDescriptionHelpFormatter() {
    _classCallCheck(this, RawDescriptionHelpFormatter);

    return _possibleConstructorReturn(this, _getPrototypeOf(RawDescriptionHelpFormatter).apply(this, arguments));
  }

  _createClass(RawDescriptionHelpFormatter, [{
    key: "_fill_text",

    /*
     *  Help message formatter which retains any formatting in descriptions.
     *
     *  Only the name of this class is considered a public API. All the methods
     *  provided by the class are considered an implementation detail.
     */
    value: function _fill_text(text, width, indent) {
      return splitlines(text, true).map(function (line) {
        return indent + line;
      }).join('');
    }
  }]);

  return RawDescriptionHelpFormatter;
}(HelpFormatter)));

var RawTextHelpFormatter = _camelcase_alias(_callable(
/*#__PURE__*/
function (_RawDescriptionHelpFo) {
  _inherits(RawTextHelpFormatter, _RawDescriptionHelpFo);

  function RawTextHelpFormatter() {
    _classCallCheck(this, RawTextHelpFormatter);

    return _possibleConstructorReturn(this, _getPrototypeOf(RawTextHelpFormatter).apply(this, arguments));
  }

  _createClass(RawTextHelpFormatter, [{
    key: "_split_lines",

    /*
     *  Help message formatter which retains formatting of all help text.
     *
     *  Only the name of this class is considered a public API. All the methods
     *  provided by the class are considered an implementation detail.
     */
    value: function _split_lines(text
    /*, width*/
    ) {
      return splitlines(text);
    }
  }]);

  return RawTextHelpFormatter;
}(RawDescriptionHelpFormatter)));

var ArgumentDefaultsHelpFormatter = _camelcase_alias(_callable(
/*#__PURE__*/
function (_HelpFormatter2) {
  _inherits(ArgumentDefaultsHelpFormatter, _HelpFormatter2);

  function ArgumentDefaultsHelpFormatter() {
    _classCallCheck(this, ArgumentDefaultsHelpFormatter);

    return _possibleConstructorReturn(this, _getPrototypeOf(ArgumentDefaultsHelpFormatter).apply(this, arguments));
  }

  _createClass(ArgumentDefaultsHelpFormatter, [{
    key: "_get_help_string",

    /*
     *  Help message formatter which adds default values to argument help.
     *
     *  Only the name of this class is considered a public API. All the methods
     *  provided by the class are considered an implementation detail.
     */
    value: function _get_help_string(action) {
      var help = action.help; // LEGACY (v1 compatibility): additional check for defaultValue needed

      if (!action.help.includes('%(default)') && !action.help.includes('%(defaultValue)')) {
        if (action["default"] !== SUPPRESS) {
          var defaulting_nargs = [OPTIONAL, ZERO_OR_MORE];

          if (action.option_strings.length || defaulting_nargs.includes(action.nargs)) {
            help += ' (default: %(default)s)';
          }
        }
      }

      return help;
    }
  }]);

  return ArgumentDefaultsHelpFormatter;
}(HelpFormatter)));

var MetavarTypeHelpFormatter = _camelcase_alias(_callable(
/*#__PURE__*/
function (_HelpFormatter3) {
  _inherits(MetavarTypeHelpFormatter, _HelpFormatter3);

  function MetavarTypeHelpFormatter() {
    _classCallCheck(this, MetavarTypeHelpFormatter);

    return _possibleConstructorReturn(this, _getPrototypeOf(MetavarTypeHelpFormatter).apply(this, arguments));
  }

  _createClass(MetavarTypeHelpFormatter, [{
    key: "_get_default_metavar_for_optional",

    /*
     *  Help message formatter which uses the argument 'type' as the default
     *  metavar value (instead of the argument 'dest')
     *
     *  Only the name of this class is considered a public API. All the methods
     *  provided by the class are considered an implementation detail.
     */
    value: function _get_default_metavar_for_optional(action) {
      return typeof action.type === 'function' ? action.type.name : action.type;
    }
  }, {
    key: "_get_default_metavar_for_positional",
    value: function _get_default_metavar_for_positional(action) {
      return typeof action.type === 'function' ? action.type.name : action.type;
    }
  }]);

  return MetavarTypeHelpFormatter;
}(HelpFormatter))); // =====================
// Options and Arguments
// =====================


function _get_action_name(argument) {
  if (argument === undefined) {
    return undefined;
  } else if (argument.option_strings.length) {
    return argument.option_strings.join('/');
  } else if (![undefined, SUPPRESS].includes(argument.metavar)) {
    return argument.metavar;
  } else if (![undefined, SUPPRESS].includes(argument.dest)) {
    return argument.dest;
  } else {
    return undefined;
  }
}

var ArgumentError = _callable(
/*#__PURE__*/
function (_Error) {
  _inherits(ArgumentError, _Error);

  /*
   *  An error from creating or using an argument (optional or positional).
   *
   *  The string value of this exception is the message, augmented with
   *  information about the argument that caused it.
   */
  function ArgumentError(argument, message) {
    var _this;

    _classCallCheck(this, ArgumentError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ArgumentError).call(this));
    _this.name = 'ArgumentError';
    _this._argument_name = _get_action_name(argument);
    _this._message = message;
    _this.message = _this.str();
    return _this;
  }

  _createClass(ArgumentError, [{
    key: "str",
    value: function str() {
      var format;

      if (this._argument_name === undefined) {
        format = '%(message)s';
      } else {
        format = 'argument %(argument_name)s: %(message)s';
      }

      return sub(format, {
        message: this._message,
        argument_name: this._argument_name
      });
    }
  }]);

  return ArgumentError;
}(_wrapNativeSuper(Error)));

var ArgumentTypeError = _callable(
/*#__PURE__*/
function (_Error2) {
  _inherits(ArgumentTypeError, _Error2);

  /*
   * An error from trying to convert a command line string to a type.
   */
  function ArgumentTypeError(message) {
    var _this2;

    _classCallCheck(this, ArgumentTypeError);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ArgumentTypeError).call(this, message));
    _this2.name = 'ArgumentTypeError';
    return _this2;
  }

  return ArgumentTypeError;
}(_wrapNativeSuper(Error))); // ==============
// Action classes
// ==============


var Action = _camelcase_alias(_callable(
/*#__PURE__*/
function (_AttributeHolder2) {
  _inherits(Action, _AttributeHolder2);

  /*
   *  Information about how to convert command line strings to Python objects.
   *
   *  Action objects are used by an ArgumentParser to represent the information
   *  needed to parse a single argument from one or more strings from the
   *  command line. The keyword arguments to the Action constructor are also
   *  all attributes of Action instances.
   *
   *  Keyword Arguments:
   *
   *      - option_strings -- A list of command-line option strings which
   *          should be associated with this action.
   *
   *      - dest -- The name of the attribute to hold the created object(s)
   *
   *      - nargs -- The number of command-line arguments that should be
   *          consumed. By default, one argument will be consumed and a single
   *          value will be produced.  Other values include:
   *              - N (an integer) consumes N arguments (and produces a list)
   *              - '?' consumes zero or one arguments
   *              - '*' consumes zero or more arguments (and produces a list)
   *              - '+' consumes one or more arguments (and produces a list)
   *          Note that the difference between the default and nargs=1 is that
   *          with the default, a single value will be produced, while with
   *          nargs=1, a list containing a single value will be produced.
   *
   *      - const -- The value to be produced if the option is specified and the
   *          option uses an action that takes no values.
   *
   *      - default -- The value to be produced if the option is not specified.
   *
   *      - type -- A callable that accepts a single string argument, and
   *          returns the converted value.  The standard Python types str, int,
   *          float, and complex are useful examples of such callables.  If None,
   *          str is used.
   *
   *      - choices -- A container of values that should be allowed. If not None,
   *          after a command-line argument has been converted to the appropriate
   *          type, an exception will be raised if it is not a member of this
   *          collection.
   *
   *      - required -- True if the action must always be specified at the
   *          command line. This is only meaningful for optional command-line
   *          arguments.
   *
   *      - help -- The help string describing the argument.
   *
   *      - metavar -- The name to be used for the option's argument with the
   *          help string. If None, the 'dest' value will be used as the name.
   */
  function Action() {
    var _this3;

    _classCallCheck(this, Action);

    var _parse_opts4 = _parse_opts(arguments, {
      option_strings: no_default,
      dest: no_default,
      nargs: undefined,
      "const": undefined,
      "default": undefined,
      type: undefined,
      choices: undefined,
      required: false,
      help: undefined,
      metavar: undefined
    }),
        _parse_opts5 = _slicedToArray(_parse_opts4, 10),
        option_strings = _parse_opts5[0],
        dest = _parse_opts5[1],
        nargs = _parse_opts5[2],
        const_value = _parse_opts5[3],
        default_value = _parse_opts5[4],
        type = _parse_opts5[5],
        choices = _parse_opts5[6],
        required = _parse_opts5[7],
        help = _parse_opts5[8],
        metavar = _parse_opts5[9]; // when this class is called as a function, redirect it to .call() method of itself


    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Action).call(this, 'return arguments.callee.call.apply(arguments.callee, arguments)'));
    _this3.option_strings = option_strings;
    _this3.dest = dest;
    _this3.nargs = nargs;
    _this3["const"] = const_value;
    _this3["default"] = default_value;
    _this3.type = type;
    _this3.choices = choices;
    _this3.required = required;
    _this3.help = help;
    _this3.metavar = metavar;
    return _this3;
  }

  _createClass(Action, [{
    key: "_get_kwargs",
    value: function _get_kwargs() {
      var _this4 = this;

      var names = ['option_strings', 'dest', 'nargs', 'const', 'default', 'type', 'choices', 'help', 'metavar'];
      return names.map(function (name) {
        return [name, getattr(_this4, name)];
      });
    }
  }, {
    key: "format_usage",
    value: function format_usage() {
      return this.option_strings[0];
    }
  }, {
    key: "call",
    value: function call()
    /*parser, namespace, values, option_string = undefined*/
    {
      throw new Error('.call() not defined');
    }
  }]);

  return Action;
}(_AttributeHolder(Function))));

var BooleanOptionalAction = _camelcase_alias(_callable(
/*#__PURE__*/
function (_Action) {
  _inherits(BooleanOptionalAction, _Action);

  function BooleanOptionalAction() {
    _classCallCheck(this, BooleanOptionalAction);

    var _parse_opts6 = _parse_opts(arguments, {
      option_strings: no_default,
      dest: no_default,
      "default": undefined,
      type: undefined,
      choices: undefined,
      required: false,
      help: undefined,
      metavar: undefined
    }),
        _parse_opts7 = _slicedToArray(_parse_opts6, 8),
        option_strings = _parse_opts7[0],
        dest = _parse_opts7[1],
        default_value = _parse_opts7[2],
        type = _parse_opts7[3],
        choices = _parse_opts7[4],
        required = _parse_opts7[5],
        help = _parse_opts7[6],
        metavar = _parse_opts7[7];

    var _option_strings = [];
    var _iteratorNormalCompletion15 = true;
    var _didIteratorError15 = false;
    var _iteratorError15 = undefined;

    try {
      for (var _iterator15 = option_strings[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
        var option_string = _step15.value;

        _option_strings.push(option_string);

        if (option_string.startsWith('--')) {
          option_string = '--no-' + option_string.slice(2);

          _option_strings.push(option_string);
        }
      }
    } catch (err) {
      _didIteratorError15 = true;
      _iteratorError15 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
          _iterator15["return"]();
        }
      } finally {
        if (_didIteratorError15) {
          throw _iteratorError15;
        }
      }
    }

    if (help !== undefined && default_value !== undefined) {
      help += " (default: ".concat(default_value, ")");
    }

    return _possibleConstructorReturn(this, _getPrototypeOf(BooleanOptionalAction).call(this, {
      option_strings: _option_strings,
      dest: dest,
      nargs: 0,
      "default": default_value,
      type: type,
      choices: choices,
      required: required,
      help: help,
      metavar: metavar
    }));
  }

  _createClass(BooleanOptionalAction, [{
    key: "call",
    value: function call(parser, namespace, values) {
      var option_string = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;

      if (this.option_strings.includes(option_string)) {
        setattr(namespace, this.dest, !option_string.startsWith('--no-'));
      }
    }
  }, {
    key: "format_usage",
    value: function format_usage() {
      return this.option_strings.join(' | ');
    }
  }]);

  return BooleanOptionalAction;
}(Action)));

var _StoreAction = _callable(
/*#__PURE__*/
function (_Action2) {
  _inherits(_StoreAction, _Action2);

  function _StoreAction() {
    _classCallCheck(this, _StoreAction);

    var _parse_opts8 = _parse_opts(arguments, {
      option_strings: no_default,
      dest: no_default,
      nargs: undefined,
      "const": undefined,
      "default": undefined,
      type: undefined,
      choices: undefined,
      required: false,
      help: undefined,
      metavar: undefined
    }),
        _parse_opts9 = _slicedToArray(_parse_opts8, 10),
        option_strings = _parse_opts9[0],
        dest = _parse_opts9[1],
        nargs = _parse_opts9[2],
        const_value = _parse_opts9[3],
        default_value = _parse_opts9[4],
        type = _parse_opts9[5],
        choices = _parse_opts9[6],
        required = _parse_opts9[7],
        help = _parse_opts9[8],
        metavar = _parse_opts9[9];

    if (nargs === 0) {
      throw new TypeError('nargs for store actions must be != 0; if you ' + 'have nothing to store, actions such as store ' + 'true or store const may be more appropriate');
    }

    if (const_value !== undefined && nargs !== OPTIONAL) {
      throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL));
    }

    return _possibleConstructorReturn(this, _getPrototypeOf(_StoreAction).call(this, {
      option_strings: option_strings,
      dest: dest,
      nargs: nargs,
      "const": const_value,
      "default": default_value,
      type: type,
      choices: choices,
      required: required,
      help: help,
      metavar: metavar
    }));
  }

  _createClass(_StoreAction, [{
    key: "call",
    value: function call(parser, namespace, values
    /*, option_string = undefined*/
    ) {
      setattr(namespace, this.dest, values);
    }
  }]);

  return _StoreAction;
}(Action));

var _StoreConstAction = _callable(
/*#__PURE__*/
function (_Action3) {
  _inherits(_StoreConstAction, _Action3);

  function _StoreConstAction() {
    _classCallCheck(this, _StoreConstAction);

    var _parse_opts10 = _parse_opts(arguments, {
      option_strings: no_default,
      dest: no_default,
      "const": no_default,
      "default": undefined,
      required: false,
      help: undefined,
      metavar: undefined
    }),
        _parse_opts11 = _slicedToArray(_parse_opts10, 6),
        option_strings = _parse_opts11[0],
        dest = _parse_opts11[1],
        const_value = _parse_opts11[2],
        default_value = _parse_opts11[3],
        required = _parse_opts11[4],
        help //, metavar
    = _parse_opts11[5];

    return _possibleConstructorReturn(this, _getPrototypeOf(_StoreConstAction).call(this, {
      option_strings: option_strings,
      dest: dest,
      nargs: 0,
      "const": const_value,
      "default": default_value,
      required: required,
      help: help
    }));
  }

  _createClass(_StoreConstAction, [{
    key: "call",
    value: function call(parser, namespace
    /*, values, option_string = undefined*/
    ) {
      setattr(namespace, this.dest, this["const"]);
    }
  }]);

  return _StoreConstAction;
}(Action));

var _StoreTrueAction = _callable(
/*#__PURE__*/
function (_StoreConstAction2) {
  _inherits(_StoreTrueAction, _StoreConstAction2);

  function _StoreTrueAction() {
    _classCallCheck(this, _StoreTrueAction);

    var _parse_opts12 = _parse_opts(arguments, {
      option_strings: no_default,
      dest: no_default,
      "default": false,
      required: false,
      help: undefined
    }),
        _parse_opts13 = _slicedToArray(_parse_opts12, 5),
        option_strings = _parse_opts13[0],
        dest = _parse_opts13[1],
        default_value = _parse_opts13[2],
        required = _parse_opts13[3],
        help = _parse_opts13[4];

    return _possibleConstructorReturn(this, _getPrototypeOf(_StoreTrueAction).call(this, {
      option_strings: option_strings,
      dest: dest,
      "const": true,
      "default": default_value,
      required: required,
      help: help
    }));
  }

  return _StoreTrueAction;
}(_StoreConstAction));

var _StoreFalseAction = _callable(
/*#__PURE__*/
function (_StoreConstAction3) {
  _inherits(_StoreFalseAction, _StoreConstAction3);

  function _StoreFalseAction() {
    _classCallCheck(this, _StoreFalseAction);

    var _parse_opts14 = _parse_opts(arguments, {
      option_strings: no_default,
      dest: no_default,
      "default": true,
      required: false,
      help: undefined
    }),
        _parse_opts15 = _slicedToArray(_parse_opts14, 5),
        option_strings = _parse_opts15[0],
        dest = _parse_opts15[1],
        default_value = _parse_opts15[2],
        required = _parse_opts15[3],
        help = _parse_opts15[4];

    return _possibleConstructorReturn(this, _getPrototypeOf(_StoreFalseAction).call(this, {
      option_strings: option_strings,
      dest: dest,
      "const": false,
      "default": default_value,
      required: required,
      help: help
    }));
  }

  return _StoreFalseAction;
}(_StoreConstAction));

var _AppendAction = _callable(
/*#__PURE__*/
function (_Action4) {
  _inherits(_AppendAction, _Action4);

  function _AppendAction() {
    _classCallCheck(this, _AppendAction);

    var _parse_opts16 = _parse_opts(arguments, {
      option_strings: no_default,
      dest: no_default,
      nargs: undefined,
      "const": undefined,
      "default": undefined,
      type: undefined,
      choices: undefined,
      required: false,
      help: undefined,
      metavar: undefined
    }),
        _parse_opts17 = _slicedToArray(_parse_opts16, 10),
        option_strings = _parse_opts17[0],
        dest = _parse_opts17[1],
        nargs = _parse_opts17[2],
        const_value = _parse_opts17[3],
        default_value = _parse_opts17[4],
        type = _parse_opts17[5],
        choices = _parse_opts17[6],
        required = _parse_opts17[7],
        help = _parse_opts17[8],
        metavar = _parse_opts17[9];

    if (nargs === 0) {
      throw new TypeError('nargs for append actions must be != 0; if arg ' + 'strings are not supplying the value to append, ' + 'the append const action may be more appropriate');
    }

    if (const_value !== undefined && nargs !== OPTIONAL) {
      throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL));
    }

    return _possibleConstructorReturn(this, _getPrototypeOf(_AppendAction).call(this, {
      option_strings: option_strings,
      dest: dest,
      nargs: nargs,
      "const": const_value,
      "default": default_value,
      type: type,
      choices: choices,
      required: required,
      help: help,
      metavar: metavar
    }));
  }

  _createClass(_AppendAction, [{
    key: "call",
    value: function call(parser, namespace, values
    /*, option_string = undefined*/
    ) {
      var items = getattr(namespace, this.dest, undefined);
      items = _copy_items(items);
      items.push(values);
      setattr(namespace, this.dest, items);
    }
  }]);

  return _AppendAction;
}(Action));

var _AppendConstAction = _callable(
/*#__PURE__*/
function (_Action5) {
  _inherits(_AppendConstAction, _Action5);

  function _AppendConstAction() {
    _classCallCheck(this, _AppendConstAction);

    var _parse_opts18 = _parse_opts(arguments, {
      option_strings: no_default,
      dest: no_default,
      "const": no_default,
      "default": undefined,
      required: false,
      help: undefined,
      metavar: undefined
    }),
        _parse_opts19 = _slicedToArray(_parse_opts18, 7),
        option_strings = _parse_opts19[0],
        dest = _parse_opts19[1],
        const_value = _parse_opts19[2],
        default_value = _parse_opts19[3],
        required = _parse_opts19[4],
        help = _parse_opts19[5],
        metavar = _parse_opts19[6];

    return _possibleConstructorReturn(this, _getPrototypeOf(_AppendConstAction).call(this, {
      option_strings: option_strings,
      dest: dest,
      nargs: 0,
      "const": const_value,
      "default": default_value,
      required: required,
      help: help,
      metavar: metavar
    }));
  }

  _createClass(_AppendConstAction, [{
    key: "call",
    value: function call(parser, namespace
    /*, values, option_string = undefined*/
    ) {
      var items = getattr(namespace, this.dest, undefined);
      items = _copy_items(items);
      items.push(this["const"]);
      setattr(namespace, this.dest, items);
    }
  }]);

  return _AppendConstAction;
}(Action));

var _CountAction = _callable(
/*#__PURE__*/
function (_Action6) {
  _inherits(_CountAction, _Action6);

  function _CountAction() {
    _classCallCheck(this, _CountAction);

    var _parse_opts20 = _parse_opts(arguments, {
      option_strings: no_default,
      dest: no_default,
      "default": undefined,
      required: false,
      help: undefined
    }),
        _parse_opts21 = _slicedToArray(_parse_opts20, 5),
        option_strings = _parse_opts21[0],
        dest = _parse_opts21[1],
        default_value = _parse_opts21[2],
        required = _parse_opts21[3],
        help = _parse_opts21[4];

    return _possibleConstructorReturn(this, _getPrototypeOf(_CountAction).call(this, {
      option_strings: option_strings,
      dest: dest,
      nargs: 0,
      "default": default_value,
      required: required,
      help: help
    }));
  }

  _createClass(_CountAction, [{
    key: "call",
    value: function call(parser, namespace
    /*, values, option_string = undefined*/
    ) {
      var count = getattr(namespace, this.dest, undefined);

      if (count === undefined) {
        count = 0;
      }

      setattr(namespace, this.dest, count + 1);
    }
  }]);

  return _CountAction;
}(Action));

var _HelpAction = _callable(
/*#__PURE__*/
function (_Action7) {
  _inherits(_HelpAction, _Action7);

  function _HelpAction() {
    _classCallCheck(this, _HelpAction);

    var _parse_opts22 = _parse_opts(arguments, {
      option_strings: no_default,
      dest: SUPPRESS,
      "default": SUPPRESS,
      help: undefined
    }),
        _parse_opts23 = _slicedToArray(_parse_opts22, 4),
        option_strings = _parse_opts23[0],
        dest = _parse_opts23[1],
        default_value = _parse_opts23[2],
        help = _parse_opts23[3];

    return _possibleConstructorReturn(this, _getPrototypeOf(_HelpAction).call(this, {
      option_strings: option_strings,
      dest: dest,
      "default": default_value,
      nargs: 0,
      help: help
    }));
  }

  _createClass(_HelpAction, [{
    key: "call",
    value: function call(parser
    /*, namespace, values, option_string = undefined*/
    ) {
      parser.print_help();
      parser.exit();
    }
  }]);

  return _HelpAction;
}(Action));

var _VersionAction = _callable(
/*#__PURE__*/
function (_Action8) {
  _inherits(_VersionAction, _Action8);

  function _VersionAction() {
    var _this5;

    _classCallCheck(this, _VersionAction);

    var _parse_opts24 = _parse_opts(arguments, {
      option_strings: no_default,
      version: undefined,
      dest: SUPPRESS,
      "default": SUPPRESS,
      help: "show program's version number and exit"
    }),
        _parse_opts25 = _slicedToArray(_parse_opts24, 5),
        option_strings = _parse_opts25[0],
        version = _parse_opts25[1],
        dest = _parse_opts25[2],
        default_value = _parse_opts25[3],
        help = _parse_opts25[4];

    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(_VersionAction).call(this, {
      option_strings: option_strings,
      dest: dest,
      "default": default_value,
      nargs: 0,
      help: help
    }));
    _this5.version = version;
    return _this5;
  }

  _createClass(_VersionAction, [{
    key: "call",
    value: function call(parser
    /*, namespace, values, option_string = undefined*/
    ) {
      var version = this.version;

      if (version === undefined) {
        version = parser.version;
      }

      var formatter = parser._get_formatter();

      formatter.add_text(version);

      parser._print_message(formatter.format_help(), process.stdout);

      parser.exit();
    }
  }]);

  return _VersionAction;
}(Action));

var _SubParsersAction = _camelcase_alias(_callable(
/*#__PURE__*/
function (_Action9) {
  _inherits(_SubParsersAction, _Action9);

  function _SubParsersAction() {
    var _this6;

    _classCallCheck(this, _SubParsersAction);

    var _parse_opts26 = _parse_opts(arguments, {
      option_strings: no_default,
      prog: no_default,
      parser_class: no_default,
      dest: SUPPRESS,
      required: false,
      help: undefined,
      metavar: undefined
    }),
        _parse_opts27 = _slicedToArray(_parse_opts26, 7),
        option_strings = _parse_opts27[0],
        prog = _parse_opts27[1],
        parser_class = _parse_opts27[2],
        dest = _parse_opts27[3],
        required = _parse_opts27[4],
        help = _parse_opts27[5],
        metavar = _parse_opts27[6];

    var name_parser_map = {};
    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(_SubParsersAction).call(this, {
      option_strings: option_strings,
      dest: dest,
      nargs: PARSER,
      choices: name_parser_map,
      required: required,
      help: help,
      metavar: metavar
    }));
    _this6._prog_prefix = prog;
    _this6._parser_class = parser_class;
    _this6._name_parser_map = name_parser_map;
    _this6._choices_actions = [];
    return _this6;
  }

  _createClass(_SubParsersAction, [{
    key: "add_parser",
    value: function add_parser() {
      var _parse_opts28 = _parse_opts(arguments, {
        name: no_default,
        '**kwargs': no_default
      }),
          _parse_opts29 = _slicedToArray(_parse_opts28, 2),
          name = _parse_opts29[0],
          kwargs = _parse_opts29[1]; // set prog from the existing prefix


      if (kwargs.prog === undefined) {
        kwargs.prog = sub('%s %s', this._prog_prefix, name);
      }

      var aliases = getattr(kwargs, 'aliases', []);
      delete kwargs.aliases; // create a pseudo-action to hold the choice help

      if ('help' in kwargs) {
        var help = kwargs.help;
        delete kwargs.help;

        var choice_action = this._ChoicesPseudoAction(name, aliases, help);

        this._choices_actions.push(choice_action);
      } // create the parser and add it to the map


      var parser = new this._parser_class(kwargs);
      this._name_parser_map[name] = parser; // make parser available under aliases also

      var _iteratorNormalCompletion16 = true;
      var _didIteratorError16 = false;
      var _iteratorError16 = undefined;

      try {
        for (var _iterator16 = aliases[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
          var alias = _step16.value;
          this._name_parser_map[alias] = parser;
        }
      } catch (err) {
        _didIteratorError16 = true;
        _iteratorError16 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion16 && _iterator16["return"] != null) {
            _iterator16["return"]();
          }
        } finally {
          if (_didIteratorError16) {
            throw _iteratorError16;
          }
        }
      }

      return parser;
    }
  }, {
    key: "_get_subactions",
    value: function _get_subactions() {
      return this._choices_actions;
    }
  }, {
    key: "call",
    value: function call(parser, namespace, values
    /*, option_string = undefined*/
    ) {
      var parser_name = values[0];
      var arg_strings = values.slice(1); // set the parser name if requested

      if (this.dest !== SUPPRESS) {
        setattr(namespace, this.dest, parser_name);
      } // select the parser


      if (hasattr(this._name_parser_map, parser_name)) {
        parser = this._name_parser_map[parser_name];
      } else {
        var args = {
          parser_name: parser_name,
          choices: this._name_parser_map.join(', ')
        };
        var msg = sub('unknown parser %(parser_name)r (choices: %(choices)s)', args);
        throw new ArgumentError(this, msg);
      } // parse all the remaining options into the namespace
      // store any unrecognized options on the object, so that the top
      // level parser can decide what to do with them
      // In case this subparser defines new defaults, we parse them
      // in a new namespace object and then update the original
      // namespace for the relevant parts.


      var subnamespace;

      var _parser$parse_known_a = parser.parse_known_args(arg_strings, undefined);

      var _parser$parse_known_a2 = _slicedToArray(_parser$parse_known_a, 2);

      subnamespace = _parser$parse_known_a2[0];
      arg_strings = _parser$parse_known_a2[1];

      for (var _i11 = 0, _Object$entries3 = Object.entries(subnamespace); _i11 < _Object$entries3.length; _i11++) {
        var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i11], 2),
            key = _Object$entries3$_i[0],
            value = _Object$entries3$_i[1];

        setattr(namespace, key, value);
      }

      if (arg_strings.length) {
        var _getattr;

        setdefault(namespace, _UNRECOGNIZED_ARGS_ATTR, []);

        (_getattr = getattr(namespace, _UNRECOGNIZED_ARGS_ATTR)).push.apply(_getattr, _toConsumableArray(arg_strings));
      }
    }
  }]);

  return _SubParsersAction;
}(Action)));

_SubParsersAction.prototype._ChoicesPseudoAction = _callable(
/*#__PURE__*/
function (_Action10) {
  _inherits(_ChoicesPseudoAction, _Action10);

  function _ChoicesPseudoAction(name, aliases, help) {
    _classCallCheck(this, _ChoicesPseudoAction);

    var metavar = name,
        dest = name;

    if (aliases.length) {
      metavar += sub(' (%s)', aliases.join(', '));
    }

    return _possibleConstructorReturn(this, _getPrototypeOf(_ChoicesPseudoAction).call(this, {
      option_strings: [],
      dest: dest,
      help: help,
      metavar: metavar
    }));
  }

  return _ChoicesPseudoAction;
}(Action));

var _ExtendAction = _callable(
/*#__PURE__*/
function (_AppendAction2) {
  _inherits(_ExtendAction, _AppendAction2);

  function _ExtendAction() {
    _classCallCheck(this, _ExtendAction);

    return _possibleConstructorReturn(this, _getPrototypeOf(_ExtendAction).apply(this, arguments));
  }

  _createClass(_ExtendAction, [{
    key: "call",
    value: function call(parser, namespace, values
    /*, option_string = undefined*/
    ) {
      var items = getattr(namespace, this.dest, undefined);
      items = _copy_items(items);
      items = items.concat(values);
      setattr(namespace, this.dest, items);
    }
  }]);

  return _ExtendAction;
}(_AppendAction)); // ==============
// Type classes
// ==============


var FileType = _callable(
/*#__PURE__*/
function (_Function) {
  _inherits(FileType, _Function);

  /*
   *  Factory for creating file object types
   *
   *  Instances of FileType are typically passed as type= arguments to the
   *  ArgumentParser add_argument() method.
   *
   *  Keyword Arguments:
   *      - mode -- A string indicating how the file is to be opened. Accepts the
   *          same values as the builtin open() function.
   *      - bufsize -- The file's desired buffer size. Accepts the same values as
   *          the builtin open() function.
   *      - encoding -- The file's encoding. Accepts the same values as the
   *          builtin open() function.
   *      - errors -- A string indicating how encoding and decoding errors are to
   *          be handled. Accepts the same value as the builtin open() function.
   */
  function FileType() {
    var _this7;

    _classCallCheck(this, FileType);

    var _parse_opts30 = _parse_opts(arguments, {
      flags: 'r',
      encoding: undefined,
      mode: undefined,
      // 0o666
      autoClose: undefined,
      // true
      emitClose: undefined,
      // false
      start: undefined,
      // 0
      end: undefined,
      // Infinity
      highWaterMark: undefined,
      // 64 * 1024
      fs: undefined
    }),
        _parse_opts31 = _slicedToArray(_parse_opts30, 9),
        flags = _parse_opts31[0],
        encoding = _parse_opts31[1],
        mode = _parse_opts31[2],
        autoClose = _parse_opts31[3],
        emitClose = _parse_opts31[4],
        start = _parse_opts31[5],
        end = _parse_opts31[6],
        highWaterMark = _parse_opts31[7],
        fs = _parse_opts31[8]; // when this class is called as a function, redirect it to .call() method of itself


    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(FileType).call(this, 'return arguments.callee.call.apply(arguments.callee, arguments)'));
    Object.defineProperty(_assertThisInitialized(_this7), 'name', {
      get: function get() {
        return sub('FileType(%r)', flags);
      }
    });
    _this7._flags = flags;
    _this7._options = {};
    if (encoding !== undefined) _this7._options.encoding = encoding;
    if (mode !== undefined) _this7._options.mode = mode;
    if (autoClose !== undefined) _this7._options.autoClose = autoClose;
    if (emitClose !== undefined) _this7._options.emitClose = emitClose;
    if (start !== undefined) _this7._options.start = start;
    if (end !== undefined) _this7._options.end = end;
    if (highWaterMark !== undefined) _this7._options.highWaterMark = highWaterMark;
    if (fs !== undefined) _this7._options.fs = fs;
    return _this7;
  }

  _createClass(FileType, [{
    key: "call",
    value: function call(string) {
      // the special argument "-" means sys.std{in,out}
      if (string === '-') {
        if (this._flags.includes('r')) {
          return process.stdin;
        } else if (this._flags.includes('w')) {
          return process.stdout;
        } else {
          var msg = sub('argument "-" with mode %r', this._flags);
          throw new TypeError(msg);
        }
      } // all other arguments are used as file names


      var fd;

      try {
        fd = fs.openSync(string, this._flags, this._options.mode);
      } catch (e) {
        var args = {
          filename: string,
          error: e.message
        };
        var message = "can't open '%(filename)s': %(error)s";
        throw new ArgumentTypeError(sub(message, args));
      }

      var options = Object.assign({
        fd: fd,
        flags: this._flags
      }, this._options);

      if (this._flags.includes('r')) {
        return fs.createReadStream(undefined, options);
      } else if (this._flags.includes('w')) {
        return fs.createWriteStream(undefined, options);
      } else {
        var _msg = sub('argument "%s" with mode %r', string, this._flags);

        throw new TypeError(_msg);
      }
    }
  }, {
    key: util.inspect.custom,
    value: function value() {
      var args = [this._flags];
      var kwargs = Object.entries(this._options).map(function (_ref12) {
        var _ref13 = _slicedToArray(_ref12, 2),
            k = _ref13[0],
            v = _ref13[1];

        if (k === 'mode') v = _defineProperty({
          value: v
        }, util.inspect.custom, function () {
          return '0o' + this.value.toString(8);
        });
        return [k, v];
      });
      var args_str = [].concat(args.filter(function (arg) {
        return arg !== -1;
      }).map(repr)).concat(kwargs.filter(function (_ref14) {
        var _ref15 = _slicedToArray(_ref14, 2),

        /*kw*/
        arg = _ref15[1];

        return arg !== undefined;
      }).map(function (_ref16) {
        var _ref17 = _slicedToArray(_ref16, 2),
            kw = _ref17[0],
            arg = _ref17[1];

        return sub('%s=%r', kw, arg);
      })).join(', ');
      return sub('%s(%s)', this.constructor.name, args_str);
    }
  }, {
    key: "toString",
    value: function toString() {
      return this[util.inspect.custom]();
    }
  }]);

  return FileType;
}(_wrapNativeSuper(Function))); // ===========================
// Optional and Positional Parsing
// ===========================


var Namespace = _callable(
/*#__PURE__*/
function (_AttributeHolder3) {
  _inherits(Namespace, _AttributeHolder3);

  /*
   *  Simple object for storing attributes.
   *
   *  Implements equality by attribute names and values, and provides a simple
   *  string representation.
   */
  function Namespace() {
    var _this8;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Namespace);

    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(Namespace).call(this));
    Object.assign(_assertThisInitialized(_this8), options);
    return _this8;
  }

  return Namespace;
}(_AttributeHolder())); // unset string tag to mimic plain object


Namespace.prototype[Symbol.toStringTag] = undefined;

var _ActionsContainer = _camelcase_alias(_callable(
/*#__PURE__*/
function () {
  function _ActionsContainer() {
    var _this9 = this;

    _classCallCheck(this, _ActionsContainer);

    var _parse_opts32 = _parse_opts(arguments, {
      description: no_default,
      prefix_chars: no_default,
      argument_default: no_default,
      conflict_handler: no_default
    }),
        _parse_opts33 = _slicedToArray(_parse_opts32, 4),
        description = _parse_opts33[0],
        prefix_chars = _parse_opts33[1],
        argument_default = _parse_opts33[2],
        conflict_handler = _parse_opts33[3];

    this.description = description;
    this.argument_default = argument_default;
    this.prefix_chars = prefix_chars;
    this.conflict_handler = conflict_handler; // set up registries

    this._registries = {}; // register actions

    this.register('action', undefined, _StoreAction);
    this.register('action', 'store', _StoreAction);
    this.register('action', 'store_const', _StoreConstAction);
    this.register('action', 'store_true', _StoreTrueAction);
    this.register('action', 'store_false', _StoreFalseAction);
    this.register('action', 'append', _AppendAction);
    this.register('action', 'append_const', _AppendConstAction);
    this.register('action', 'count', _CountAction);
    this.register('action', 'help', _HelpAction);
    this.register('action', 'version', _VersionAction);
    this.register('action', 'parsers', _SubParsersAction);
    this.register('action', 'extend', _ExtendAction) // LEGACY (v1 compatibility): camelcase variants
    ;
    ['storeConst', 'storeTrue', 'storeFalse', 'appendConst'].forEach(function (old_name) {
      var new_name = _to_new_name(old_name);

      _this9.register('action', old_name, util.deprecate(_this9._registry_get('action', new_name), sub('{action: "%s"} is renamed to {action: "%s"}', old_name, new_name)));
    }); // end
    // raise an exception if the conflict handler is invalid

    this._get_handler(); // action storage


    this._actions = [];
    this._option_string_actions = {}; // groups

    this._action_groups = [];
    this._mutually_exclusive_groups = []; // defaults storage

    this._defaults = {}; // determines whether an "option" looks like a negative number

    this._negative_number_matcher = /^-\d+$|^-\d*\.\d+$/; // whether or not there are any optionals that look like negative
    // numbers -- uses a list so it can be shared and edited

    this._has_negative_number_optionals = [];
  } // ====================
  // Registration methods
  // ====================


  _createClass(_ActionsContainer, [{
    key: "register",
    value: function register(registry_name, value, object) {
      var registry = setdefault(this._registries, registry_name, {});
      registry[value] = object;
    }
  }, {
    key: "_registry_get",
    value: function _registry_get(registry_name, value) {
      var default_value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      return getattr(this._registries[registry_name], value, default_value);
    } // ==================================
    // Namespace default accessor methods
    // ==================================

  }, {
    key: "set_defaults",
    value: function set_defaults(kwargs) {
      Object.assign(this._defaults, kwargs); // if these defaults match any existing arguments, replace
      // the previous default on the object with the new one

      var _iteratorNormalCompletion17 = true;
      var _didIteratorError17 = false;
      var _iteratorError17 = undefined;

      try {
        for (var _iterator17 = this._actions[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
          var action = _step17.value;

          if (action.dest in kwargs) {
            action["default"] = kwargs[action.dest];
          }
        }
      } catch (err) {
        _didIteratorError17 = true;
        _iteratorError17 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion17 && _iterator17["return"] != null) {
            _iterator17["return"]();
          }
        } finally {
          if (_didIteratorError17) {
            throw _iteratorError17;
          }
        }
      }
    }
  }, {
    key: "get_default",
    value: function get_default(dest) {
      var _iteratorNormalCompletion18 = true;
      var _didIteratorError18 = false;
      var _iteratorError18 = undefined;

      try {
        for (var _iterator18 = this._actions[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
          var action = _step18.value;

          if (action.dest === dest && action["default"] !== undefined) {
            return action["default"];
          }
        }
      } catch (err) {
        _didIteratorError18 = true;
        _iteratorError18 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion18 && _iterator18["return"] != null) {
            _iterator18["return"]();
          }
        } finally {
          if (_didIteratorError18) {
            throw _iteratorError18;
          }
        }
      }

      return this._defaults[dest];
    } // =======================
    // Adding argument actions
    // =======================

  }, {
    key: "add_argument",
    value: function add_argument() {
      /*
       *  add_argument(dest, ..., name=value, ...)
       *  add_argument(option_string, option_string, ..., name=value, ...)
       */
      var _parse_opts34 = _parse_opts(arguments, {
        '*args': no_default,
        '**kwargs': no_default
      }),
          _parse_opts35 = _slicedToArray(_parse_opts34, 2),
          args = _parse_opts35[0],
          kwargs = _parse_opts35[1]; // LEGACY (v1 compatibility), old-style add_argument([ args ], { options })


      if (args.length === 1 && Array.isArray(args[0])) {
        args = args[0];
        deprecate('argument-array', sub('use add_argument(%(args)s, {...}) instead of add_argument([ %(args)s ], { ... })', {
          args: args.map(repr).join(', ')
        }));
      } // end
      // if no positional args are supplied or only one is supplied and
      // it doesn't look like an option string, parse a positional
      // argument


      var chars = this.prefix_chars;

      if (!args.length || args.length === 1 && !chars.includes(args[0][0])) {
        if (args.length && 'dest' in kwargs) {
          throw new TypeError('dest supplied twice for positional argument');
        }

        kwargs = this._get_positional_kwargs.apply(this, _toConsumableArray(args).concat([kwargs])); // otherwise, we're adding an optional argument
      } else {
        kwargs = this._get_optional_kwargs.apply(this, _toConsumableArray(args).concat([kwargs]));
      } // if no default was supplied, use the parser-level default


      if (!('default' in kwargs)) {
        var dest = kwargs.dest;

        if (dest in this._defaults) {
          kwargs["default"] = this._defaults[dest];
        } else if (this.argument_default !== undefined) {
          kwargs["default"] = this.argument_default;
        }
      } // create the action object, and add it to the parser


      var action_class = this._pop_action_class(kwargs);

      if (typeof action_class !== 'function') {
        throw new TypeError(sub('unknown action "%s"', action_class));
      } // eslint-disable-next-line new-cap


      var action = new action_class(kwargs); // raise an error if the action type is not callable

      var type_func = this._registry_get('type', action.type, action.type);

      if (typeof type_func !== 'function') {
        throw new TypeError(sub('%r is not callable', type_func));
      }

      if (type_func === FileType) {
        throw new TypeError(sub('%r is a FileType class object, instance of it' + ' must be passed', type_func));
      } // raise an error if the metavar does not match the type


      if ('_get_formatter' in this) {
        try {
          this._get_formatter()._format_args(action, undefined);
        } catch (err) {
          // check for 'invalid nargs value' is an artifact of TypeError and ValueError in js being the same
          if (err instanceof TypeError && err.message !== 'invalid nargs value') {
            throw new TypeError('length of metavar tuple does not match nargs');
          } else {
            throw err;
          }
        }
      }

      return this._add_action(action);
    }
  }, {
    key: "add_argument_group",
    value: function add_argument_group() {
      var group = _ArgumentGroup.apply(void 0, [this].concat(Array.prototype.slice.call(arguments)));

      this._action_groups.push(group);

      return group;
    }
  }, {
    key: "add_mutually_exclusive_group",
    value: function add_mutually_exclusive_group() {
      // eslint-disable-next-line no-use-before-define
      var group = _MutuallyExclusiveGroup.apply(void 0, [this].concat(Array.prototype.slice.call(arguments)));

      this._mutually_exclusive_groups.push(group);

      return group;
    }
  }, {
    key: "_add_action",
    value: function _add_action(action) {
      // resolve any conflicts
      this._check_conflict(action); // add to actions list


      this._actions.push(action);

      action.container = this; // index the action by any option strings it has

      var _iteratorNormalCompletion19 = true;
      var _didIteratorError19 = false;
      var _iteratorError19 = undefined;

      try {
        for (var _iterator19 = action.option_strings[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
          var option_string = _step19.value;
          this._option_string_actions[option_string] = action;
        } // set the flag if any option strings look like negative numbers

      } catch (err) {
        _didIteratorError19 = true;
        _iteratorError19 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion19 && _iterator19["return"] != null) {
            _iterator19["return"]();
          }
        } finally {
          if (_didIteratorError19) {
            throw _iteratorError19;
          }
        }
      }

      var _iteratorNormalCompletion20 = true;
      var _didIteratorError20 = false;
      var _iteratorError20 = undefined;

      try {
        for (var _iterator20 = action.option_strings[Symbol.iterator](), _step20; !(_iteratorNormalCompletion20 = (_step20 = _iterator20.next()).done); _iteratorNormalCompletion20 = true) {
          var _option_string = _step20.value;

          if (this._negative_number_matcher.test(_option_string)) {
            if (!this._has_negative_number_optionals.length) {
              this._has_negative_number_optionals.push(true);
            }
          }
        } // return the created action

      } catch (err) {
        _didIteratorError20 = true;
        _iteratorError20 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion20 && _iterator20["return"] != null) {
            _iterator20["return"]();
          }
        } finally {
          if (_didIteratorError20) {
            throw _iteratorError20;
          }
        }
      }

      return action;
    }
  }, {
    key: "_remove_action",
    value: function _remove_action(action) {
      _array_remove(this._actions, action);
    }
  }, {
    key: "_add_container_actions",
    value: function _add_container_actions(container) {
      // collect groups by titles
      var title_group_map = {};
      var _iteratorNormalCompletion21 = true;
      var _didIteratorError21 = false;
      var _iteratorError21 = undefined;

      try {
        for (var _iterator21 = this._action_groups[Symbol.iterator](), _step21; !(_iteratorNormalCompletion21 = (_step21 = _iterator21.next()).done); _iteratorNormalCompletion21 = true) {
          var group = _step21.value;

          if (group.title in title_group_map) {
            var msg = 'cannot merge actions - two groups are named %r';
            throw new TypeError(sub(msg, group.title));
          }

          title_group_map[group.title] = group;
        } // map each action to its group

      } catch (err) {
        _didIteratorError21 = true;
        _iteratorError21 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion21 && _iterator21["return"] != null) {
            _iterator21["return"]();
          }
        } finally {
          if (_didIteratorError21) {
            throw _iteratorError21;
          }
        }
      }

      var group_map = new Map();
      var _iteratorNormalCompletion22 = true;
      var _didIteratorError22 = false;
      var _iteratorError22 = undefined;

      try {
        for (var _iterator22 = container._action_groups[Symbol.iterator](), _step22; !(_iteratorNormalCompletion22 = (_step22 = _iterator22.next()).done); _iteratorNormalCompletion22 = true) {
          var _group = _step22.value;

          // if a group with the title exists, use that, otherwise
          // create a new group matching the container's group
          if (!(_group.title in title_group_map)) {
            title_group_map[_group.title] = this.add_argument_group({
              title: _group.title,
              description: _group.description,
              conflict_handler: _group.conflict_handler
            });
          } // map the actions to their new group


          var _iteratorNormalCompletion25 = true;
          var _didIteratorError25 = false;
          var _iteratorError25 = undefined;

          try {
            for (var _iterator25 = _group._group_actions[Symbol.iterator](), _step25; !(_iteratorNormalCompletion25 = (_step25 = _iterator25.next()).done); _iteratorNormalCompletion25 = true) {
              var action = _step25.value;
              group_map.set(action, title_group_map[_group.title]);
            }
          } catch (err) {
            _didIteratorError25 = true;
            _iteratorError25 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion25 && _iterator25["return"] != null) {
                _iterator25["return"]();
              }
            } finally {
              if (_didIteratorError25) {
                throw _iteratorError25;
              }
            }
          }
        } // add container's mutually exclusive groups
        // NOTE: if add_mutually_exclusive_group ever gains title= and
        // description= then this code will need to be expanded as above

      } catch (err) {
        _didIteratorError22 = true;
        _iteratorError22 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion22 && _iterator22["return"] != null) {
            _iterator22["return"]();
          }
        } finally {
          if (_didIteratorError22) {
            throw _iteratorError22;
          }
        }
      }

      var _iteratorNormalCompletion23 = true;
      var _didIteratorError23 = false;
      var _iteratorError23 = undefined;

      try {
        for (var _iterator23 = container._mutually_exclusive_groups[Symbol.iterator](), _step23; !(_iteratorNormalCompletion23 = (_step23 = _iterator23.next()).done); _iteratorNormalCompletion23 = true) {
          var _group2 = _step23.value;
          var mutex_group = this.add_mutually_exclusive_group({
            required: _group2.required
          }); // map the actions to their new mutex group

          var _iteratorNormalCompletion26 = true;
          var _didIteratorError26 = false;
          var _iteratorError26 = undefined;

          try {
            for (var _iterator26 = _group2._group_actions[Symbol.iterator](), _step26; !(_iteratorNormalCompletion26 = (_step26 = _iterator26.next()).done); _iteratorNormalCompletion26 = true) {
              var _action2 = _step26.value;
              group_map.set(_action2, mutex_group);
            }
          } catch (err) {
            _didIteratorError26 = true;
            _iteratorError26 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion26 && _iterator26["return"] != null) {
                _iterator26["return"]();
              }
            } finally {
              if (_didIteratorError26) {
                throw _iteratorError26;
              }
            }
          }
        } // add all actions to this container or their group

      } catch (err) {
        _didIteratorError23 = true;
        _iteratorError23 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion23 && _iterator23["return"] != null) {
            _iterator23["return"]();
          }
        } finally {
          if (_didIteratorError23) {
            throw _iteratorError23;
          }
        }
      }

      var _iteratorNormalCompletion24 = true;
      var _didIteratorError24 = false;
      var _iteratorError24 = undefined;

      try {
        for (var _iterator24 = container._actions[Symbol.iterator](), _step24; !(_iteratorNormalCompletion24 = (_step24 = _iterator24.next()).done); _iteratorNormalCompletion24 = true) {
          var _action3 = _step24.value;

          group_map.get(_action3)._add_action(_action3);
        }
      } catch (err) {
        _didIteratorError24 = true;
        _iteratorError24 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion24 && _iterator24["return"] != null) {
            _iterator24["return"]();
          }
        } finally {
          if (_didIteratorError24) {
            throw _iteratorError24;
          }
        }
      }
    }
  }, {
    key: "_get_positional_kwargs",
    value: function _get_positional_kwargs() {
      var _parse_opts36 = _parse_opts(arguments, {
        dest: no_default,
        '**kwargs': no_default
      }),
          _parse_opts37 = _slicedToArray(_parse_opts36, 2),
          dest = _parse_opts37[0],
          kwargs = _parse_opts37[1]; // make sure required is not specified


      if ('required' in kwargs) {
        var msg = "'required' is an invalid argument for positionals";
        throw new TypeError(msg);
      } // mark positional arguments as required if at least one is
      // always required


      if (![OPTIONAL, ZERO_OR_MORE].includes(kwargs.nargs)) {
        kwargs.required = true;
      }

      if (kwargs.nargs === ZERO_OR_MORE && !('default' in kwargs)) {
        kwargs.required = true;
      } // return the keyword arguments with no option strings


      return Object.assign(kwargs, {
        dest: dest,
        option_strings: []
      });
    }
  }, {
    key: "_get_optional_kwargs",
    value: function _get_optional_kwargs() {
      var _parse_opts38 = _parse_opts(arguments, {
        '*args': no_default,
        '**kwargs': no_default
      }),
          _parse_opts39 = _slicedToArray(_parse_opts38, 2),
          args = _parse_opts39[0],
          kwargs = _parse_opts39[1]; // determine short and long option strings


      var option_strings = [];
      var long_option_strings = [];
      var option_string;
      var _iteratorNormalCompletion27 = true;
      var _didIteratorError27 = false;
      var _iteratorError27 = undefined;

      try {
        for (var _iterator27 = args[Symbol.iterator](), _step27; !(_iteratorNormalCompletion27 = (_step27 = _iterator27.next()).done); _iteratorNormalCompletion27 = true) {
          option_string = _step27.value;

          // error on strings that don't start with an appropriate prefix
          if (!this.prefix_chars.includes(option_string[0])) {
            var _args2 = {
              option: option_string,
              prefix_chars: this.prefix_chars
            };

            var _msg2 = 'invalid option string %(option)r: ' + 'must start with a character %(prefix_chars)r';

            throw new TypeError(sub(_msg2, _args2));
          } // strings starting with two prefix characters are long options


          option_strings.push(option_string);

          if (option_string.length > 1 && this.prefix_chars.includes(option_string[1])) {
            long_option_strings.push(option_string);
          }
        } // infer destination, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'

      } catch (err) {
        _didIteratorError27 = true;
        _iteratorError27 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion27 && _iterator27["return"] != null) {
            _iterator27["return"]();
          }
        } finally {
          if (_didIteratorError27) {
            throw _iteratorError27;
          }
        }
      }

      var dest = kwargs.dest;
      delete kwargs.dest;

      if (dest === undefined) {
        var dest_option_string;

        if (long_option_strings.length) {
          dest_option_string = long_option_strings[0];
        } else {
          dest_option_string = option_strings[0];
        }

        dest = _string_lstrip(dest_option_string, this.prefix_chars);

        if (!dest) {
          var msg = 'dest= is required for options like %r';
          throw new TypeError(sub(msg, option_string));
        }

        dest = dest.replace(/-/g, '_');
      } // return the updated keyword arguments


      return Object.assign(kwargs, {
        dest: dest,
        option_strings: option_strings
      });
    }
  }, {
    key: "_pop_action_class",
    value: function _pop_action_class(kwargs) {
      var default_value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var action = getattr(kwargs, 'action', default_value);
      delete kwargs.action;
      return this._registry_get('action', action, action);
    }
  }, {
    key: "_get_handler",
    value: function _get_handler() {
      // determine function from conflict handler string
      var handler_func_name = sub('_handle_conflict_%s', this.conflict_handler);

      if (typeof this[handler_func_name] === 'function') {
        return this[handler_func_name];
      } else {
        var msg = 'invalid conflict_resolution value: %r';
        throw new TypeError(sub(msg, this.conflict_handler));
      }
    }
  }, {
    key: "_check_conflict",
    value: function _check_conflict(action) {
      // find all options that conflict with this option
      var confl_optionals = [];
      var _iteratorNormalCompletion28 = true;
      var _didIteratorError28 = false;
      var _iteratorError28 = undefined;

      try {
        for (var _iterator28 = action.option_strings[Symbol.iterator](), _step28; !(_iteratorNormalCompletion28 = (_step28 = _iterator28.next()).done); _iteratorNormalCompletion28 = true) {
          var option_string = _step28.value;

          if (hasattr(this._option_string_actions, option_string)) {
            var confl_optional = this._option_string_actions[option_string];
            confl_optionals.push([option_string, confl_optional]);
          }
        } // resolve any conflicts

      } catch (err) {
        _didIteratorError28 = true;
        _iteratorError28 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion28 && _iterator28["return"] != null) {
            _iterator28["return"]();
          }
        } finally {
          if (_didIteratorError28) {
            throw _iteratorError28;
          }
        }
      }

      if (confl_optionals.length) {
        var conflict_handler = this._get_handler();

        conflict_handler.call(this, action, confl_optionals);
      }
    }
  }, {
    key: "_handle_conflict_error",
    value: function _handle_conflict_error(action, conflicting_actions) {
      var message = conflicting_actions.length === 1 ? 'conflicting option string: %s' : 'conflicting option strings: %s';
      var conflict_string = conflicting_actions.map(function (_ref18) {
        var _ref19 = _slicedToArray(_ref18, 1),
            option_string
        /*, action*/
        = _ref19[0];

        return option_string;
      }).join(', ');
      throw new ArgumentError(action, sub(message, conflict_string));
    }
  }, {
    key: "_handle_conflict_resolve",
    value: function _handle_conflict_resolve(action, conflicting_actions) {
      // remove all conflicting options
      var _iteratorNormalCompletion29 = true;
      var _didIteratorError29 = false;
      var _iteratorError29 = undefined;

      try {
        for (var _iterator29 = conflicting_actions[Symbol.iterator](), _step29; !(_iteratorNormalCompletion29 = (_step29 = _iterator29.next()).done); _iteratorNormalCompletion29 = true) {
          var _step29$value = _slicedToArray(_step29.value, 2),
              option_string = _step29$value[0],
              _action4 = _step29$value[1];

          // remove the conflicting option
          _array_remove(_action4.option_strings, option_string);

          delete this._option_string_actions[option_string]; // if the option now has no option string, remove it from the
          // container holding it

          if (!_action4.option_strings.length) {
            _action4.container._remove_action(_action4);
          }
        }
      } catch (err) {
        _didIteratorError29 = true;
        _iteratorError29 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion29 && _iterator29["return"] != null) {
            _iterator29["return"]();
          }
        } finally {
          if (_didIteratorError29) {
            throw _iteratorError29;
          }
        }
      }
    }
  }]);

  return _ActionsContainer;
}()));

var _ArgumentGroup = _callable(
/*#__PURE__*/
function (_ActionsContainer2) {
  _inherits(_ArgumentGroup, _ActionsContainer2);

  function _ArgumentGroup() {
    var _this10;

    _classCallCheck(this, _ArgumentGroup);

    var _parse_opts40 = _parse_opts(arguments, {
      container: no_default,
      title: undefined,
      description: undefined,
      '**kwargs': no_default
    }),
        _parse_opts41 = _slicedToArray(_parse_opts40, 4),
        container = _parse_opts41[0],
        title = _parse_opts41[1],
        description = _parse_opts41[2],
        kwargs = _parse_opts41[3]; // add any missing keyword arguments by checking the container


    setdefault(kwargs, 'conflict_handler', container.conflict_handler);
    setdefault(kwargs, 'prefix_chars', container.prefix_chars);
    setdefault(kwargs, 'argument_default', container.argument_default);
    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(_ArgumentGroup).call(this, Object.assign({
      description: description
    }, kwargs))); // group attributes

    _this10.title = title;
    _this10._group_actions = []; // share most attributes with the container

    _this10._registries = container._registries;
    _this10._actions = container._actions;
    _this10._option_string_actions = container._option_string_actions;
    _this10._defaults = container._defaults;
    _this10._has_negative_number_optionals = container._has_negative_number_optionals;
    _this10._mutually_exclusive_groups = container._mutually_exclusive_groups;
    return _this10;
  }

  _createClass(_ArgumentGroup, [{
    key: "_add_action",
    value: function _add_action(action) {
      action = _get(_getPrototypeOf(_ArgumentGroup.prototype), "_add_action", this).call(this, action);

      this._group_actions.push(action);

      return action;
    }
  }, {
    key: "_remove_action",
    value: function _remove_action(action) {
      _get(_getPrototypeOf(_ArgumentGroup.prototype), "_remove_action", this).call(this, action);

      _array_remove(this._group_actions, action);
    }
  }]);

  return _ArgumentGroup;
}(_ActionsContainer));

var _MutuallyExclusiveGroup = _callable(
/*#__PURE__*/
function (_ArgumentGroup2) {
  _inherits(_MutuallyExclusiveGroup, _ArgumentGroup2);

  function _MutuallyExclusiveGroup() {
    var _this11;

    _classCallCheck(this, _MutuallyExclusiveGroup);

    var _parse_opts42 = _parse_opts(arguments, {
      container: no_default,
      required: false
    }),
        _parse_opts43 = _slicedToArray(_parse_opts42, 2),
        container = _parse_opts43[0],
        required = _parse_opts43[1];

    _this11 = _possibleConstructorReturn(this, _getPrototypeOf(_MutuallyExclusiveGroup).call(this, container));
    _this11.required = required;
    _this11._container = container;
    return _this11;
  }

  _createClass(_MutuallyExclusiveGroup, [{
    key: "_add_action",
    value: function _add_action(action) {
      if (action.required) {
        var msg = 'mutually exclusive arguments must be optional';
        throw new TypeError(msg);
      }

      action = this._container._add_action(action);

      this._group_actions.push(action);

      return action;
    }
  }, {
    key: "_remove_action",
    value: function _remove_action(action) {
      this._container._remove_action(action);

      _array_remove(this._group_actions, action);
    }
  }]);

  return _MutuallyExclusiveGroup;
}(_ArgumentGroup));

var ArgumentParser = _camelcase_alias(_callable(
/*#__PURE__*/
function (_AttributeHolder4) {
  _inherits(ArgumentParser, _AttributeHolder4);

  /*
   *  Object for parsing command line strings into Python objects.
   *
   *  Keyword Arguments:
   *      - prog -- The name of the program (default: sys.argv[0])
   *      - usage -- A usage message (default: auto-generated from arguments)
   *      - description -- A description of what the program does
   *      - epilog -- Text following the argument descriptions
   *      - parents -- Parsers whose arguments should be copied into this one
   *      - formatter_class -- HelpFormatter class for printing help messages
   *      - prefix_chars -- Characters that prefix optional arguments
   *      - fromfile_prefix_chars -- Characters that prefix files containing
   *          additional arguments
   *      - argument_default -- The default value for all arguments
   *      - conflict_handler -- String indicating how to handle conflicts
   *      - add_help -- Add a -h/-help option
   *      - allow_abbrev -- Allow long options to be abbreviated unambiguously
   *      - exit_on_error -- Determines whether or not ArgumentParser exits with
   *          error info when an error occurs
   */
  function ArgumentParser() {
    var _this12;

    _classCallCheck(this, ArgumentParser);

    var _parse_opts44 = _parse_opts(arguments, {
      prog: undefined,
      usage: undefined,
      description: undefined,
      epilog: undefined,
      parents: [],
      formatter_class: HelpFormatter,
      prefix_chars: '-',
      fromfile_prefix_chars: undefined,
      argument_default: undefined,
      conflict_handler: 'error',
      add_help: true,
      allow_abbrev: true,
      exit_on_error: true,
      debug: undefined,
      // LEGACY (v1 compatibility), debug mode
      version: undefined // LEGACY (v1 compatibility), version

    }),
        _parse_opts45 = _slicedToArray(_parse_opts44, 15),
        prog = _parse_opts45[0],
        usage = _parse_opts45[1],
        description = _parse_opts45[2],
        epilog = _parse_opts45[3],
        parents = _parse_opts45[4],
        formatter_class = _parse_opts45[5],
        prefix_chars = _parse_opts45[6],
        fromfile_prefix_chars = _parse_opts45[7],
        argument_default = _parse_opts45[8],
        conflict_handler = _parse_opts45[9],
        add_help = _parse_opts45[10],
        allow_abbrev = _parse_opts45[11],
        exit_on_error = _parse_opts45[12],
        debug = _parse_opts45[13],
        // LEGACY (v1 compatibility), debug mode
    version // LEGACY (v1 compatibility), version
    = _parse_opts45[14]; // LEGACY (v1 compatibility)


    if (debug !== undefined) {
      deprecate('debug', 'The "debug" argument to ArgumentParser is deprecated. Please ' + 'override ArgumentParser.exit function instead.');
    }

    if (version !== undefined) {
      deprecate('version', 'The "version" argument to ArgumentParser is deprecated. Please use ' + "add_argument(..., { action: 'version', version: 'N', ... }) instead.");
    } // end


    _this12 = _possibleConstructorReturn(this, _getPrototypeOf(ArgumentParser).call(this, {
      description: description,
      prefix_chars: prefix_chars,
      argument_default: argument_default,
      conflict_handler: conflict_handler
    })); // default setting for prog

    if (prog === undefined) {
      prog = path.basename(get_argv()[0] || '');
    }

    _this12.prog = prog;
    _this12.usage = usage;
    _this12.epilog = epilog;
    _this12.formatter_class = formatter_class;
    _this12.fromfile_prefix_chars = fromfile_prefix_chars;
    _this12.add_help = add_help;
    _this12.allow_abbrev = allow_abbrev;
    _this12.exit_on_error = exit_on_error; // LEGACY (v1 compatibility), debug mode

    _this12.debug = debug; // end

    _this12._positionals = _this12.add_argument_group('positional arguments');
    _this12._optionals = _this12.add_argument_group('optional arguments');
    _this12._subparsers = undefined; // register types

    function identity(string) {
      return string;
    }

    _this12.register('type', undefined, identity);

    _this12.register('type', null, identity);

    _this12.register('type', 'auto', identity);

    _this12.register('type', 'int', function (x) {
      var result = Number(x);

      if (!Number.isInteger(result)) {
        throw new TypeError(sub('could not convert string to int: %r', x));
      }

      return result;
    });

    _this12.register('type', 'float', function (x) {
      var result = Number(x);

      if (isNaN(result)) {
        throw new TypeError(sub('could not convert string to float: %r', x));
      }

      return result;
    });

    _this12.register('type', 'str', String); // LEGACY (v1 compatibility): custom types


    _this12.register('type', 'string', util.deprecate(String, 'use {type:"str"} or {type:String} instead of {type:"string"}')); // end
    // add help argument if necessary
    // (using explicit default to override global argument_default)


    var default_prefix = prefix_chars.includes('-') ? '-' : prefix_chars[0];

    if (_this12.add_help) {
      _this12.add_argument(default_prefix + 'h', default_prefix.repeat(2) + 'help', {
        action: 'help',
        "default": SUPPRESS,
        help: 'show this help message and exit'
      });
    } // LEGACY (v1 compatibility), version


    if (version) {
      _this12.add_argument(default_prefix + 'v', default_prefix.repeat(2) + 'version', {
        action: 'version',
        "default": SUPPRESS,
        version: _this12.version,
        help: "show program's version number and exit"
      });
    } // end
    // add parent arguments and defaults


    var _iteratorNormalCompletion30 = true;
    var _didIteratorError30 = false;
    var _iteratorError30 = undefined;

    try {
      for (var _iterator30 = parents[Symbol.iterator](), _step30; !(_iteratorNormalCompletion30 = (_step30 = _iterator30.next()).done); _iteratorNormalCompletion30 = true) {
        var parent = _step30.value;

        _this12._add_container_actions(parent);

        Object.assign(_this12._defaults, parent._defaults);
      }
    } catch (err) {
      _didIteratorError30 = true;
      _iteratorError30 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion30 && _iterator30["return"] != null) {
          _iterator30["return"]();
        }
      } finally {
        if (_didIteratorError30) {
          throw _iteratorError30;
        }
      }
    }

    return _this12;
  } // =======================
  // Pretty __repr__ methods
  // =======================


  _createClass(ArgumentParser, [{
    key: "_get_kwargs",
    value: function _get_kwargs() {
      var _this13 = this;

      var names = ['prog', 'usage', 'description', 'formatter_class', 'conflict_handler', 'add_help'];
      return names.map(function (name) {
        return [name, getattr(_this13, name)];
      });
    } // ==================================
    // Optional/Positional adding methods
    // ==================================

  }, {
    key: "add_subparsers",
    value: function add_subparsers() {
      var _parse_opts46 = _parse_opts(arguments, {
        '**kwargs': no_default
      }),
          _parse_opts47 = _slicedToArray(_parse_opts46, 1),
          kwargs = _parse_opts47[0];

      if (this._subparsers !== undefined) {
        this.error('cannot have multiple subparser arguments');
      } // add the parser class to the arguments if it's not present


      setdefault(kwargs, 'parser_class', this.constructor);

      if ('title' in kwargs || 'description' in kwargs) {
        var title = getattr(kwargs, 'title', 'subcommands');
        var description = getattr(kwargs, 'description', undefined);
        delete kwargs.title;
        delete kwargs.description;
        this._subparsers = this.add_argument_group(title, description);
      } else {
        this._subparsers = this._positionals;
      } // prog defaults to the usage message of this parser, skipping
      // optional arguments and with no "usage:" prefix


      if (kwargs.prog === undefined) {
        var formatter = this._get_formatter();

        var positionals = this._get_positional_actions();

        var groups = this._mutually_exclusive_groups;
        formatter.add_usage(this.usage, positionals, groups, '');
        kwargs.prog = formatter.format_help().trim();
      } // create the parsers action and add it to the positionals list


      var parsers_class = this._pop_action_class(kwargs, 'parsers'); // eslint-disable-next-line new-cap


      var action = new parsers_class(Object.assign({
        option_strings: []
      }, kwargs));

      this._subparsers._add_action(action); // return the created parsers action


      return action;
    }
  }, {
    key: "_add_action",
    value: function _add_action(action) {
      if (action.option_strings.length) {
        this._optionals._add_action(action);
      } else {
        this._positionals._add_action(action);
      }

      return action;
    }
  }, {
    key: "_get_optional_actions",
    value: function _get_optional_actions() {
      return this._actions.filter(function (action) {
        return action.option_strings.length;
      });
    }
  }, {
    key: "_get_positional_actions",
    value: function _get_positional_actions() {
      return this._actions.filter(function (action) {
        return !action.option_strings.length;
      });
    } // =====================================
    // Command line argument parsing methods
    // =====================================

  }, {
    key: "parse_args",
    value: function parse_args() {
      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var argv;

      var _this$parse_known_arg = this.parse_known_args(args, namespace);

      var _this$parse_known_arg2 = _slicedToArray(_this$parse_known_arg, 2);

      args = _this$parse_known_arg2[0];
      argv = _this$parse_known_arg2[1];

      if (argv && argv.length > 0) {
        var msg = 'unrecognized arguments: %s';
        this.error(sub(msg, argv.join(' ')));
      }

      return args;
    }
  }, {
    key: "parse_known_args",
    value: function parse_known_args() {
      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (args === undefined) {
        args = get_argv().slice(1);
      } // default Namespace built from parser defaults


      if (namespace === undefined) {
        namespace = new Namespace();
      } // add any action defaults that aren't present


      var _iteratorNormalCompletion31 = true;
      var _didIteratorError31 = false;
      var _iteratorError31 = undefined;

      try {
        for (var _iterator31 = this._actions[Symbol.iterator](), _step31; !(_iteratorNormalCompletion31 = (_step31 = _iterator31.next()).done); _iteratorNormalCompletion31 = true) {
          var action = _step31.value;

          if (action.dest !== SUPPRESS) {
            if (!hasattr(namespace, action.dest)) {
              if (action["default"] !== SUPPRESS) {
                setattr(namespace, action.dest, action["default"]);
              }
            }
          }
        } // add any parser defaults that aren't present

      } catch (err) {
        _didIteratorError31 = true;
        _iteratorError31 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion31 && _iterator31["return"] != null) {
            _iterator31["return"]();
          }
        } finally {
          if (_didIteratorError31) {
            throw _iteratorError31;
          }
        }
      }

      for (var _i12 = 0, _Object$keys6 = Object.keys(this._defaults); _i12 < _Object$keys6.length; _i12++) {
        var dest = _Object$keys6[_i12];

        if (!hasattr(namespace, dest)) {
          setattr(namespace, dest, this._defaults[dest]);
        }
      } // parse the arguments and exit if there are any errors


      if (this.exit_on_error) {
        try {
          var _this$_parse_known_ar = this._parse_known_args(args, namespace);

          var _this$_parse_known_ar2 = _slicedToArray(_this$_parse_known_ar, 2);

          namespace = _this$_parse_known_ar2[0];
          args = _this$_parse_known_ar2[1];
        } catch (err) {
          if (err instanceof ArgumentError) {
            this.error(err.message);
          } else {
            throw err;
          }
        }
      } else {
        var _this$_parse_known_ar3 = this._parse_known_args(args, namespace);

        var _this$_parse_known_ar4 = _slicedToArray(_this$_parse_known_ar3, 2);

        namespace = _this$_parse_known_ar4[0];
        args = _this$_parse_known_ar4[1];
      }

      if (hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR)) {
        args = args.concat(getattr(namespace, _UNRECOGNIZED_ARGS_ATTR));
        delattr(namespace, _UNRECOGNIZED_ARGS_ATTR);
      }

      return [namespace, args];
    }
  }, {
    key: "_parse_known_args",
    value: function _parse_known_args(arg_strings, namespace) {
      var _this14 = this;

      // replace arg strings that are file references
      if (this.fromfile_prefix_chars !== undefined) {
        arg_strings = this._read_args_from_files(arg_strings);
      } // map all mutually exclusive arguments to the other arguments
      // they can't occur with


      var action_conflicts = new Map();
      var _iteratorNormalCompletion32 = true;
      var _didIteratorError32 = false;
      var _iteratorError32 = undefined;

      try {
        for (var _iterator32 = this._mutually_exclusive_groups[Symbol.iterator](), _step32; !(_iteratorNormalCompletion32 = (_step32 = _iterator32.next()).done); _iteratorNormalCompletion32 = true) {
          var mutex_group = _step32.value;
          var group_actions = mutex_group._group_actions;

          for (var _i14 = 0, _Object$entries4 = Object.entries(mutex_group._group_actions); _i14 < _Object$entries4.length; _i14++) {
            var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i14], 2),
                i = _Object$entries4$_i[0],
                mutex_action = _Object$entries4$_i[1];

            var conflicts = action_conflicts.get(mutex_action) || [];
            conflicts = conflicts.concat(group_actions.slice(0, +i));
            conflicts = conflicts.concat(group_actions.slice(+i + 1));
            action_conflicts.set(mutex_action, conflicts);
          }
        } // find all option indices, and determine the arg_string_pattern
        // which has an 'O' if there is an option at an index,
        // an 'A' if there is an argument, or a '-' if there is a '--'

      } catch (err) {
        _didIteratorError32 = true;
        _iteratorError32 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion32 && _iterator32["return"] != null) {
            _iterator32["return"]();
          }
        } finally {
          if (_didIteratorError32) {
            throw _iteratorError32;
          }
        }
      }

      var option_string_indices = {};
      var arg_string_pattern_parts = [];
      var arg_strings_iter = Object.entries(arg_strings)[Symbol.iterator]();
      var _iteratorNormalCompletion33 = true;
      var _didIteratorError33 = false;
      var _iteratorError33 = undefined;

      try {
        for (var _iterator33 = arg_strings_iter[Symbol.iterator](), _step33; !(_iteratorNormalCompletion33 = (_step33 = _iterator33.next()).done); _iteratorNormalCompletion33 = true) {
          var _step33$value = _slicedToArray(_step33.value, 2),
              _i15 = _step33$value[0],
              arg_string = _step33$value[1];

          // all args after -- are non-options
          if (arg_string === '--') {
            arg_string_pattern_parts.push('-');
            var _iteratorNormalCompletion37 = true;
            var _didIteratorError37 = false;
            var _iteratorError37 = undefined;

            try {
              for (var _iterator37 = arg_strings_iter[Symbol.iterator](), _step37; !(_iteratorNormalCompletion37 = (_step37 = _iterator37.next()).done); _iteratorNormalCompletion37 = true) {
                var _step37$value = _slicedToArray(_step37.value, 2);

                i = _step37$value[0];
                arg_string = _step37$value[1];
                arg_string_pattern_parts.push('A');
              } // otherwise, add the arg to the arg strings
              // and note the index if it was an option

            } catch (err) {
              _didIteratorError37 = true;
              _iteratorError37 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion37 && _iterator37["return"] != null) {
                  _iterator37["return"]();
                }
              } finally {
                if (_didIteratorError37) {
                  throw _iteratorError37;
                }
              }
            }
          } else {
            var option_tuple = this._parse_optional(arg_string);

            var pattern = void 0;

            if (option_tuple === undefined) {
              pattern = 'A';
            } else {
              option_string_indices[_i15] = option_tuple;
              pattern = 'O';
            }

            arg_string_pattern_parts.push(pattern);
          }
        } // join the pieces together to form the pattern

      } catch (err) {
        _didIteratorError33 = true;
        _iteratorError33 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion33 && _iterator33["return"] != null) {
            _iterator33["return"]();
          }
        } finally {
          if (_didIteratorError33) {
            throw _iteratorError33;
          }
        }
      }

      var arg_strings_pattern = arg_string_pattern_parts.join(''); // converts arg strings to the appropriate and then takes the action

      var seen_actions = new Set();
      var seen_non_default_actions = new Set();
      var extras;

      var take_action = function take_action(action, argument_strings) {
        var option_string = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
        seen_actions.add(action);

        var argument_values = _this14._get_values(action, argument_strings); // error if this argument is not allowed with other previously
        // seen arguments, assuming that actions that use the default
        // value don't really count as "present"


        if (argument_values !== action["default"]) {
          seen_non_default_actions.add(action);
          var _iteratorNormalCompletion34 = true;
          var _didIteratorError34 = false;
          var _iteratorError34 = undefined;

          try {
            for (var _iterator34 = (action_conflicts.get(action) || [])[Symbol.iterator](), _step34; !(_iteratorNormalCompletion34 = (_step34 = _iterator34.next()).done); _iteratorNormalCompletion34 = true) {
              var conflict_action = _step34.value;

              if (seen_non_default_actions.has(conflict_action)) {
                var msg = 'not allowed with argument %s';

                var action_name = _get_action_name(conflict_action);

                throw new ArgumentError(action, sub(msg, action_name));
              }
            }
          } catch (err) {
            _didIteratorError34 = true;
            _iteratorError34 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion34 && _iterator34["return"] != null) {
                _iterator34["return"]();
              }
            } finally {
              if (_didIteratorError34) {
                throw _iteratorError34;
              }
            }
          }
        } // take the action if we didn't receive a SUPPRESS value
        // (e.g. from a default)


        if (argument_values !== SUPPRESS) {
          action(_this14, namespace, argument_values, option_string);
        }
      }; // function to convert arg_strings into an optional action


      var consume_optional = function consume_optional(start_index) {
        // get the optional identified at this index
        var option_tuple = option_string_indices[start_index];

        var _option_tuple = _slicedToArray(option_tuple, 3),
            action = _option_tuple[0],
            option_string = _option_tuple[1],
            explicit_arg = _option_tuple[2]; // identify additional optionals in the same arg string
        // (e.g. -xyz is the same as -x -y -z if no args are required)


        var action_tuples = [];
        var stop;

        for (;;) {
          // if we found no optional action, skip it
          if (action === undefined) {
            extras.push(arg_strings[start_index]);
            return start_index + 1;
          } // if there is an explicit argument, try to match the
          // optional's string arguments to only this


          if (explicit_arg !== undefined) {
            var arg_count = _this14._match_argument(action, 'A'); // if the action is a single-dash option and takes no
            // arguments, try to parse more single-dash options out
            // of the tail of the option string


            var chars = _this14.prefix_chars;

            if (arg_count === 0 && !chars.includes(option_string[1])) {
              action_tuples.push([action, [], option_string]);
              var _char = option_string[0];
              option_string = _char + explicit_arg[0];
              var new_explicit_arg = explicit_arg.slice(1) || undefined;
              var optionals_map = _this14._option_string_actions;

              if (hasattr(optionals_map, option_string)) {
                action = optionals_map[option_string];
                explicit_arg = new_explicit_arg;
              } else {
                var msg = 'ignored explicit argument %r';
                throw new ArgumentError(action, sub(msg, explicit_arg));
              } // if the action expect exactly one argument, we've
              // successfully matched the option; exit the loop

            } else if (arg_count === 1) {
              stop = start_index + 1;
              var args = [explicit_arg];
              action_tuples.push([action, args, option_string]);
              break; // error if a double-dash option did not use the
              // explicit argument
            } else {
              var _msg3 = 'ignored explicit argument %r';
              throw new ArgumentError(action, sub(_msg3, explicit_arg));
            } // if there is no explicit argument, try to match the
            // optional's string arguments with the following strings
            // if successful, exit the loop

          } else {
            var start = start_index + 1;
            var selected_patterns = arg_strings_pattern.slice(start);

            var _arg_count = _this14._match_argument(action, selected_patterns);

            stop = start + _arg_count;

            var _args3 = arg_strings.slice(start, stop);

            action_tuples.push([action, _args3, option_string]);
            break;
          }
        } // add the Optional to the list and return the index at which
        // the Optional's string args stopped


        assert(action_tuples.length);

        for (var _i13 = 0, _action_tuples = action_tuples; _i13 < _action_tuples.length; _i13++) {
          var _action_tuples$_i = _slicedToArray(_action_tuples[_i13], 3),
              _action5 = _action_tuples$_i[0],
              _args4 = _action_tuples$_i[1],
              _option_string2 = _action_tuples$_i[2];

          take_action(_action5, _args4, _option_string2);
        }

        return stop;
      }; // the list of Positionals left to be parsed; this is modified
      // by consume_positionals()


      var positionals = this._get_positional_actions(); // function to convert arg_strings into positional actions


      var consume_positionals = function consume_positionals(start_index) {
        // match as many Positionals as possible
        var selected_pattern = arg_strings_pattern.slice(start_index);

        var arg_counts = _this14._match_arguments_partial(positionals, selected_pattern); // slice off the appropriate arg strings for each Positional
        // and add the Positional and its args to the list


        for (var i = 0; i < positionals.length && i < arg_counts.length; i++) {
          var action = positionals[i];
          var arg_count = arg_counts[i];
          var args = arg_strings.slice(start_index, start_index + arg_count);
          start_index += arg_count;
          take_action(action, args);
        } // slice off the Positionals that we just parsed and return the
        // index at which the Positionals' string args stopped


        positionals = positionals.slice(arg_counts.length);
        return start_index;
      }; // consume Positionals and Optionals alternately, until we have
      // passed the last option string


      extras = [];
      var start_index = 0;
      var max_option_string_index = Math.max.apply(Math, [-1].concat(_toConsumableArray(Object.keys(option_string_indices).map(Number))));

      while (start_index <= max_option_string_index) {
        // consume any Positionals preceding the next option
        var next_option_string_index = Math.min.apply(Math, _toConsumableArray(Object.keys(option_string_indices).map(Number).filter(function (index) {
          return index >= start_index;
        })));

        if (start_index !== next_option_string_index) {
          var positionals_end_index = consume_positionals(start_index); // only try to parse the next optional if we didn't consume
          // the option string during the positionals parsing

          if (positionals_end_index > start_index) {
            start_index = positionals_end_index;
            continue;
          } else {
            start_index = positionals_end_index;
          }
        } // if we consumed all the positionals we could and we're not
        // at the index of an option string, there were extra arguments


        if (!(start_index in option_string_indices)) {
          var strings = arg_strings.slice(start_index, next_option_string_index);
          extras = extras.concat(strings);
          start_index = next_option_string_index;
        } // consume the next optional and any arguments for it


        start_index = consume_optional(start_index);
      } // consume any positionals following the last Optional


      var stop_index = consume_positionals(start_index); // if we didn't consume all the argument strings, there were extras

      extras = extras.concat(arg_strings.slice(stop_index)); // make sure all required actions were present and also convert
      // action defaults which were not given as arguments

      var required_actions = [];
      var _iteratorNormalCompletion35 = true;
      var _didIteratorError35 = false;
      var _iteratorError35 = undefined;

      try {
        for (var _iterator35 = this._actions[Symbol.iterator](), _step35; !(_iteratorNormalCompletion35 = (_step35 = _iterator35.next()).done); _iteratorNormalCompletion35 = true) {
          var action = _step35.value;

          if (!seen_actions.has(action)) {
            if (action.required) {
              required_actions.push(_get_action_name(action));
            } else {
              // Convert action default now instead of doing it before
              // parsing arguments to avoid calling convert functions
              // twice (which may fail) if the argument was given, but
              // only if it was defined already in the namespace
              if (action["default"] !== undefined && typeof action["default"] === 'string' && hasattr(namespace, action.dest) && action["default"] === getattr(namespace, action.dest)) {
                setattr(namespace, action.dest, this._get_value(action, action["default"]));
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError35 = true;
        _iteratorError35 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion35 && _iterator35["return"] != null) {
            _iterator35["return"]();
          }
        } finally {
          if (_didIteratorError35) {
            throw _iteratorError35;
          }
        }
      }

      if (required_actions.length) {
        this.error(sub('the following arguments are required: %s', required_actions.join(', ')));
      } // make sure all required groups had one option present


      var _iteratorNormalCompletion36 = true;
      var _didIteratorError36 = false;
      var _iteratorError36 = undefined;

      try {
        for (var _iterator36 = this._mutually_exclusive_groups[Symbol.iterator](), _step36; !(_iteratorNormalCompletion36 = (_step36 = _iterator36.next()).done); _iteratorNormalCompletion36 = true) {
          var group = _step36.value;

          if (group.required) {
            var no_actions_used = true;
            var _iteratorNormalCompletion38 = true;
            var _didIteratorError38 = false;
            var _iteratorError38 = undefined;

            try {
              for (var _iterator38 = group._group_actions[Symbol.iterator](), _step38; !(_iteratorNormalCompletion38 = (_step38 = _iterator38.next()).done); _iteratorNormalCompletion38 = true) {
                var _action6 = _step38.value;

                if (seen_non_default_actions.has(_action6)) {
                  no_actions_used = false;
                  break;
                }
              } // if no actions were used, report the error

            } catch (err) {
              _didIteratorError38 = true;
              _iteratorError38 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion38 && _iterator38["return"] != null) {
                  _iterator38["return"]();
                }
              } finally {
                if (_didIteratorError38) {
                  throw _iteratorError38;
                }
              }
            }

            if (no_actions_used) {
              var names = group._group_actions.filter(function (action) {
                return action.help !== SUPPRESS;
              }).map(function (action) {
                return _get_action_name(action);
              });

              var msg = 'one of the arguments %s is required';
              this.error(sub(msg, names.join(' ')));
            }
          }
        } // return the updated namespace and the extra arguments

      } catch (err) {
        _didIteratorError36 = true;
        _iteratorError36 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion36 && _iterator36["return"] != null) {
            _iterator36["return"]();
          }
        } finally {
          if (_didIteratorError36) {
            throw _iteratorError36;
          }
        }
      }

      return [namespace, extras];
    }
  }, {
    key: "_read_args_from_files",
    value: function _read_args_from_files(arg_strings) {
      // expand arguments referencing files
      var new_arg_strings = [];
      var _iteratorNormalCompletion39 = true;
      var _didIteratorError39 = false;
      var _iteratorError39 = undefined;

      try {
        for (var _iterator39 = arg_strings[Symbol.iterator](), _step39; !(_iteratorNormalCompletion39 = (_step39 = _iterator39.next()).done); _iteratorNormalCompletion39 = true) {
          var arg_string = _step39.value;

          // for regular arguments, just add them back into the list
          if (!arg_string || !this.fromfile_prefix_chars.includes(arg_string[0])) {
            new_arg_strings.push(arg_string); // replace arguments referencing files with the file content
          } else {
            try {
              var args_file = fs.readFileSync(arg_string.slice(1), 'utf8');
              var _arg_strings = [];
              var _iteratorNormalCompletion40 = true;
              var _didIteratorError40 = false;
              var _iteratorError40 = undefined;

              try {
                for (var _iterator40 = splitlines(args_file)[Symbol.iterator](), _step40; !(_iteratorNormalCompletion40 = (_step40 = _iterator40.next()).done); _iteratorNormalCompletion40 = true) {
                  var arg_line = _step40.value;
                  var _iteratorNormalCompletion41 = true;
                  var _didIteratorError41 = false;
                  var _iteratorError41 = undefined;

                  try {
                    for (var _iterator41 = this.convert_arg_line_to_args(arg_line)[Symbol.iterator](), _step41; !(_iteratorNormalCompletion41 = (_step41 = _iterator41.next()).done); _iteratorNormalCompletion41 = true) {
                      var arg = _step41.value;

                      _arg_strings.push(arg);
                    }
                  } catch (err) {
                    _didIteratorError41 = true;
                    _iteratorError41 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion41 && _iterator41["return"] != null) {
                        _iterator41["return"]();
                      }
                    } finally {
                      if (_didIteratorError41) {
                        throw _iteratorError41;
                      }
                    }
                  }
                }
              } catch (err) {
                _didIteratorError40 = true;
                _iteratorError40 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion40 && _iterator40["return"] != null) {
                    _iterator40["return"]();
                  }
                } finally {
                  if (_didIteratorError40) {
                    throw _iteratorError40;
                  }
                }
              }

              _arg_strings = this._read_args_from_files(_arg_strings);
              new_arg_strings = new_arg_strings.concat(_arg_strings);
            } catch (err) {
              this.error(err.message);
            }
          }
        } // return the modified argument list

      } catch (err) {
        _didIteratorError39 = true;
        _iteratorError39 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion39 && _iterator39["return"] != null) {
            _iterator39["return"]();
          }
        } finally {
          if (_didIteratorError39) {
            throw _iteratorError39;
          }
        }
      }

      return new_arg_strings;
    }
  }, {
    key: "convert_arg_line_to_args",
    value: function convert_arg_line_to_args(arg_line) {
      return [arg_line];
    }
  }, {
    key: "_match_argument",
    value: function _match_argument(action, arg_strings_pattern) {
      // match the pattern for this action to the arg strings
      var nargs_pattern = this._get_nargs_pattern(action);

      var match = arg_strings_pattern.match(new RegExp('^' + nargs_pattern)); // raise an exception if we weren't able to find a match

      if (match === null) {
        var _nargs_errors;

        var nargs_errors = (_nargs_errors = {
          undefined: 'expected one argument'
        }, _defineProperty(_nargs_errors, OPTIONAL, 'expected at most one argument'), _defineProperty(_nargs_errors, ONE_OR_MORE, 'expected at least one argument'), _nargs_errors);
        var msg = nargs_errors[action.nargs];

        if (msg === undefined) {
          msg = sub(action.nargs === 1 ? 'expected %s argument' : 'expected %s arguments', action.nargs);
        }

        throw new ArgumentError(action, msg);
      } // return the number of arguments matched


      return match[1].length;
    }
  }, {
    key: "_match_arguments_partial",
    value: function _match_arguments_partial(actions, arg_strings_pattern) {
      var _this15 = this;

      // progressively shorten the actions list by slicing off the
      // final actions until we find a match
      var result = [];
      var _iteratorNormalCompletion42 = true;
      var _didIteratorError42 = false;
      var _iteratorError42 = undefined;

      try {
        for (var _iterator42 = range(actions.length, 0, -1)[Symbol.iterator](), _step42; !(_iteratorNormalCompletion42 = (_step42 = _iterator42.next()).done); _iteratorNormalCompletion42 = true) {
          var i = _step42.value;
          var actions_slice = actions.slice(0, i);
          var pattern = actions_slice.map(function (action) {
            return _this15._get_nargs_pattern(action);
          }).join('');
          var match = arg_strings_pattern.match(new RegExp('^' + pattern));

          if (match !== null) {
            result = result.concat(match.slice(1).map(function (string) {
              return string.length;
            }));
            break;
          }
        } // return the list of arg string counts

      } catch (err) {
        _didIteratorError42 = true;
        _iteratorError42 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion42 && _iterator42["return"] != null) {
            _iterator42["return"]();
          }
        } finally {
          if (_didIteratorError42) {
            throw _iteratorError42;
          }
        }
      }

      return result;
    }
  }, {
    key: "_parse_optional",
    value: function _parse_optional(arg_string) {
      // if it's an empty string, it was meant to be a positional
      if (!arg_string) {
        return undefined;
      } // if it doesn't start with a prefix, it was meant to be positional


      if (!this.prefix_chars.includes(arg_string[0])) {
        return undefined;
      } // if the option string is present in the parser, return the action


      if (arg_string in this._option_string_actions) {
        var action = this._option_string_actions[arg_string];
        return [action, arg_string, undefined];
      } // if it's just a single character, it was meant to be positional


      if (arg_string.length === 1) {
        return undefined;
      } // if the option string before the "=" is present, return the action


      if (arg_string.includes('=')) {
        var _string_split2 = _string_split(arg_string, '=', 1),
            _string_split3 = _slicedToArray(_string_split2, 2),
            option_string = _string_split3[0],
            explicit_arg = _string_split3[1];

        if (option_string in this._option_string_actions) {
          var _action7 = this._option_string_actions[option_string];
          return [_action7, option_string, explicit_arg];
        }
      } // search through all possible prefixes of the option string
      // and all actions in the parser for possible interpretations


      var option_tuples = this._get_option_tuples(arg_string); // if multiple actions match, the option string was ambiguous


      if (option_tuples.length > 1) {
        var options = option_tuples.map(function (_ref20) {
          var _ref21 = _slicedToArray(_ref20, 2),

          /*action*/
          option_string
          /*, explicit_arg*/
          = _ref21[1];

          return option_string;
        }).join(', ');
        var args = {
          option: arg_string,
          matches: options
        };
        var msg = 'ambiguous option: %(option)s could match %(matches)s';
        this.error(sub(msg, args)); // if exactly one action matched, this segmentation is good,
        // so return the parsed action
      } else if (option_tuples.length === 1) {
        var _option_tuples = _slicedToArray(option_tuples, 1),
            option_tuple = _option_tuples[0];

        return option_tuple;
      } // if it was not found as an option, but it looks like a negative
      // number, it was meant to be positional
      // unless there are negative-number-like options


      if (this._negative_number_matcher.test(arg_string)) {
        if (!this._has_negative_number_optionals.length) {
          return undefined;
        }
      } // if it contains a space, it was meant to be a positional


      if (arg_string.includes(' ')) {
        return undefined;
      } // it was meant to be an optional but there is no such option
      // in this parser (though it might be a valid option in a subparser)


      return [undefined, arg_string, undefined];
    }
  }, {
    key: "_get_option_tuples",
    value: function _get_option_tuples(option_string) {
      var result = []; // option strings starting with two prefix characters are only
      // split at the '='

      var chars = this.prefix_chars;

      if (chars.includes(option_string[0]) && chars.includes(option_string[1])) {
        if (this.allow_abbrev) {
          var option_prefix, explicit_arg;

          if (option_string.includes('=')) {
            var _string_split4 = _string_split(option_string, '=', 1);

            var _string_split5 = _slicedToArray(_string_split4, 2);

            option_prefix = _string_split5[0];
            explicit_arg = _string_split5[1];
          } else {
            option_prefix = option_string;
            explicit_arg = undefined;
          }

          for (var _i16 = 0, _Object$keys7 = Object.keys(this._option_string_actions); _i16 < _Object$keys7.length; _i16++) {
            var _option_string3 = _Object$keys7[_i16];

            if (_option_string3.startsWith(option_prefix)) {
              var action = this._option_string_actions[_option_string3];
              var tup = [action, _option_string3, explicit_arg];
              result.push(tup);
            }
          }
        } // single character options can be concatenated with their arguments
        // but multiple character options always have to have their argument
        // separate

      } else if (chars.includes(option_string[0]) && !chars.includes(option_string[1])) {
        var _option_prefix = option_string;
        var _explicit_arg = undefined;
        var short_option_prefix = option_string.slice(0, 2);
        var short_explicit_arg = option_string.slice(2);

        for (var _i17 = 0, _Object$keys8 = Object.keys(this._option_string_actions); _i17 < _Object$keys8.length; _i17++) {
          var _option_string4 = _Object$keys8[_i17];

          if (_option_string4 === short_option_prefix) {
            var _action8 = this._option_string_actions[_option_string4];
            var _tup3 = [_action8, _option_string4, short_explicit_arg];
            result.push(_tup3);
          } else if (_option_string4.startsWith(_option_prefix)) {
            var _action9 = this._option_string_actions[_option_string4];
            var _tup4 = [_action9, _option_string4, _explicit_arg];
            result.push(_tup4);
          }
        } // shouldn't ever get here

      } else {
        this.error(sub('unexpected option string: %s', option_string));
      } // return the collected option tuples


      return result;
    }
  }, {
    key: "_get_nargs_pattern",
    value: function _get_nargs_pattern(action) {
      // in all examples below, we have to allow for '--' args
      // which are represented as '-' in the pattern
      var nargs = action.nargs;
      var nargs_pattern; // the default (None) is assumed to be a single argument

      if (nargs === undefined) {
        nargs_pattern = '(-*A-*)'; // allow zero or one arguments
      } else if (nargs === OPTIONAL) {
        nargs_pattern = '(-*A?-*)'; // allow zero or more arguments
      } else if (nargs === ZERO_OR_MORE) {
        nargs_pattern = '(-*[A-]*)'; // allow one or more arguments
      } else if (nargs === ONE_OR_MORE) {
        nargs_pattern = '(-*A[A-]*)'; // allow any number of options or arguments
      } else if (nargs === REMAINDER) {
        nargs_pattern = '([-AO]*)'; // allow one argument followed by any number of options or arguments
      } else if (nargs === PARSER) {
        nargs_pattern = '(-*A[-AO]*)'; // suppress action, like nargs=0
      } else if (nargs === SUPPRESS) {
        nargs_pattern = '(-*-*)'; // all others should be integers
      } else {
        nargs_pattern = sub('(-*%s-*)', 'A'.repeat(nargs).split('').join('-*'));
      } // if this is an optional action, -- is not allowed


      if (action.option_strings.length) {
        nargs_pattern = nargs_pattern.replace(/-\*/g, '');
        nargs_pattern = nargs_pattern.replace(/-/g, '');
      } // return the pattern


      return nargs_pattern;
    } // ========================
    // Alt command line argument parsing, allowing free intermix
    // ========================

  }, {
    key: "parse_intermixed_args",
    value: function parse_intermixed_args() {
      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      var argv;

      var _this$parse_known_int = this.parse_known_intermixed_args(args, namespace);

      var _this$parse_known_int2 = _slicedToArray(_this$parse_known_int, 2);

      args = _this$parse_known_int2[0];
      argv = _this$parse_known_int2[1];

      if (argv.length) {
        var msg = 'unrecognized arguments: %s';
        this.error(sub(msg, argv.join(' ')));
      }

      return args;
    }
  }, {
    key: "parse_known_intermixed_args",
    value: function parse_known_intermixed_args() {
      var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      var namespace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      // returns a namespace and list of extras
      //
      // positional can be freely intermixed with optionals.  optionals are
      // first parsed with all positional arguments deactivated.  The 'extras'
      // are then parsed.  If the parser definition is incompatible with the
      // intermixed assumptions (e.g. use of REMAINDER, subparsers) a
      // TypeError is raised.
      //
      // positionals are 'deactivated' by setting nargs and default to
      // SUPPRESS.  This blocks the addition of that positional to the
      // namespace
      var extras;

      var positionals = this._get_positional_actions();

      var a = positionals.filter(function (action) {
        return [PARSER, REMAINDER].includes(action.nargs);
      });

      if (a.length) {
        throw new TypeError(sub('parse_intermixed_args: positional arg' + ' with nargs=%s', a[0].nargs));
      }

      var _iteratorNormalCompletion43 = true;
      var _didIteratorError43 = false;
      var _iteratorError43 = undefined;

      try {
        for (var _iterator43 = this._mutually_exclusive_groups[Symbol.iterator](), _step43; !(_iteratorNormalCompletion43 = (_step43 = _iterator43.next()).done); _iteratorNormalCompletion43 = true) {
          var _group4 = _step43.value;
          var _iteratorNormalCompletion51 = true;
          var _didIteratorError51 = false;
          var _iteratorError51 = undefined;

          try {
            for (var _iterator51 = _group4._group_actions[Symbol.iterator](), _step51; !(_iteratorNormalCompletion51 = (_step51 = _iterator51.next()).done); _iteratorNormalCompletion51 = true) {
              var _action14 = _step51.value;

              if (positionals.includes(_action14)) {
                throw new TypeError('parse_intermixed_args: positional in' + ' mutuallyExclusiveGroup');
              }
            }
          } catch (err) {
            _didIteratorError51 = true;
            _iteratorError51 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion51 && _iterator51["return"] != null) {
                _iterator51["return"]();
              }
            } finally {
              if (_didIteratorError51) {
                throw _iteratorError51;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError43 = true;
        _iteratorError43 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion43 && _iterator43["return"] != null) {
            _iterator43["return"]();
          }
        } finally {
          if (_didIteratorError43) {
            throw _iteratorError43;
          }
        }
      }

      var save_usage;

      try {
        save_usage = this.usage;
        var remaining_args;

        try {
          if (this.usage === undefined) {
            // capture the full usage for use in error messages
            this.usage = this.format_usage().slice(7);
          }

          var _iteratorNormalCompletion44 = true;
          var _didIteratorError44 = false;
          var _iteratorError44 = undefined;

          try {
            for (var _iterator44 = positionals[Symbol.iterator](), _step44; !(_iteratorNormalCompletion44 = (_step44 = _iterator44.next()).done); _iteratorNormalCompletion44 = true) {
              var action = _step44.value;
              // deactivate positionals
              action.save_nargs = action.nargs; // action.nargs = 0

              action.nargs = SUPPRESS;
              action.save_default = action["default"];
              action["default"] = SUPPRESS;
            }
          } catch (err) {
            _didIteratorError44 = true;
            _iteratorError44 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion44 && _iterator44["return"] != null) {
                _iterator44["return"]();
              }
            } finally {
              if (_didIteratorError44) {
                throw _iteratorError44;
              }
            }
          }

          var _this$parse_known_arg3 = this.parse_known_args(args, namespace);

          var _this$parse_known_arg4 = _slicedToArray(_this$parse_known_arg3, 2);

          namespace = _this$parse_known_arg4[0];
          remaining_args = _this$parse_known_arg4[1];
          var _iteratorNormalCompletion45 = true;
          var _didIteratorError45 = false;
          var _iteratorError45 = undefined;

          try {
            for (var _iterator45 = positionals[Symbol.iterator](), _step45; !(_iteratorNormalCompletion45 = (_step45 = _iterator45.next()).done); _iteratorNormalCompletion45 = true) {
              var _action10 = _step45.value;
              // remove the empty positional values from namespace
              var attr = getattr(namespace, _action10.dest);

              if (Array.isArray(attr) && attr.length === 0) {
                // eslint-disable-next-line no-console
                console.warn(sub('Do not expect %s in %s', _action10.dest, namespace));
                delattr(namespace, _action10.dest);
              }
            }
          } catch (err) {
            _didIteratorError45 = true;
            _iteratorError45 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion45 && _iterator45["return"] != null) {
                _iterator45["return"]();
              }
            } finally {
              if (_didIteratorError45) {
                throw _iteratorError45;
              }
            }
          }
        } finally {
          // restore nargs and usage before exiting
          var _iteratorNormalCompletion46 = true;
          var _didIteratorError46 = false;
          var _iteratorError46 = undefined;

          try {
            for (var _iterator46 = positionals[Symbol.iterator](), _step46; !(_iteratorNormalCompletion46 = (_step46 = _iterator46.next()).done); _iteratorNormalCompletion46 = true) {
              var _action11 = _step46.value;
              _action11.nargs = _action11.save_nargs;
              _action11["default"] = _action11.save_default;
            }
          } catch (err) {
            _didIteratorError46 = true;
            _iteratorError46 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion46 && _iterator46["return"] != null) {
                _iterator46["return"]();
              }
            } finally {
              if (_didIteratorError46) {
                throw _iteratorError46;
              }
            }
          }
        }

        var optionals = this._get_optional_actions();

        try {
          // parse positionals.  optionals aren't normally required, but
          // they could be, so make sure they aren't.
          var _iteratorNormalCompletion47 = true;
          var _didIteratorError47 = false;
          var _iteratorError47 = undefined;

          try {
            for (var _iterator47 = optionals[Symbol.iterator](), _step47; !(_iteratorNormalCompletion47 = (_step47 = _iterator47.next()).done); _iteratorNormalCompletion47 = true) {
              var _action12 = _step47.value;
              _action12.save_required = _action12.required;
              _action12.required = false;
            }
          } catch (err) {
            _didIteratorError47 = true;
            _iteratorError47 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion47 && _iterator47["return"] != null) {
                _iterator47["return"]();
              }
            } finally {
              if (_didIteratorError47) {
                throw _iteratorError47;
              }
            }
          }

          var _iteratorNormalCompletion48 = true;
          var _didIteratorError48 = false;
          var _iteratorError48 = undefined;

          try {
            for (var _iterator48 = this._mutually_exclusive_groups[Symbol.iterator](), _step48; !(_iteratorNormalCompletion48 = (_step48 = _iterator48.next()).done); _iteratorNormalCompletion48 = true) {
              var group = _step48.value;
              group.save_required = group.required;
              group.required = false;
            }
          } catch (err) {
            _didIteratorError48 = true;
            _iteratorError48 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion48 && _iterator48["return"] != null) {
                _iterator48["return"]();
              }
            } finally {
              if (_didIteratorError48) {
                throw _iteratorError48;
              }
            }
          }

          var _this$parse_known_arg5 = this.parse_known_args(remaining_args, namespace);

          var _this$parse_known_arg6 = _slicedToArray(_this$parse_known_arg5, 2);

          namespace = _this$parse_known_arg6[0];
          extras = _this$parse_known_arg6[1];
        } finally {
          // restore parser values before exiting
          var _iteratorNormalCompletion49 = true;
          var _didIteratorError49 = false;
          var _iteratorError49 = undefined;

          try {
            for (var _iterator49 = optionals[Symbol.iterator](), _step49; !(_iteratorNormalCompletion49 = (_step49 = _iterator49.next()).done); _iteratorNormalCompletion49 = true) {
              var _action13 = _step49.value;
              _action13.required = _action13.save_required;
            }
          } catch (err) {
            _didIteratorError49 = true;
            _iteratorError49 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion49 && _iterator49["return"] != null) {
                _iterator49["return"]();
              }
            } finally {
              if (_didIteratorError49) {
                throw _iteratorError49;
              }
            }
          }

          var _iteratorNormalCompletion50 = true;
          var _didIteratorError50 = false;
          var _iteratorError50 = undefined;

          try {
            for (var _iterator50 = this._mutually_exclusive_groups[Symbol.iterator](), _step50; !(_iteratorNormalCompletion50 = (_step50 = _iterator50.next()).done); _iteratorNormalCompletion50 = true) {
              var _group3 = _step50.value;
              _group3.required = _group3.save_required;
            }
          } catch (err) {
            _didIteratorError50 = true;
            _iteratorError50 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion50 && _iterator50["return"] != null) {
                _iterator50["return"]();
              }
            } finally {
              if (_didIteratorError50) {
                throw _iteratorError50;
              }
            }
          }
        }
      } finally {
        this.usage = save_usage;
      }

      return [namespace, extras];
    } // ========================
    // Value conversion methods
    // ========================

  }, {
    key: "_get_values",
    value: function _get_values(action, arg_strings) {
      var _this16 = this;

      // for everything but PARSER, REMAINDER args, strip out first '--'
      if (![PARSER, REMAINDER].includes(action.nargs)) {
        try {
          _array_remove(arg_strings, '--');
        } catch (err) {}
      }

      var value; // optional argument produces a default when not present

      if (!arg_strings.length && action.nargs === OPTIONAL) {
        if (action.option_strings.length) {
          value = action["const"];
        } else {
          value = action["default"];
        }

        if (typeof value === 'string') {
          value = this._get_value(action, value);

          this._check_value(action, value);
        } // when nargs='*' on a positional, if there were no command-line
        // args, use the default if it is anything other than None

      } else if (!arg_strings.length && action.nargs === ZERO_OR_MORE && !action.option_strings.length) {
        if (action["default"] !== undefined) {
          value = action["default"];
        } else {
          value = arg_strings;
        }

        this._check_value(action, value); // single argument or optional argument produces a single value

      } else if (arg_strings.length === 1 && [undefined, OPTIONAL].includes(action.nargs)) {
        var arg_string = arg_strings[0];
        value = this._get_value(action, arg_string);

        this._check_value(action, value); // REMAINDER arguments convert all values, checking none

      } else if (action.nargs === REMAINDER) {
        value = arg_strings.map(function (v) {
          return _this16._get_value(action, v);
        }); // PARSER arguments convert all values, but check only the first
      } else if (action.nargs === PARSER) {
        value = arg_strings.map(function (v) {
          return _this16._get_value(action, v);
        });

        this._check_value(action, value[0]); // SUPPRESS argument does not put anything in the namespace

      } else if (action.nargs === SUPPRESS) {
        value = SUPPRESS; // all other types of nargs produce a list
      } else {
        value = arg_strings.map(function (v) {
          return _this16._get_value(action, v);
        });
        var _iteratorNormalCompletion52 = true;
        var _didIteratorError52 = false;
        var _iteratorError52 = undefined;

        try {
          for (var _iterator52 = value[Symbol.iterator](), _step52; !(_iteratorNormalCompletion52 = (_step52 = _iterator52.next()).done); _iteratorNormalCompletion52 = true) {
            var v = _step52.value;

            this._check_value(action, v);
          }
        } catch (err) {
          _didIteratorError52 = true;
          _iteratorError52 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion52 && _iterator52["return"] != null) {
              _iterator52["return"]();
            }
          } finally {
            if (_didIteratorError52) {
              throw _iteratorError52;
            }
          }
        }
      } // return the converted value


      return value;
    }
  }, {
    key: "_get_value",
    value: function _get_value(action, arg_string) {
      var type_func = this._registry_get('type', action.type, action.type);

      if (typeof type_func !== 'function') {
        var msg = '%r is not callable';
        throw new ArgumentError(action, sub(msg, type_func));
      } // convert the value to the appropriate type


      var result;

      try {
        try {
          result = type_func(arg_string);
        } catch (err) {
          // Dear TC39, why would you ever consider making es6 classes not callable?
          // We had one universal interface, [[Call]], which worked for anything
          // (with familiar this-instanceof guard for classes). Now we have two.
          if (err instanceof TypeError && /Class constructor .* cannot be invoked without 'new'/.test(err.message)) {
            // eslint-disable-next-line new-cap
            result = new type_func(arg_string);
          } else {
            throw err;
          }
        }
      } catch (err) {
        // ArgumentTypeErrors indicate errors
        if (err instanceof ArgumentTypeError) {
          //let name = getattr(action.type, 'name', repr(action.type))
          var _msg4 = err.message;
          throw new ArgumentError(action, _msg4); // TypeErrors or ValueErrors also indicate errors
        } else if (err instanceof TypeError) {
          var name = getattr(action.type, 'name', repr(action.type));
          var args = {
            type: name,
            value: arg_string
          };
          var _msg5 = 'invalid %(type)s value: %(value)r';
          throw new ArgumentError(action, sub(_msg5, args));
        } else {
          throw err;
        }
      } // return the converted value


      return result;
    }
  }, {
    key: "_check_value",
    value: function _check_value(action, value) {
      // converted value must be one of the choices (if specified)
      if (action.choices !== undefined && !_choices_to_array(action.choices).includes(value)) {
        var args = {
          value: value,
          choices: _choices_to_array(action.choices).map(repr).join(', ')
        };
        var msg = 'invalid choice: %(value)r (choose from %(choices)s)';
        throw new ArgumentError(action, sub(msg, args));
      }
    } // =======================
    // Help-formatting methods
    // =======================

  }, {
    key: "format_usage",
    value: function format_usage() {
      var formatter = this._get_formatter();

      formatter.add_usage(this.usage, this._actions, this._mutually_exclusive_groups);
      return formatter.format_help();
    }
  }, {
    key: "format_help",
    value: function format_help() {
      var formatter = this._get_formatter(); // usage


      formatter.add_usage(this.usage, this._actions, this._mutually_exclusive_groups); // description

      formatter.add_text(this.description); // positionals, optionals and user-defined groups

      var _iteratorNormalCompletion53 = true;
      var _didIteratorError53 = false;
      var _iteratorError53 = undefined;

      try {
        for (var _iterator53 = this._action_groups[Symbol.iterator](), _step53; !(_iteratorNormalCompletion53 = (_step53 = _iterator53.next()).done); _iteratorNormalCompletion53 = true) {
          var action_group = _step53.value;
          formatter.start_section(action_group.title);
          formatter.add_text(action_group.description);
          formatter.add_arguments(action_group._group_actions);
          formatter.end_section();
        } // epilog

      } catch (err) {
        _didIteratorError53 = true;
        _iteratorError53 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion53 && _iterator53["return"] != null) {
            _iterator53["return"]();
          }
        } finally {
          if (_didIteratorError53) {
            throw _iteratorError53;
          }
        }
      }

      formatter.add_text(this.epilog); // determine help from format above

      return formatter.format_help();
    }
  }, {
    key: "_get_formatter",
    value: function _get_formatter() {
      // eslint-disable-next-line new-cap
      return new this.formatter_class({
        prog: this.prog
      });
    } // =====================
    // Help-printing methods
    // =====================

  }, {
    key: "print_usage",
    value: function print_usage() {
      var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      if (file === undefined) file = process.stdout;

      this._print_message(this.format_usage(), file);
    }
  }, {
    key: "print_help",
    value: function print_help() {
      var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;
      if (file === undefined) file = process.stdout;

      this._print_message(this.format_help(), file);
    }
  }, {
    key: "_print_message",
    value: function _print_message(message) {
      var file = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (message) {
        if (file === undefined) file = process.stderr;
        file.write(message);
      }
    } // ===============
    // Exiting methods
    // ===============

  }, {
    key: "exit",
    value: function exit() {
      var status = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      if (message) {
        this._print_message(message, process.stderr);
      }

      process.exit(status);
    }
  }, {
    key: "error",
    value: function error(message) {
      /*
       *  error(message: string)
       *
       *  Prints a usage message incorporating the message to stderr and
       *  exits.
       *
       *  If you override this in a subclass, it should not return -- it
       *  should either exit or raise an exception.
       */
      // LEGACY (v1 compatibility), debug mode
      if (this.debug === true) throw new Error(message); // end

      this.print_usage(process.stderr);
      var args = {
        prog: this.prog,
        message: message
      };
      this.exit(2, sub('%(prog)s: error: %(message)s\n', args));
    }
  }]);

  return ArgumentParser;
}(_AttributeHolder(_ActionsContainer))));

module.exports = {
  ArgumentParser: ArgumentParser,
  ArgumentError: ArgumentError,
  ArgumentTypeError: ArgumentTypeError,
  BooleanOptionalAction: BooleanOptionalAction,
  FileType: FileType,
  HelpFormatter: HelpFormatter,
  ArgumentDefaultsHelpFormatter: ArgumentDefaultsHelpFormatter,
  RawDescriptionHelpFormatter: RawDescriptionHelpFormatter,
  RawTextHelpFormatter: RawTextHelpFormatter,
  MetavarTypeHelpFormatter: MetavarTypeHelpFormatter,
  Namespace: Namespace,
  Action: Action,
  ONE_OR_MORE: ONE_OR_MORE,
  OPTIONAL: OPTIONAL,
  PARSER: PARSER,
  REMAINDER: REMAINDER,
  SUPPRESS: SUPPRESS,
  ZERO_OR_MORE: ZERO_OR_MORE
}; // LEGACY (v1 compatibility), Const alias

Object.defineProperty(module.exports, 'Const', {
  get: function get() {
    var result = {};
    Object.entries({
      ONE_OR_MORE: ONE_OR_MORE,
      OPTIONAL: OPTIONAL,
      PARSER: PARSER,
      REMAINDER: REMAINDER,
      SUPPRESS: SUPPRESS,
      ZERO_OR_MORE: ZERO_OR_MORE
    }).forEach(function (_ref22) {
      var _ref23 = _slicedToArray(_ref22, 2),
          n = _ref23[0],
          v = _ref23[1];

      Object.defineProperty(result, n, {
        get: function get() {
          deprecate(n, sub('use argparse.%s instead of argparse.Const.%s', n, n));
          return v;
        }
      });
    });
    Object.entries({
      _UNRECOGNIZED_ARGS_ATTR: _UNRECOGNIZED_ARGS_ATTR
    }).forEach(function (_ref24) {
      var _ref25 = _slicedToArray(_ref24, 2),
          n = _ref25[0],
          v = _ref25[1];

      Object.defineProperty(result, n, {
        get: function get() {
          deprecate(n, sub('argparse.Const.%s is an internal symbol and will no longer be available', n));
          return v;
        }
      });
    });
    return result;
  },
  enumerable: false
}); // end