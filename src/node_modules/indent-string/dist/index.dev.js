"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = indentString;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function indentString(string) {
  var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _options$indent = options.indent,
      indent = _options$indent === void 0 ? ' ' : _options$indent,
      _options$includeEmpty = options.includeEmptyLines,
      includeEmptyLines = _options$includeEmpty === void 0 ? false : _options$includeEmpty;

  if (typeof string !== 'string') {
    throw new TypeError("Expected `input` to be a `string`, got `".concat(_typeof(string), "`"));
  }

  if (typeof count !== 'number') {
    throw new TypeError("Expected `count` to be a `number`, got `".concat(_typeof(count), "`"));
  }

  if (count < 0) {
    throw new RangeError("Expected `count` to be at least 0, got `".concat(count, "`"));
  }

  if (typeof indent !== 'string') {
    throw new TypeError("Expected `options.indent` to be a `string`, got `".concat(_typeof(indent), "`"));
  }

  if (count === 0) {
    return string;
  }

  var regex = includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
  return string.replace(regex, indent.repeat(count));
}