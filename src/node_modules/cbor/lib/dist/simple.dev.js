'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('./constants'),
    MT = _require.MT,
    SIMPLE = _require.SIMPLE,
    SYMS = _require.SYMS;
/**
 * A CBOR Simple Value that does not map onto a known constant.
 */


var Simple =
/*#__PURE__*/
function () {
  /**
   * Creates an instance of Simple.
   *
   * @param {number} value The simple value's integer value.
   */
  function Simple(value) {
    _classCallCheck(this, Simple);

    if (typeof value !== 'number') {
      throw new Error("Invalid Simple type: ".concat(_typeof(value)));
    }

    if (value < 0 || value > 255 || (value | 0) !== value) {
      throw new Error("value must be a small positive integer: ".concat(value));
    }

    this.value = value;
  }
  /**
   * Debug string for simple value.
   *
   * @returns {string} Formated string of `simple(value)`.
   */


  _createClass(Simple, [{
    key: "toString",
    value: function toString() {
      return "simple(".concat(this.value, ")");
    }
    /**
     * Debug string for simple value.
     *
     * @param {number} depth How deep are we?
     * @param {object} opts Options.
     * @returns {string} Formatted string of `simple(value)`.
     */

  }, {
    key: Symbol["for"]('nodejs.util.inspect.custom'),
    value: function value(depth, opts) {
      return "simple(".concat(this.value, ")");
    }
    /**
     * Push the simple value onto the CBOR stream.
     *
     * @param {object} gen The generator to push onto.
     * @returns {boolean} True on success.
     */

  }, {
    key: "encodeCBOR",
    value: function encodeCBOR(gen) {
      return gen._pushInt(this.value, MT.SIMPLE_FLOAT);
    }
    /**
     * Is the given object a Simple?
     *
     * @param {any} obj Object to test.
     * @returns {boolean} Is it Simple?
     */

  }], [{
    key: "isSimple",
    value: function isSimple(obj) {
      return obj instanceof Simple;
    }
    /**
     * Decode from the CBOR additional information into a JavaScript value.
     * If the CBOR item has no parent, return a "safe" symbol instead of
     * `null` or `undefined`, so that the value can be passed through a
     * stream in object mode.
     *
     * @param {number} val The CBOR additional info to convert.
     * @param {boolean} [has_parent=true] Does the CBOR item have a parent?
     * @param {boolean} [parent_indefinite=false] Is the parent element
     *   indefinitely encoded?
     * @returns {(null|undefined|boolean|symbol|Simple)} The decoded value.
     * @throws {Error} Invalid BREAK.
     */

  }, {
    key: "decode",
    value: function decode(val) {
      var has_parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var parent_indefinite = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      switch (val) {
        case SIMPLE.FALSE:
          return false;

        case SIMPLE.TRUE:
          return true;

        case SIMPLE.NULL:
          if (has_parent) {
            return null;
          }

          return SYMS.NULL;

        case SIMPLE.UNDEFINED:
          if (has_parent) {
            return undefined;
          }

          return SYMS.UNDEFINED;

        case -1:
          if (!has_parent || !parent_indefinite) {
            throw new Error('Invalid BREAK');
          }

          return SYMS.BREAK;

        default:
          return new Simple(val);
      }
    }
  }]);

  return Simple;
}();

module.exports = Simple;