'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var BinaryParseStream = require('../vendor/binary-parse-stream');

var Tagged = require('./tagged');

var Simple = require('./simple');

var utils = require('./utils');

var NoFilter = require('nofilter');

var stream = require('stream');

var constants = require('./constants');

var MT = constants.MT,
    NUMBYTES = constants.NUMBYTES,
    SYMS = constants.SYMS,
    BI = constants.BI;

var _require = require('buffer'),
    Buffer = _require.Buffer;

var COUNT = Symbol('count');
var MAJOR = Symbol('major type');
var ERROR = Symbol('error');
var NOT_FOUND = Symbol('not found');

function parentArray(parent, typ, count) {
  var a = [];
  a[COUNT] = count;
  a[SYMS.PARENT] = parent;
  a[MAJOR] = typ;
  return a;
}

function parentBufferStream(parent, typ) {
  var b = new NoFilter();
  b[COUNT] = -1;
  b[SYMS.PARENT] = parent;
  b[MAJOR] = typ;
  return b;
}

var UnexpectedDataError =
/*#__PURE__*/
function (_Error) {
  _inherits(UnexpectedDataError, _Error);

  function UnexpectedDataError(_byte, value) {
    var _this;

    _classCallCheck(this, UnexpectedDataError);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(UnexpectedDataError).call(this, "Unexpected data: 0x".concat(_byte.toString(16))));
    _this.name = 'UnexpectedDataError';
    _this["byte"] = _byte;
    _this.value = value;
    return _this;
  }

  return UnexpectedDataError;
}(_wrapNativeSuper(Error));
/**
 * Things that can act as inputs, from which a NoFilter can be created.
 *
 * @typedef {string|Buffer|ArrayBuffer|Uint8Array|Uint8ClampedArray
 *   |DataView|stream.Readable} BufferLike
 */

/**
 * @typedef ExtendedResults
 * @property {any} value The value that was found.
 * @property {number} length The number of bytes of the original input that
 *   were read.
 * @property {Buffer} bytes The bytes of the original input that were used
 *   to produce the value.
 * @property {Buffer} [unused] The bytes that were left over from the original
 *   input.  This property only exists if {@linkcode Decoder.decodeFirst} or
 *   {@linkcode Decoder.decodeFirstSync} was called.
 */

/**
 * @typedef DecoderOptions
 * @property {number} [max_depth=-1] The maximum depth to parse.
 *   Use -1 for "until you run out of memory".  Set this to a finite
 *   positive number for un-trusted inputs.  Most standard inputs won't nest
 *   more than 100 or so levels; I've tested into the millions before
 *   running out of memory.
 * @property {Tagged.TagMap} [tags] Mapping from tag number to function(v),
 *   where v is the decoded value that comes after the tag, and where the
 *   function returns the correctly-created value for that tag.
 * @property {boolean} [preferMap=false] If true, prefer to generate Map
 *   instances to plain objects, even if there are no entries in the map
 *   or if all of the keys are strings.
 * @property {boolean} [preferWeb=false] If true, prefer Uint8Arrays to
 *   be generated instead of node Buffers.  This might turn on some more
 *   changes in the future, so forward-compatibility is not guaranteed yet.
 * @property {BufferEncoding} [encoding='hex'] The encoding of the input.
 *   Ignored if input is a Buffer.
 * @property {boolean} [required=false] Should an error be thrown when no
 *   data is in the input?
 * @property {boolean} [extendedResults=false] If true, emit extended
 *   results, which will be an object with shape {@link ExtendedResults}.
 *   The value will already have been null-checked.
 * @property {boolean} [preventDuplicateKeys=false] If true, error is
 *   thrown if a map has duplicate keys.
 */

/**
 * @callback decodeCallback
 * @param {Error} [error] If one was generated.
 * @param {any} [value] The decoded value.
 * @returns {void}
 */

/**
 * @param {DecoderOptions|decodeCallback|string} opts Options,
 *   the callback, or input incoding.
 * @param {decodeCallback} [cb] Called on completion.
 * @returns {{options: DecoderOptions, cb: decodeCallback}} Normalized.
 * @throws {TypeError} On unknown option type.
 * @private
 */


function normalizeOptions(opts, cb) {
  switch (_typeof(opts)) {
    case 'function':
      return {
        options: {},
        cb:
        /** @type {decodeCallback} */
        opts
      };

    case 'string':
      return {
        options: {
          encoding:
          /** @type {BufferEncoding} */
          opts
        },
        cb: cb
      };

    case 'object':
      return {
        options: opts || {},
        cb: cb
      };

    default:
      throw new TypeError('Unknown option type');
  }
}
/**
 * Decode a stream of CBOR bytes by transforming them into equivalent
 * JavaScript data.  Because of the limitations of Node object streams,
 * special symbols are emitted instead of NULL or UNDEFINED.  Fix those
 * up by calling {@link Decoder.nullcheck}.
 *
 * @extends BinaryParseStream
 */


var Decoder =
/*#__PURE__*/
function (_BinaryParseStream) {
  _inherits(Decoder, _BinaryParseStream);

  /**
   * Create a parsing stream.
   *
   * @param {DecoderOptions} [options={}] Options.
   */
  function Decoder() {
    var _this2;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Decoder);

    var _options$tags = options.tags,
        tags = _options$tags === void 0 ? {} : _options$tags,
        _options$max_depth = options.max_depth,
        max_depth = _options$max_depth === void 0 ? -1 : _options$max_depth,
        _options$preferMap = options.preferMap,
        preferMap = _options$preferMap === void 0 ? false : _options$preferMap,
        _options$preferWeb = options.preferWeb,
        preferWeb = _options$preferWeb === void 0 ? false : _options$preferWeb,
        _options$required = options.required,
        required = _options$required === void 0 ? false : _options$required,
        _options$encoding = options.encoding,
        encoding = _options$encoding === void 0 ? 'hex' : _options$encoding,
        _options$extendedResu = options.extendedResults,
        extendedResults = _options$extendedResu === void 0 ? false : _options$extendedResu,
        _options$preventDupli = options.preventDuplicateKeys,
        preventDuplicateKeys = _options$preventDupli === void 0 ? false : _options$preventDupli,
        superOpts = _objectWithoutProperties(options, ["tags", "max_depth", "preferMap", "preferWeb", "required", "encoding", "extendedResults", "preventDuplicateKeys"]);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Decoder).call(this, _objectSpread({
      defaultEncoding: encoding
    }, superOpts)));
    _this2.running = true;
    _this2.max_depth = max_depth;
    _this2.tags = tags;
    _this2.preferMap = preferMap;
    _this2.preferWeb = preferWeb;
    _this2.extendedResults = extendedResults;
    _this2.required = required;
    _this2.preventDuplicateKeys = preventDuplicateKeys;

    if (extendedResults) {
      _this2.bs.on('read', _this2._onRead.bind(_assertThisInitialized(_this2)));

      _this2.valueBytes =
      /** @type {NoFilter} */
      new NoFilter();
    }

    return _this2;
  }
  /**
   * Check the given value for a symbol encoding a NULL or UNDEFINED value in
   * the CBOR stream.
   *
   * @param {any} val The value to check.
   * @returns {any} The corrected value.
   * @throws {Error} Nothing was found.
   * @static
   * @example
   * myDecoder.on('data', val => {
   *   val = Decoder.nullcheck(val)
   *   // ...
   * })
   */


  _createClass(Decoder, [{
    key: "close",

    /**
     * Stop processing.
     */
    value: function close() {
      this.running = false;
      this.__fresh = true;
    }
    /**
     * Only called if extendedResults is true.
     *
     * @ignore
     */

  }, {
    key: "_onRead",
    value: function _onRead(data) {
      this.valueBytes.write(data);
    }
    /**
     * @returns {Generator<number, any, Buffer>} Yields a number of bytes,
     *   returns anything, next returns a Buffer.
     * @throws {Error} Maximum depth exceeded.
     * @yields {number} Number of bytes to read.
     * @ignore
     */

  }, {
    key: "_parse",
    value:
    /*#__PURE__*/
    regeneratorRuntime.mark(function _parse() {
      var parent, depth, val, _ref, _ref2, octet, mt, ai, parent_major, parent_length, _ref3, _ref4, numbytes, buf, hasParent, again, pm, allstrings, i, len, _i2, _len, _i3, _len2, t, old, bytes, ret;

      return regeneratorRuntime.wrap(function _parse$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              parent = null;
              depth = 0;
              val = null;

            case 3:
              if (!true) {
                _context.next = 183;
                break;
              }

              if (!(this.max_depth >= 0 && depth > this.max_depth)) {
                _context.next = 6;
                break;
              }

              throw new Error("Maximum depth ".concat(this.max_depth, " exceeded"));

            case 6:
              _context.next = 8;
              return 1;

            case 8:
              _ref = _context.sent;
              _ref2 = _slicedToArray(_ref, 1);
              octet = _ref2[0];

              if (this.running) {
                _context.next = 14;
                break;
              }

              this.bs.unshift(Buffer.from([octet]));
              throw new UnexpectedDataError(octet);

            case 14:
              mt = octet >> 5;
              ai = octet & 0x1f;
              parent_major = parent == null ? undefined : parent[MAJOR];
              parent_length = parent == null ? undefined : parent.length;
              _context.t0 = ai;
              _context.next = _context.t0 === NUMBYTES.ONE ? 21 : _context.t0 === NUMBYTES.TWO ? 28 : _context.t0 === NUMBYTES.FOUR ? 28 : _context.t0 === NUMBYTES.EIGHT ? 28 : _context.t0 === 28 ? 35 : _context.t0 === 29 ? 35 : _context.t0 === 30 ? 35 : _context.t0 === NUMBYTES.INDEFINITE ? 37 : 43;
              break;

            case 21:
              this.emit('more-bytes', mt, 1, parent_major, parent_length);
              _context.next = 24;
              return 1;

            case 24:
              _ref3 = _context.sent;
              _ref4 = _slicedToArray(_ref3, 1);
              val = _ref4[0];
              return _context.abrupt("break", 44);

            case 28:
              numbytes = 1 << ai - 24;
              this.emit('more-bytes', mt, numbytes, parent_major, parent_length);
              _context.next = 32;
              return numbytes;

            case 32:
              buf = _context.sent;
              val = mt === MT.SIMPLE_FLOAT ? buf : utils.parseCBORint(ai, buf);
              return _context.abrupt("break", 44);

            case 35:
              this.running = false;
              throw new Error("Additional info not implemented: ".concat(ai));

            case 37:
              _context.t1 = mt;
              _context.next = _context.t1 === MT.POS_INT ? 40 : _context.t1 === MT.NEG_INT ? 40 : _context.t1 === MT.TAG ? 40 : 41;
              break;

            case 40:
              throw new Error("Invalid indefinite encoding for MT ".concat(mt));

            case 41:
              val = -1;
              return _context.abrupt("break", 44);

            case 43:
              val = ai;

            case 44:
              _context.t2 = mt;
              _context.next = _context.t2 === MT.POS_INT ? 47 : _context.t2 === MT.NEG_INT ? 48 : _context.t2 === MT.BYTE_STRING ? 50 : _context.t2 === MT.UTF8_STRING ? 50 : _context.t2 === MT.ARRAY ? 66 : _context.t2 === MT.MAP ? 66 : _context.t2 === MT.TAG ? 80 : _context.t2 === MT.SIMPLE_FLOAT ? 85 : 93;
              break;

            case 47:
              return _context.abrupt("break", 93);

            case 48:
              if (val === Number.MAX_SAFE_INTEGER) {
                val = BI.NEG_MAX;
              } else {
                val = typeof val === 'bigint' ? BI.MINUS_ONE - val : -1 - val;
              }

              return _context.abrupt("break", 93);

            case 50:
              _context.t3 = val;
              _context.next = _context.t3 === 0 ? 53 : _context.t3 === -1 ? 56 : 60;
              break;

            case 53:
              this.emit('start-string', mt, val, parent_major, parent_length);

              if (mt === MT.UTF8_STRING) {
                val = '';
              } else {
                val = this.preferWeb ? new Uint8Array(0) : Buffer.allocUnsafe(0);
              }

              return _context.abrupt("break", 65);

            case 56:
              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);
              parent = parentBufferStream(parent, mt);
              depth++;
              return _context.abrupt("continue", 3);

            case 60:
              this.emit('start-string', mt, val, parent_major, parent_length);
              _context.next = 63;
              return val;

            case 63:
              val = _context.sent;

              if (mt === MT.UTF8_STRING) {
                val = utils.utf8(val);
              } else if (this.preferWeb) {
                val = new Uint8Array(val.buffer, val.byteOffset, val.length);
              }

            case 65:
              return _context.abrupt("break", 93);

            case 66:
              _context.t4 = val;
              _context.next = _context.t4 === 0 ? 69 : _context.t4 === -1 ? 71 : 75;
              break;

            case 69:
              if (mt === MT.MAP) {
                val = this.preferMap ? new Map() : {};
              } else {
                val = [];
              }

              return _context.abrupt("break", 79);

            case 71:
              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);
              parent = parentArray(parent, mt, -1);
              depth++;
              return _context.abrupt("continue", 3);

            case 75:
              this.emit('start', mt, val, parent_major, parent_length);
              parent = parentArray(parent, mt, val * (mt - 3));
              depth++;
              return _context.abrupt("continue", 3);

            case 79:
              return _context.abrupt("break", 93);

            case 80:
              this.emit('start', mt, val, parent_major, parent_length);
              parent = parentArray(parent, mt, 1);
              parent.push(val);
              depth++;
              return _context.abrupt("continue", 3);

            case 85:
              if (!(typeof val === 'number')) {
                _context.next = 92;
                break;
              }

              if (!(ai === NUMBYTES.ONE && val < 32)) {
                _context.next = 88;
                break;
              }

              throw new Error("Invalid two-byte encoding of simple value ".concat(val));

            case 88:
              hasParent = parent != null;
              val = Simple.decode(val, hasParent, hasParent && parent[COUNT] < 0);
              _context.next = 93;
              break;

            case 92:
              val = utils.parseCBORfloat(val);

            case 93:
              this.emit('value', val, parent_major, parent_length, ai);
              again = false;

            case 95:
              if (!(parent != null)) {
                _context.next = 174;
                break;
              }

              if (!(val === SYMS.BREAK)) {
                _context.next = 100;
                break;
              }

              parent[COUNT] = 1;
              _context.next = 109;
              break;

            case 100:
              if (!Array.isArray(parent)) {
                _context.next = 104;
                break;
              }

              parent.push(val);
              _context.next = 109;
              break;

            case 104:
              // Assert: parent instanceof NoFilter
              pm = parent[MAJOR];

              if (!(pm != null && pm !== mt)) {
                _context.next = 108;
                break;
              }

              this.running = false;
              throw new Error('Invalid major type in indefinite encoding');

            case 108:
              parent.write(val);

            case 109:
              if (!(--parent[COUNT] !== 0)) {
                _context.next = 112;
                break;
              }

              again = true;
              return _context.abrupt("break", 174);

            case 112:
              --depth;
              delete parent[COUNT];

              if (!Array.isArray(parent)) {
                _context.next = 158;
                break;
              }

              _context.t5 = parent[MAJOR];
              _context.next = _context.t5 === MT.ARRAY ? 118 : _context.t5 === MT.MAP ? 120 : _context.t5 === MT.TAG ? 153 : 156;
              break;

            case 118:
              val = parent;
              return _context.abrupt("break", 156);

            case 120:
              allstrings = !this.preferMap;

              if (!(parent.length % 2 !== 0)) {
                _context.next = 123;
                break;
              }

              throw new Error("Invalid map length: ".concat(parent.length));

            case 123:
              i = 0, len = parent.length;

            case 124:
              if (!(allstrings && i < len)) {
                _context.next = 131;
                break;
              }

              if (!(typeof parent[i] !== 'string' || parent[i] === '__proto__')) {
                _context.next = 128;
                break;
              }

              allstrings = false;
              return _context.abrupt("break", 131);

            case 128:
              i += 2;
              _context.next = 124;
              break;

            case 131:
              if (!allstrings) {
                _context.next = 143;
                break;
              }

              val = {};
              _i2 = 0, _len = parent.length;

            case 134:
              if (!(_i2 < _len)) {
                _context.next = 141;
                break;
              }

              if (!(this.preventDuplicateKeys && Object.prototype.hasOwnProperty.call(val, parent[_i2]))) {
                _context.next = 137;
                break;
              }

              throw new Error('Duplicate keys in a map');

            case 137:
              val[parent[_i2]] = parent[_i2 + 1];

            case 138:
              _i2 += 2;
              _context.next = 134;
              break;

            case 141:
              _context.next = 152;
              break;

            case 143:
              val = new Map();
              _i3 = 0, _len2 = parent.length;

            case 145:
              if (!(_i3 < _len2)) {
                _context.next = 152;
                break;
              }

              if (!(this.preventDuplicateKeys && val.has(parent[_i3]))) {
                _context.next = 148;
                break;
              }

              throw new Error('Duplicate keys in a map');

            case 148:
              val.set(parent[_i3], parent[_i3 + 1]);

            case 149:
              _i3 += 2;
              _context.next = 145;
              break;

            case 152:
              return _context.abrupt("break", 156);

            case 153:
              t = new Tagged(parent[0], parent[1]);
              val = t.convert(this.tags);
              return _context.abrupt("break", 156);

            case 156:
              _context.next = 167;
              break;

            case 158:
              if (!(parent instanceof NoFilter)) {
                _context.next = 167;
                break;
              }

              _context.t6 = parent[MAJOR];
              _context.next = _context.t6 === MT.BYTE_STRING ? 162 : _context.t6 === MT.UTF8_STRING ? 165 : 167;
              break;

            case 162:
              val = parent.slice();

              if (this.preferWeb) {
                val = new Uint8Array(
                /** @type {Buffer} */
                val.buffer,
                /** @type {Buffer} */
                val.byteOffset,
                /** @type {Buffer} */
                val.length);
              }

              return _context.abrupt("break", 167);

            case 165:
              val = parent.toString('utf-8');
              return _context.abrupt("break", 167);

            case 167:
              this.emit('stop', parent[MAJOR]);
              old = parent;
              parent = parent[SYMS.PARENT];
              delete old[SYMS.PARENT];
              delete old[MAJOR];
              _context.next = 95;
              break;

            case 174:
              if (again) {
                _context.next = 181;
                break;
              }

              if (!this.extendedResults) {
                _context.next = 180;
                break;
              }

              bytes = this.valueBytes.slice();
              ret = {
                value: Decoder.nullcheck(val),
                bytes: bytes,
                length: bytes.length
              };
              this.valueBytes = new NoFilter();
              return _context.abrupt("return", ret);

            case 180:
              return _context.abrupt("return", val);

            case 181:
              _context.next = 3;
              break;

            case 183:
            case "end":
              return _context.stop();
          }
        }
      }, _parse, this);
    })
  }], [{
    key: "nullcheck",
    value: function nullcheck(val) {
      switch (val) {
        case SYMS.NULL:
          return null;

        case SYMS.UNDEFINED:
          return undefined;
        // Leaving this in for now as belt-and-suspenders, but I'm pretty sure
        // it can't happen.

        /* istanbul ignore next */

        case NOT_FOUND:
          /* istanbul ignore next */
          throw new Error('Value not found');

        default:
          return val;
      }
    }
    /**
     * Decode the first CBOR item in the input, synchronously.  This will throw
     * an exception if the input is not valid CBOR, or if there are more bytes
     * left over at the end (if options.extendedResults is not true).
     *
     * @param {BufferLike} input If a Readable stream, must have
     *   received the `readable` event already, or you will get an error
     *   claiming "Insufficient data".
     * @param {DecoderOptions|string} [options={}] Options or encoding for input.
     * @returns {ExtendedResults|any} The decoded value.
     * @throws {UnexpectedDataError} Data is left over after decoding.
     * @throws {Error} Insufficient data.
     * @static
     */

  }, {
    key: "decodeFirstSync",
    value: function decodeFirstSync(input) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (input == null) {
        throw new TypeError('input required');
      }

      var _normalizeOptions = normalizeOptions(options);

      options = _normalizeOptions.options;

      var _options = options,
          _options$encoding2 = _options.encoding,
          encoding = _options$encoding2 === void 0 ? 'hex' : _options$encoding2,
          opts = _objectWithoutProperties(_options, ["encoding"]);

      var c = new Decoder(opts);
      var s = utils.guessEncoding(input, encoding); // For/of doesn't work when you need to call next() with a value
      // generator created by parser will be "done" after each CBOR entity
      // parser will yield numbers of bytes that it wants

      var parser = c._parse();

      var state = parser.next();

      while (!state.done) {
        var b = s.read(state.value);

        if (b == null || b.length !== state.value) {
          throw new Error('Insufficient data');
        }

        if (c.extendedResults) {
          c.valueBytes.write(b);
        }

        state = parser.next(b);
      }

      var val = null;

      if (c.extendedResults) {
        val = state.value;
        val.unused = s.read();
      } else {
        val = Decoder.nullcheck(state.value);

        if (s.length > 0) {
          var nextByte = s.read(1);
          s.unshift(nextByte);
          throw new UnexpectedDataError(nextByte[0], val);
        }
      }

      return val;
    }
    /**
     * Decode all of the CBOR items in the input into an array.  This will throw
     * an exception if the input is not valid CBOR; a zero-length input will
     * return an empty array.
     *
     * @param {BufferLike} input What to parse?
     * @param {DecoderOptions|string} [options={}] Options or encoding
     *   for input.
     * @returns {Array<ExtendedResults>|Array<any>} Array of all found items.
     * @throws {TypeError} No input provided.
     * @throws {Error} Insufficient data provided.
     * @static
     */

  }, {
    key: "decodeAllSync",
    value: function decodeAllSync(input) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (input == null) {
        throw new TypeError('input required');
      }

      var _normalizeOptions2 = normalizeOptions(options);

      options = _normalizeOptions2.options;

      var _options2 = options,
          _options2$encoding = _options2.encoding,
          encoding = _options2$encoding === void 0 ? 'hex' : _options2$encoding,
          opts = _objectWithoutProperties(_options2, ["encoding"]);

      var c = new Decoder(opts);
      var s = utils.guessEncoding(input, encoding);
      var res = [];

      while (s.length > 0) {
        var parser = c._parse();

        var state = parser.next();

        while (!state.done) {
          var b = s.read(state.value);

          if (b == null || b.length !== state.value) {
            throw new Error('Insufficient data');
          }

          if (c.extendedResults) {
            c.valueBytes.write(b);
          }

          state = parser.next(b);
        }

        res.push(Decoder.nullcheck(state.value));
      }

      return res;
    }
    /**
     * Decode the first CBOR item in the input.  This will error if there are
     * more bytes left over at the end (if options.extendedResults is not true),
     * and optionally if there were no valid CBOR bytes in the input.  Emits the
     * {Decoder.NOT_FOUND} Symbol in the callback if no data was found and the
     * `required` option is false.
     *
     * @param {BufferLike} input What to parse?
     * @param {DecoderOptions|decodeCallback|string} [options={}] Options, the
     *   callback, or input encoding.
     * @param {decodeCallback} [cb] Callback.
     * @returns {Promise<ExtendedResults|any>} Returned even if callback is
     *   specified.
     * @throws {TypeError} No input provided.
     * @static
     */

  }, {
    key: "decodeFirst",
    value: function decodeFirst(input) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (input == null) {
        throw new TypeError('input required');
      }

      var _normalizeOptions3 = normalizeOptions(options, cb);

      options = _normalizeOptions3.options;
      cb = _normalizeOptions3.cb;

      var _options3 = options,
          _options3$encoding = _options3.encoding,
          encoding = _options3$encoding === void 0 ? 'hex' : _options3$encoding,
          _options3$required = _options3.required,
          required = _options3$required === void 0 ? false : _options3$required,
          opts = _objectWithoutProperties(_options3, ["encoding", "required"]);

      var c = new Decoder(opts);
      var v =
      /** @type {any} */
      NOT_FOUND;
      var s = utils.guessEncoding(input, encoding);
      var p = new Promise(function (resolve, reject) {
        c.on('data', function (val) {
          v = Decoder.nullcheck(val);
          c.close();
        });
        c.once('error', function (er) {
          if (c.extendedResults && er instanceof UnexpectedDataError) {
            v.unused = c.bs.slice();
            return resolve(v);
          }

          if (v !== NOT_FOUND) {
            // Typescript work-around
            // eslint-disable-next-line dot-notation
            er['value'] = v;
          }

          v = ERROR;
          c.close();
          return reject(er);
        });
        c.once('end', function () {
          switch (v) {
            case NOT_FOUND:
              if (required) {
                return reject(new Error('No CBOR found'));
              }

              return resolve(v);
            // Pretty sure this can't happen, but not *certain*.

            /* istanbul ignore next */

            case ERROR:
              /* istanbul ignore next */
              return undefined;

            default:
              return resolve(v);
          }
        });
      });

      if (typeof cb === 'function') {
        p.then(function (val) {
          return cb(null, val);
        }, cb);
      }

      s.pipe(c);
      return p;
    }
    /**
     * @callback decodeAllCallback
     * @param {Error} error If one was generated.
     * @param {Array<ExtendedResults>|Array<any>} value All of the decoded
     *   values, wrapped in an Array.
     */

    /**
     * Decode all of the CBOR items in the input.  This will error if there are
     * more bytes left over at the end.
     *
     * @param {BufferLike} input What to parse?
     * @param {DecoderOptions|decodeAllCallback|string} [options={}]
     *   Decoding options, the callback, or the input encoding.
     * @param {decodeAllCallback} [cb] Callback.
     * @returns {Promise<Array<ExtendedResults>|Array<any>>} Even if callback
     *   is specified.
     * @throws {TypeError} No input specified.
     * @static
     */

  }, {
    key: "decodeAll",
    value: function decodeAll(input) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var cb = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (input == null) {
        throw new TypeError('input required');
      }

      var _normalizeOptions4 = normalizeOptions(options, cb);

      options = _normalizeOptions4.options;
      cb = _normalizeOptions4.cb;

      var _options4 = options,
          _options4$encoding = _options4.encoding,
          encoding = _options4$encoding === void 0 ? 'hex' : _options4$encoding,
          opts = _objectWithoutProperties(_options4, ["encoding"]);

      var c = new Decoder(opts);
      var vals = [];
      c.on('data', function (val) {
        return vals.push(Decoder.nullcheck(val));
      });
      var p = new Promise(function (resolve, reject) {
        c.on('error', reject);
        c.on('end', function () {
          return resolve(vals);
        });
      });

      if (typeof cb === 'function') {
        p.then(function (v) {
          return cb(undefined, v);
        }, function (er) {
          return cb(er, undefined);
        });
      }

      utils.guessEncoding(input, encoding).pipe(c);
      return p;
    }
  }]);

  return Decoder;
}(BinaryParseStream);

Decoder.NOT_FOUND = NOT_FOUND;
module.exports = Decoder;