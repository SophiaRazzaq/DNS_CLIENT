'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Encoder = require('./encoder');

var ObjectRecorder = require('./objectRecorder');

var _require = require('buffer'),
    Buffer = _require.Buffer;
/**
 * Implement value sharing.
 *
 * @see {@link cbor.schmorp.de/value-sharing}
 */


var SharedValueEncoder =
/*#__PURE__*/
function (_Encoder) {
  _inherits(SharedValueEncoder, _Encoder);

  function SharedValueEncoder(opts) {
    var _this;

    _classCallCheck(this, SharedValueEncoder);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(SharedValueEncoder).call(this, opts));
    _this.valueSharing = new ObjectRecorder();
    return _this;
  }
  /**
   * @param {object} obj Object to encode.
   * @param {import('./encoder').ObjectOptions} [opts] Options for encoding
   *   this object.
   * @returns {boolean} True on success.
   * @throws {Error} Loop detected.
   * @ignore
   */


  _createClass(SharedValueEncoder, [{
    key: "_pushObject",
    value: function _pushObject(obj, opts) {
      if (obj !== null) {
        var shared = this.valueSharing.check(obj);

        switch (shared) {
          case ObjectRecorder.FIRST:
            // Prefix with tag 28
            this._pushTag(28);

            break;

          case ObjectRecorder.NEVER:
            // Do nothing
            break;

          default:
            return this._pushTag(29) && this._pushIntNum(shared);
        }
      }

      return _get(_getPrototypeOf(SharedValueEncoder.prototype), "_pushObject", this).call(this, obj, opts);
    }
    /**
     * Between encoding runs, stop recording, and start outputing correct tags.
     */

  }, {
    key: "stopRecording",
    value: function stopRecording() {
      this.valueSharing.stop();
    }
    /**
     * Remove the existing recording and start over.  Do this between encoding
     * pairs.
     */

  }, {
    key: "clearRecording",
    value: function clearRecording() {
      this.valueSharing.clear();
    }
    /**
     * Encode one or more JavaScript objects, and return a Buffer containing the
     * CBOR bytes.
     *
     * @param {...any} objs The objects to encode.
     * @returns {Buffer} The encoded objects.
     */

  }], [{
    key: "encode",
    value: function encode() {
      var enc = new SharedValueEncoder(); // eslint-disable-next-line no-empty-function

      enc.on('data', function () {}); // Sink all writes

      for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
        objs[_key] = arguments[_key];
      }

      for (var _i = 0, _objs = objs; _i < _objs.length; _i++) {
        var o = _objs[_i];
        enc.pushAny(o);
      }

      enc.stopRecording();
      enc.removeAllListeners('data');
      return enc._encodeAll(objs);
    } // eslint-disable-next-line jsdoc/require-returns-check

    /**
     * Encode one or more JavaScript objects canonically (slower!), and return
     * a Buffer containing the CBOR bytes.
     *
     * @param {...any} objs The objects to encode.
     * @returns {Buffer} Never.
     * @throws {Error} Always.  This combination doesn't work at the moment.
     */

  }, {
    key: "encodeCanonical",
    value: function encodeCanonical() {
      throw new Error('Cannot encode canonically in a SharedValueEncoder, which serializes objects multiple times.');
    }
    /**
     * Encode one JavaScript object using the given options.
     *
     * @param {any} obj The object to encode.
     * @param {import('./encoder').EncodingOptions} [options={}]
     *   Passed to the Encoder constructor.
     * @returns {Buffer} The encoded objects.
     * @static
     */

  }, {
    key: "encodeOne",
    value: function encodeOne(obj, options) {
      var enc = new SharedValueEncoder(options); // eslint-disable-next-line no-empty-function

      enc.on('data', function () {}); // Sink all writes

      enc.pushAny(obj);
      enc.stopRecording();
      enc.removeAllListeners('data');
      return enc._encodeAll([obj]);
    }
    /**
     * Encode one JavaScript object using the given options in a way that
     * is more resilient to objects being larger than the highWaterMark
     * number of bytes.  As with the other static encode functions, this
     * will still use a large amount of memory.  Use a stream-based approach
     * directly if you need to process large and complicated inputs.
     *
     * @param {any} obj The object to encode.
     * @param {import('./encoder').EncodingOptions} [options={}]
     *   Passed to the Encoder constructor.
     * @returns {Promise<Buffer>} A promise for the encoded buffer.
     */

  }, {
    key: "encodeAsync",
    value: function encodeAsync(obj, options) {
      return new Promise(function (resolve, reject) {
        /** @type {Buffer[]} */
        var bufs = [];
        var enc = new SharedValueEncoder(options); // eslint-disable-next-line no-empty-function

        enc.on('data', function () {});
        enc.on('error', reject);
        enc.on('finish', function () {
          return resolve(Buffer.concat(bufs));
        });
        enc.pushAny(obj);
        enc.stopRecording();
        enc.removeAllListeners('data');
        enc.on('data', function (buf) {
          return bufs.push(buf);
        });
        enc.pushAny(obj);
        enc.end();
      });
    }
  }]);

  return SharedValueEncoder;
}(Encoder);

module.exports = SharedValueEncoder;