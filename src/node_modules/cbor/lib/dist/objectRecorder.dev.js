'use strict';
/**
 * Record objects that pass by in a stream.  If the same object is used more
 * than once, it can be value-shared using shared values.
 *
 * @see {@link http://cbor.schmorp.de/value-sharing}
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var ObjectRecorder =
/*#__PURE__*/
function () {
  function ObjectRecorder() {
    _classCallCheck(this, ObjectRecorder);

    this.clear();
  }
  /**
   * Clear all of the objects that have been seen.  Revert to recording mode.
   */


  _createClass(ObjectRecorder, [{
    key: "clear",
    value: function clear() {
      this.map = new WeakMap();
      this.count = 0;
      this.recording = true;
    }
    /**
     * Stop recording.
     */

  }, {
    key: "stop",
    value: function stop() {
      this.recording = false;
    }
    /**
     * Determine if wrapping a tag 28 or 29 around an object that has been
     * reused is appropriate.  This method stores state for which objects have
     * been seen.
     *
     * @param {object} obj Any object about to be serialized.
     * @returns {number} If recording: -1 for first use, index for second use.
     *   If not recording, -1 for never-duplicated, -2 for first use, index for
     *   subsequent uses.
     * @throws {Error} Recording does not match playback.
     */

  }, {
    key: "check",
    value: function check(obj) {
      var val = this.map.get(obj);

      if (val) {
        if (val.length > 1) {
          if (val[0] || this.recording) {
            return val[1];
          }

          val[0] = true;
          return ObjectRecorder.FIRST;
        }

        if (!this.recording) {
          return ObjectRecorder.NEVER;
        }

        val.push(this.count++); // Second use while recording

        return val[1];
      }

      if (!this.recording) {
        throw new Error('New object detected when not recording');
      }

      this.map.set(obj, [false]); // First use while recording

      return ObjectRecorder.NEVER;
    }
  }]);

  return ObjectRecorder;
}();

ObjectRecorder.NEVER = -1;
ObjectRecorder.FIRST = -2;
module.exports = ObjectRecorder;