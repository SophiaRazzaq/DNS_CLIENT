'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _wrapRegExp(re, groups) { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, undefined, groups); }; var _RegExp = _wrapNativeSuper(RegExp); var _super = RegExp.prototype; var _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = _RegExp.call(this, re, flags); _groups.set(_this, groups || _groups.get(re)); return _this; } _inherits(BabelRegExp, _RegExp); BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) result.groups = buildGroups(result, this); return result; }; BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if (typeof substitution === "string") { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { return "$" + groups[name]; })); } else if (typeof substitution === "function") { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = []; args.push.apply(args, arguments); if (_typeof(args[args.length - 1]) !== "object") { args.push(buildGroups(args, _this)); } return substitution.apply(this, args); }); } else { return _super[Symbol.replace].call(this, str, substitution); } }; function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { groups[name] = result[g[name]]; return groups; }, Object.create(null)); } return _wrapRegExp.apply(this, arguments); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var constants = require('./constants');

var utils = require('./utils');

var INTERNAL_JSON = Symbol('INTERNAL_JSON');

function setBuffersToJSON(obj, fn) {
  // The data item tagged can be a byte string or any other data item.  In the
  // latter case, the tag applies to all of the byte string data items
  // contained in the data item, except for those contained in a nested data
  // item tagged with an expected conversion.
  if (utils.isBufferish(obj)) {
    obj.toJSON = fn;
  } else if (Array.isArray(obj)) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = obj[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var v = _step.value;
        setBuffersToJSON(v, fn);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  } else if (obj && _typeof(obj) === 'object') {
    // FFS, complexity in the protocol.
    // There's some circular dependency in here.
    // eslint-disable-next-line no-use-before-define
    if (!(obj instanceof Tagged) || obj.tag < 21 || obj.tag > 23) {
      for (var _i = 0, _Object$values = Object.values(obj); _i < _Object$values.length; _i++) {
        var _v = _Object$values[_i];
        setBuffersToJSON(_v, fn);
      }
    }
  }
}

function b64this() {
  // eslint-disable-next-line no-invalid-this
  return utils.base64(this);
}

function b64urlThis() {
  // eslint-disable-next-line no-invalid-this
  return utils.base64url(this);
}

function hexThis() {
  // eslint-disable-next-line no-invalid-this
  return this.toString('hex');
}

function swapEndian(ab, size, byteOffset, byteLength) {
  var dv = new DataView(ab);

  var _$4$8$size = _slicedToArray({
    2: [dv.getUint16, dv.setUint16],
    4: [dv.getUint32, dv.setUint32],
    8: [dv.getBigUint64, dv.setBigUint64]
  }[size], 2),
      getter = _$4$8$size[0],
      setter = _$4$8$size[1];

  var end = byteOffset + byteLength;

  for (var offset = byteOffset; offset < end; offset += size) {
    setter.call(dv, offset, getter.call(dv, offset, true));
  }
}
/**
 * Convert a tagged value to a more interesting JavaScript type.  Errors
 * thrown in this function will be captured into the "err" property of the
 * original Tagged instance.
 *
 * @callback TagFunction
 * @param {any} value The value inside the tag.
 * @param {Tagged} tag The enclosing Tagged instance; useful if you want to
 *   modify it and return it.  Also available as "this".
 * @returns {any} The transformed value.
 */

/* eslint-disable jsdoc/check-types */

/**
 * A mapping from tag number to a tag decoding function.
 *
 * @typedef {Object.<string, TagFunction>} TagMap
 */

/* eslint-enable jsdoc/check-types */

/**
 * @type {TagMap}
 * @private
 */


var TAGS = {
  // Standard date/time string; see Section 3.4.1
  0: function _(v) {
    return new Date(v);
  },
  // Epoch-based date/time; see Section 3.4.2
  1: function _(v) {
    return new Date(v * 1000);
  },
  // Positive bignum; see Section 3.4.3
  2: function _(v) {
    return utils.bufferToBigInt(v);
  },
  // Negative bignum; see Section 3.4.3
  3: function _(v) {
    return constants.BI.MINUS_ONE - utils.bufferToBigInt(v);
  },
  // Expected conversion to base64url encoding; see Section 3.4.5.2
  21: function _(v, tag) {
    if (utils.isBufferish(v)) {
      tag[INTERNAL_JSON] = b64urlThis;
    } else {
      setBuffersToJSON(v, b64urlThis);
    }

    return tag;
  },
  // Expected conversion to base64 encoding; see Section 3.4.5.2
  22: function _(v, tag) {
    if (utils.isBufferish(v)) {
      tag[INTERNAL_JSON] = b64this;
    } else {
      setBuffersToJSON(v, b64this);
    }

    return tag;
  },
  // Expected conversion to base16 encoding; see Section Section 3.4.5.2
  23: function _(v, tag) {
    if (utils.isBufferish(v)) {
      tag[INTERNAL_JSON] = hexThis;
    } else {
      setBuffersToJSON(v, hexThis);
    }

    return tag;
  },
  // URI; see Section 3.4.5.3
  32: function _(v) {
    return new URL(v);
  },
  // Base64url; see Section 3.4.5.3
  33: function _(v, tag) {
    // If any of the following apply:
    // -  the encoded text string contains non-alphabet characters or
    //    only 1 alphabet character in the last block of 4 (where
    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33
    //    and Section 4 of [RFC4648] for tag number 34), or
    if (!v.match(/^[a-zA-Z0-9_-]+$/)) {
      throw new Error('Invalid base64url characters');
    }

    var last = v.length % 4;

    if (last === 1) {
      throw new Error('Invalid base64url length');
    } // -  the padding bits in a 2- or 3-character block are not 0, or


    if (last === 2) {
      // The last 4 bits of the last character need to be zero.
      if ('AQgw'.indexOf(v[v.length - 1]) === -1) {
        throw new Error('Invalid base64 padding');
      }
    } else if (last === 3) {
      // The last 2 bits of the last character need to be zero.
      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 1]) === -1) {
        throw new Error('Invalid base64 padding');
      }
    } //    Or
    // -  the base64url encoding has padding characters,
    // (caught above)
    // the string is invalid.


    return tag;
  },
  // Base64; see Section 3.4.5.3
  34: function _(v, tag) {
    // If any of the following apply:
    // -  the encoded text string contains non-alphabet characters or
    //    only 1 alphabet character in the last block of 4 (where
    //    alphabet is defined by Section 5 of [RFC4648] for tag number 33
    //    and Section 4 of [RFC4648] for tag number 34), or
    var m = v.match(_wrapRegExp(/^[\+\/-9A-Za-z]+(={0,2})$/, {
      padding: 1
    }));

    if (!m) {
      throw new Error('Invalid base64 characters');
    }

    if (v.length % 4 !== 0) {
      throw new Error('Invalid base64 length');
    } // -  the padding bits in a 2- or 3-character block are not 0, or


    if (m.groups.padding === '=') {
      // The last 4 bits of the last character need to be zero.
      if ('AQgw'.indexOf(v[v.length - 2]) === -1) {
        throw new Error('Invalid base64 padding');
      }
    } else if (m.groups.padding === '==') {
      // The last 2 bits of the last character need to be zero.
      if ('AEIMQUYcgkosw048'.indexOf(v[v.length - 3]) === -1) {
        throw new Error('Invalid base64 padding');
      }
    } // -  the base64 encoding has the wrong number of padding characters,
    // (caught above)
    // the string is invalid.


    return tag;
  },
  // Regular expression; see Section 2.4.4.3
  35: function _(v) {
    return new RegExp(v);
  },
  // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md
  258: function _(v) {
    return new Set(v);
  }
};
var TYPED_ARRAY_TAGS = {
  64: Uint8Array,
  65: Uint16Array,
  66: Uint32Array,
  // 67: BigUint64Array,  Safari doesn't implement
  68: Uint8ClampedArray,
  69: Uint16Array,
  70: Uint32Array,
  // 71: BigUint64Array,  Safari doesn't implement
  72: Int8Array,
  73: Int16Array,
  74: Int32Array,
  // 75: BigInt64Array,  Safari doesn't implement
  // 76: reserved
  77: Int16Array,
  78: Int32Array,
  // 79: BigInt64Array,  Safari doesn't implement
  // 80: not implemented, float16 array
  81: Float32Array,
  82: Float64Array,
  // 83: not implemented, float128 array
  // 84: not implemented, float16 array
  85: Float32Array,
  86: Float64Array // 87: not implemented, float128 array

}; // Safari

if (typeof BigUint64Array !== 'undefined') {
  TYPED_ARRAY_TAGS[67] = BigUint64Array;
  TYPED_ARRAY_TAGS[71] = BigUint64Array;
}

if (typeof BigInt64Array !== 'undefined') {
  TYPED_ARRAY_TAGS[75] = BigInt64Array;
  TYPED_ARRAY_TAGS[79] = BigInt64Array;
}

function _toTypedArray(val, tagged) {
  if (!utils.isBufferish(val)) {
    throw new TypeError('val not a buffer');
  }

  var tag = tagged.tag; // See https://tools.ietf.org/html/rfc8746

  var TypedClass = TYPED_ARRAY_TAGS[tag];

  if (!TypedClass) {
    throw new Error("Invalid typed array tag: ".concat(tag));
  }

  var little = tag & 4;

  var _float = (tag & 16) >> 4;

  var sz = Math.pow(2, _float + (tag & 3));

  if (!little !== utils.isBigEndian() && sz > 1) {
    swapEndian(val.buffer, sz, val.byteOffset, val.byteLength);
  }

  var ab = val.buffer.slice(val.byteOffset, val.byteOffset + val.byteLength);
  return new TypedClass(ab);
}

for (var _i2 = 0, _Object$keys = Object.keys(TYPED_ARRAY_TAGS); _i2 < _Object$keys.length; _i2++) {
  var n = _Object$keys[_i2];
  TAGS[n] = _toTypedArray;
}
/**
 * @type {TagMap}
 * @private
 */


var current_TAGS = {};
/**
 * A CBOR tagged item, where the tag does not have semantics specified at the
 * moment, or those semantics threw an error during parsing. Typically this will
 * be an extension point you're not yet expecting.
 */

var Tagged =
/*#__PURE__*/
function () {
  /**
   * Creates an instance of Tagged.
   *
   * @param {number} tag The number of the tag.
   * @param {any} value The value inside the tag.
   * @param {Error} [err] The error that was thrown parsing the tag, or null.
   */
  function Tagged(tag, value, err) {
    _classCallCheck(this, Tagged);

    this.tag = tag;
    this.value = value;
    this.err = err;

    if (typeof this.tag !== 'number') {
      throw new Error("Invalid tag type (".concat(_typeof(this.tag), ")"));
    }

    if (this.tag < 0 || (this.tag | 0) !== this.tag) {
      throw new Error("Tag must be a positive integer: ".concat(this.tag));
    }
  }

  _createClass(Tagged, [{
    key: "toJSON",
    value: function toJSON() {
      if (this[INTERNAL_JSON]) {
        return this[INTERNAL_JSON].call(this.value);
      }

      var ret = {
        tag: this.tag,
        value: this.value
      };

      if (this.err) {
        ret.err = this.err;
      }

      return ret;
    }
    /**
     * Convert to a String.
     *
     * @returns {string} String of the form '1(2)'.
     */

  }, {
    key: "toString",
    value: function toString() {
      return "".concat(this.tag, "(").concat(JSON.stringify(this.value), ")");
    }
    /**
     * Push the simple value onto the CBOR stream.
     *
     * @param {object} gen The generator to push onto.
     * @returns {boolean} True on success.
     */

  }, {
    key: "encodeCBOR",
    value: function encodeCBOR(gen) {
      gen._pushTag(this.tag);

      return gen.pushAny(this.value);
    }
    /**
     * If we have a converter for this type, do the conversion.  Some converters
     * are built-in.  Additional ones can be passed in.  If you want to remove
     * a built-in converter, pass a converter in whose value is 'null' instead
     * of a function.
     *
     * @param {object} converters Keys in the object are a tag number, the value
     *   is a function that takes the decoded CBOR and returns a JavaScript value
     *   of the appropriate type.  Throw an exception in the function on errors.
     * @returns {any} The converted item.
     */

  }, {
    key: "convert",
    value: function convert(converters) {
      var f = converters == null ? undefined : converters[this.tag];

      if (f === null) {
        // === is intentional. null has semantic meaning as above
        return this;
      }

      if (typeof f !== 'function') {
        f = Tagged.TAGS[this.tag];

        if (typeof f !== 'function') {
          return this;
        }
      }

      try {
        return f.call(this, this.value, this);
      } catch (error) {
        if (error && error.message && error.message.length > 0) {
          this.err = error.message;
        } else {
          this.err = error;
        }

        return this;
      }
    }
    /**
     * The current set of supported tags.  May be modified by plugins.
     *
     * @type {TagMap}
     * @static
     */

  }], [{
    key: "reset",

    /**
     * Reset the supported tags to the original set, before any plugins modified
     * the list.
     */
    value: function reset() {
      Tagged.TAGS = _objectSpread({}, TAGS);
    }
  }, {
    key: "TAGS",
    get: function get() {
      return current_TAGS;
    },
    set: function set(val) {
      current_TAGS = val;
    }
  }]);

  return Tagged;
}();

Tagged.INTERNAL_JSON = INTERNAL_JSON;
Tagged.reset();
module.exports = Tagged;