'use strict';

var _Object$assign;

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var stream = require('stream');

var NoFilter = require('nofilter');

var utils = require('./utils');

var constants = require('./constants');

var MT = constants.MT,
    NUMBYTES = constants.NUMBYTES,
    SHIFT32 = constants.SHIFT32,
    SIMPLE = constants.SIMPLE,
    SYMS = constants.SYMS,
    TAG = constants.TAG,
    BI = constants.BI;

var _require = require('buffer'),
    Buffer = _require.Buffer;

var HALF = MT.SIMPLE_FLOAT << 5 | NUMBYTES.TWO;
var FLOAT = MT.SIMPLE_FLOAT << 5 | NUMBYTES.FOUR;
var DOUBLE = MT.SIMPLE_FLOAT << 5 | NUMBYTES.EIGHT;
var TRUE = MT.SIMPLE_FLOAT << 5 | SIMPLE.TRUE;
var FALSE = MT.SIMPLE_FLOAT << 5 | SIMPLE.FALSE;
var UNDEFINED = MT.SIMPLE_FLOAT << 5 | SIMPLE.UNDEFINED;
var NULL = MT.SIMPLE_FLOAT << 5 | SIMPLE.NULL;
var BREAK = Buffer.from([0xff]);
var BUF_NAN = Buffer.from('f97e00', 'hex');
var BUF_INF_NEG = Buffer.from('f9fc00', 'hex');
var BUF_INF_POS = Buffer.from('f97c00', 'hex');
var BUF_NEG_ZERO = Buffer.from('f98000', 'hex');
/**
 * Generate the CBOR for a value.  If you are using this, you'll either need
 * to call {@link Encoder.write} with a Buffer, or look into the internals of
 * Encoder to reuse existing non-documented behavior.
 *
 * @callback EncodeFunction
 * @param {Encoder} enc The encoder to use.
 * @param {any} val The value to encode.
 * @returns {boolean} True on success.
 */

/* eslint-disable jsdoc/check-types */

/**
 * A mapping from tag number to a tag decoding function.
 *
 * @typedef {Object.<string, EncodeFunction>} SemanticMap
 */

/* eslint-enable jsdoc/check-types */

/**
 * @type {SemanticMap}
 * @private
 */

var SEMANTIC_TYPES = {};
/**
 * @type {SemanticMap}
 * @private
 */

var current_SEMANTIC_TYPES = {};
/**
 * @param {string} str String to normalize.
 * @returns {"number"|"float"|"int"|"string"} Normalized.
 * @throws {TypeError} Invalid input.
 * @private
 */

function parseDateType(str) {
  if (!str) {
    return 'number';
  }

  switch (str.toLowerCase()) {
    case 'number':
      return 'number';

    case 'float':
      return 'float';

    case 'int':
    case 'integer':
      return 'int';

    case 'string':
      return 'string';
  }

  throw new TypeError("dateType invalid, got \"".concat(str, "\""));
}
/**
 * @typedef ObjectOptions
 * @property {boolean} [indefinite = false] Force indefinite encoding for this
 *   object.
 * @property {boolean} [skipTypes = false] Do not use available type mappings
 *   for this object, but encode it as a "normal" JS object would be.
 */

/**
 * @typedef EncodingOptions
 * @property {any[]|object} [genTypes=[]] Array of pairs of
 *   `type`, `function(Encoder)` for semantic types to be encoded.  Not
 *   needed for Array, Date, Buffer, Map, RegExp, Set, or URL.
 *   If an object, the keys are the constructor names for the types.
 * @property {boolean} [canonical=false] Should the output be
 *   canonicalized.
 * @property {boolean|WeakSet} [detectLoops=false] Should object loops
 *   be detected?  This will currently add memory to track every part of the
 *   object being encoded in a WeakSet.  Do not encode
 *   the same object twice on the same encoder, without calling
 *   `removeLoopDetectors` in between, which will clear the WeakSet.
 *   You may pass in your own WeakSet to be used; this is useful in some
 *   recursive scenarios.
 * @property {("number"|"float"|"int"|"string")} [dateType="number"] -
 *   how should dates be encoded?  "number" means float or int, if no
 *   fractional seconds.
 * @property {any} [encodeUndefined=undefined] How should an
 *   "undefined" in the input be encoded.  By default, just encode a CBOR
 *   undefined.  If this is a buffer, use those bytes without re-encoding
 *   them.  If this is a function, the function will be called (which is a
 *   good time to throw an exception, if that's what you want), and the
 *   return value will be used according to these rules.  Anything else will
 *   be encoded as CBOR.
 * @property {boolean} [disallowUndefinedKeys=false] Should
 *   "undefined" be disallowed as a key in a Map that is serialized?  If
 *   this is true, encode(new Map([[undefined, 1]])) will throw an
 *   exception.  Note that it is impossible to get a key of undefined in a
 *   normal JS object.
 * @property {boolean} [collapseBigIntegers=false] Should integers
 *   that come in as ECMAscript bigint's be encoded
 *   as normal CBOR integers if they fit, discarding type information?
 * @property {number} [chunkSize=4096] Number of characters or bytes
 *   for each chunk, if obj is a string or Buffer, when indefinite encoding.
 * @property {boolean} [omitUndefinedProperties=false] When encoding
 *   objects or Maps, do not include a key if its corresponding value is
 *   `undefined`.
 */

/**
 * Transform JavaScript values into CBOR bytes.  The `Writable` side of
 * the stream is in object mode.
 *
 * @extends stream.Transform
 */


var Encoder =
/*#__PURE__*/
function (_stream$Transform) {
  _inherits(Encoder, _stream$Transform);

  /**
   * Creates an instance of Encoder.
   *
   * @param {EncodingOptions} [options={}] Options for the encoder.
   */
  function Encoder() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Encoder);

    var _options$canonical = options.canonical,
        canonical = _options$canonical === void 0 ? false : _options$canonical,
        encodeUndefined = options.encodeUndefined,
        _options$disallowUnde = options.disallowUndefinedKeys,
        disallowUndefinedKeys = _options$disallowUnde === void 0 ? false : _options$disallowUnde,
        _options$dateType = options.dateType,
        dateType = _options$dateType === void 0 ? 'number' : _options$dateType,
        _options$collapseBigI = options.collapseBigIntegers,
        collapseBigIntegers = _options$collapseBigI === void 0 ? false : _options$collapseBigI,
        _options$detectLoops = options.detectLoops,
        detectLoops = _options$detectLoops === void 0 ? false : _options$detectLoops,
        _options$omitUndefine = options.omitUndefinedProperties,
        omitUndefinedProperties = _options$omitUndefine === void 0 ? false : _options$omitUndefine,
        _options$genTypes = options.genTypes,
        genTypes = _options$genTypes === void 0 ? [] : _options$genTypes,
        superOpts = _objectWithoutProperties(options, ["canonical", "encodeUndefined", "disallowUndefinedKeys", "dateType", "collapseBigIntegers", "detectLoops", "omitUndefinedProperties", "genTypes"]);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Encoder).call(this, _objectSpread({}, superOpts, {
      readableObjectMode: false,
      writableObjectMode: true
    })));
    _this.canonical = canonical;
    _this.encodeUndefined = encodeUndefined;
    _this.disallowUndefinedKeys = disallowUndefinedKeys;
    _this.dateType = parseDateType(dateType);
    _this.collapseBigIntegers = _this.canonical ? true : collapseBigIntegers;
    /** @type {WeakSet?} */

    _this.detectLoops = undefined;

    if (typeof detectLoops === 'boolean') {
      if (detectLoops) {
        _this.detectLoops = new WeakSet();
      }
    } else if (detectLoops instanceof WeakSet) {
      _this.detectLoops = detectLoops;
    } else {
      throw new TypeError('detectLoops must be boolean or WeakSet');
    }

    _this.omitUndefinedProperties = omitUndefinedProperties;
    _this.semanticTypes = _objectSpread({}, Encoder.SEMANTIC_TYPES);

    if (Array.isArray(genTypes)) {
      for (var i = 0, len = genTypes.length; i < len; i += 2) {
        _this.addSemanticType(genTypes[i], genTypes[i + 1]);
      }
    } else {
      for (var _i = 0, _Object$entries = Object.entries(genTypes); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            k = _Object$entries$_i[0],
            v = _Object$entries$_i[1];

        _this.addSemanticType(k, v);
      }
    }

    return _this;
  }
  /**
   * Transforming.
   *
   * @param {any} fresh Buffer to transcode.
   * @param {BufferEncoding} encoding Name of encoding.
   * @param {stream.TransformCallback} cb Callback when done.
   * @ignore
   */


  _createClass(Encoder, [{
    key: "_transform",
    value: function _transform(fresh, encoding, cb) {
      var ret = this.pushAny(fresh); // Old transformers might not return bool.  undefined !== false

      cb(ret === false ? new Error('Push Error') : undefined);
    }
    /**
     * Flushing.
     *
     * @param {stream.TransformCallback} cb Callback when done.
     * @ignore
     */
    // eslint-disable-next-line class-methods-use-this

  }, {
    key: "_flush",
    value: function _flush(cb) {
      cb();
    }
    /**
     * @param {number} val Number(0-255) to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushUInt8",
    value: function _pushUInt8(val) {
      var b = Buffer.allocUnsafe(1);
      b.writeUInt8(val, 0);
      return this.push(b);
    }
    /**
     * @param {number} val Number(0-65535) to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushUInt16BE",
    value: function _pushUInt16BE(val) {
      var b = Buffer.allocUnsafe(2);
      b.writeUInt16BE(val, 0);
      return this.push(b);
    }
    /**
     * @param {number} val Number(0..2**32-1) to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushUInt32BE",
    value: function _pushUInt32BE(val) {
      var b = Buffer.allocUnsafe(4);
      b.writeUInt32BE(val, 0);
      return this.push(b);
    }
    /**
     * @param {number} val Number to encode as 4-byte float.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushFloatBE",
    value: function _pushFloatBE(val) {
      var b = Buffer.allocUnsafe(4);
      b.writeFloatBE(val, 0);
      return this.push(b);
    }
    /**
     * @param {number} val Number to encode as 8-byte double.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushDoubleBE",
    value: function _pushDoubleBE(val) {
      var b = Buffer.allocUnsafe(8);
      b.writeDoubleBE(val, 0);
      return this.push(b);
    }
    /**
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushNaN",
    value: function _pushNaN() {
      return this.push(BUF_NAN);
    }
    /**
     * @param {number} obj Positive or negative infinity.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushInfinity",
    value: function _pushInfinity(obj) {
      var half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;
      return this.push(half);
    }
    /**
     * Choose the best float representation for a number and encode it.
     *
     * @param {number} obj A number that is known to be not-integer, but not
     *   how many bytes of precision it needs.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushFloat",
    value: function _pushFloat(obj) {
      if (this.canonical) {
        // TODO: is this enough slower to hide behind canonical?
        // It's certainly enough of a hack (see utils.parseHalf)
        // From section 3.9:
        // If a protocol allows for IEEE floats, then additional canonicalization
        // rules might need to be added.  One example rule might be to have all
        // floats start as a 64-bit float, then do a test conversion to a 32-bit
        // float; if the result is the same numeric value, use the shorter value
        // and repeat the process with a test conversion to a 16-bit float.  (This
        // rule selects 16-bit float for positive and negative Infinity as well.)
        // which seems pretty much backwards to me.
        var b2 = Buffer.allocUnsafe(2);

        if (utils.writeHalf(b2, obj)) {
          // I have convinced myself that there are no cases where writeHalf
          // will return true but `utils.parseHalf(b2) !== obj)`
          return this._pushUInt8(HALF) && this.push(b2);
        }
      }

      if (Math.fround(obj) === obj) {
        return this._pushUInt8(FLOAT) && this._pushFloatBE(obj);
      }

      return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);
    }
    /**
     * Choose the best integer representation for a postive number and encode
     * it.  If the number is over MAX_SAFE_INTEGER, fall back on float (but I
     * don't remember why).
     *
     * @param {number} obj A positive number that is known to be an integer,
     *   but not how many bytes of precision it needs.
     * @param {number} mt The Major Type number to combine with the integer.
     *   Not yet shifted.
     * @param {number} [orig] The number before it was transformed to positive.
     *   If the mt is NEG_INT, and the positive number is over MAX_SAFE_INT,
     *   then we'll encode this as a float rather than making the number
     *   negative again and losing precision.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushInt",
    value: function _pushInt(obj, mt, orig) {
      var m = mt << 5;

      if (obj < 24) {
        return this._pushUInt8(m | obj);
      }

      if (obj <= 0xff) {
        return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);
      }

      if (obj <= 0xffff) {
        return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);
      }

      if (obj <= 0xffffffff) {
        return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);
      }

      var max = Number.MAX_SAFE_INTEGER;

      if (mt === MT.NEG_INT) {
        // Special case for Number.MIN_SAFE_INTEGER - 1
        max--;
      }

      if (obj <= max) {
        return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);
      }

      if (mt === MT.NEG_INT) {
        return this._pushFloat(orig);
      }

      return this._pushFloat(obj);
    }
    /**
     * Choose the best integer representation for a number and encode it.
     *
     * @param {number} obj A number that is known to be an integer,
     *   but not how many bytes of precision it needs.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushIntNum",
    value: function _pushIntNum(obj) {
      if (Object.is(obj, -0)) {
        return this.push(BUF_NEG_ZERO);
      }

      if (obj < 0) {
        return this._pushInt(-obj - 1, MT.NEG_INT, obj);
      }

      return this._pushInt(obj, MT.POS_INT);
    }
    /**
     * @param {number} obj Plain JS number to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushNumber",
    value: function _pushNumber(obj) {
      if (isNaN(obj)) {
        return this._pushNaN();
      }

      if (!isFinite(obj)) {
        return this._pushInfinity(obj);
      }

      if (Math.round(obj) === obj) {
        return this._pushIntNum(obj);
      }

      return this._pushFloat(obj);
    }
    /**
     * @param {string} obj String to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushString",
    value: function _pushString(obj) {
      var len = Buffer.byteLength(obj, 'utf8');
      return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8');
    }
    /**
     * @param {boolean} obj Bool to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushBoolean",
    value: function _pushBoolean(obj) {
      return this._pushUInt8(obj ? TRUE : FALSE);
    }
    /**
     * @param {undefined} obj Ignored.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushUndefined",
    value: function _pushUndefined(obj) {
      switch (_typeof(this.encodeUndefined)) {
        case 'undefined':
          return this._pushUInt8(UNDEFINED);

        case 'function':
          return this.pushAny(this.encodeUndefined(obj));

        case 'object':
          {
            var buf = utils.bufferishToBuffer(this.encodeUndefined);

            if (buf) {
              return this.push(buf);
            }
          }
      }

      return this.pushAny(this.encodeUndefined);
    }
    /**
     * @param {null} obj Ignored.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushNull",
    value: function _pushNull(obj) {
      return this._pushUInt8(NULL);
    }
    /**
     * @param {number} tag Tag number to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushTag",
    value: function _pushTag(tag) {
      return this._pushInt(tag, MT.TAG);
    }
    /**
     * @param {bigint} obj BigInt to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushJSBigint",
    value: function _pushJSBigint(obj) {
      var m = MT.POS_INT;
      var tag = TAG.POS_BIGINT; // BigInt doesn't have -0

      if (obj < 0) {
        obj = -obj + BI.MINUS_ONE;
        m = MT.NEG_INT;
        tag = TAG.NEG_BIGINT;
      }

      if (this.collapseBigIntegers && obj <= BI.MAXINT64) {
        // Special handiling for 64bits
        if (obj <= 0xffffffff) {
          return this._pushInt(Number(obj), m);
        }

        return this._pushUInt8(m << 5 | NUMBYTES.EIGHT) && this._pushUInt32BE(Number(obj / BI.SHIFT32)) && this._pushUInt32BE(Number(obj % BI.SHIFT32));
      }

      var str = obj.toString(16);

      if (str.length % 2) {
        str = "0".concat(str);
      }

      var buf = Buffer.from(str, 'hex');
      return this._pushTag(tag) && Encoder._pushBuffer(this, buf);
    }
    /**
     * @param {object} obj Object to encode.
     * @param {ObjectOptions} [opts] Options for encoding this object.
     * @returns {boolean} True on success.
     * @throws {Error} Loop detected.
     * @ignore
     */

  }, {
    key: "_pushObject",
    value: function _pushObject(obj, opts) {
      var _this2 = this;

      if (!obj) {
        return this._pushNull(obj);
      }

      opts = _objectSpread({
        indefinite: false,
        skipTypes: false
      }, opts);

      if (!opts.indefinite) {
        // This will only happen the first time through for indefinite encoding
        if (this.detectLoops) {
          if (this.detectLoops.has(obj)) {
            throw new Error("Loop detected while CBOR encoding.\nCall removeLoopDetectors before resuming.");
          } else {
            this.detectLoops.add(obj);
          }
        }
      }

      if (!opts.skipTypes) {
        var f = obj.encodeCBOR;

        if (typeof f === 'function') {
          return f.call(obj, this);
        }

        var converter = this.semanticTypes[obj.constructor.name];

        if (converter) {
          return converter.call(obj, this, obj);
        }
      }

      var keys = Object.keys(obj).filter(function (k) {
        var tv = _typeof(obj[k]);

        return tv !== 'function' && (!_this2.omitUndefinedProperties || tv !== 'undefined');
      });
      var cbor_keys = {};

      if (this.canonical) {
        // Note: this can't be a normal sort, because 'b' needs to sort before
        // 'aa'
        keys.sort(function (a, b) {
          // Always strings, so don't bother to pass options.
          // hold on to the cbor versions, since there's no need
          // to encode more than once
          var a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a));
          var b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b));
          return a_cbor.compare(b_cbor);
        });
      }

      if (opts.indefinite) {
        if (!this._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {
          return false;
        }
      } else if (!this._pushInt(keys.length, MT.MAP)) {
        return false;
      }

      var ck = null;

      for (var j = 0, len2 = keys.length; j < len2; j++) {
        var k = keys[j];

        if (this.canonical && (ck = cbor_keys[k])) {
          if (!this.push(ck)) {
            // Already a Buffer
            return false;
          }
        } else if (!this._pushString(k)) {
          return false;
        }

        if (!this.pushAny(obj[k])) {
          return false;
        }
      }

      if (opts.indefinite) {
        if (!this.push(BREAK)) {
          return false;
        }
      } else if (this.detectLoops) {
        this.detectLoops["delete"](obj);
      }

      return true;
    }
    /**
     * @param {any[]} objs Array of supported things.
     * @returns {Buffer} Concatenation of encodings for the supported things.
     * @ignore
     */

  }, {
    key: "_encodeAll",
    value: function _encodeAll(objs) {
      var bs = new NoFilter({
        highWaterMark: this.readableHighWaterMark
      });
      this.pipe(bs);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = objs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var o = _step.value;
          this.pushAny(o);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this.end();
      return bs.read();
    }
    /**
     * Add an encoding function to the list of supported semantic types.  This
     * is useful for objects for which you can't add an encodeCBOR method.
     *
     * @param {string|Function} type The type to encode.
     * @param {EncodeFunction} fun The encoder to use.
     * @returns {EncodeFunction?} The previous encoder or undefined if there
     *   wasn't one.
     * @throws {TypeError} Invalid function.
     */

  }, {
    key: "addSemanticType",
    value: function addSemanticType(type, fun) {
      var typeName = typeof type === 'string' ? type : type.name;
      var old = this.semanticTypes[typeName];

      if (fun) {
        if (typeof fun !== 'function') {
          throw new TypeError('fun must be of type function');
        }

        this.semanticTypes[typeName] = fun;
      } else if (old) {
        delete this.semanticTypes[typeName];
      }

      return old;
    }
    /**
     * Push any supported type onto the encoded stream.
     *
     * @param {any} obj The thing to encode.
     * @returns {boolean} True on success.
     * @throws {TypeError} Unknown type for obj.
     */

  }, {
    key: "pushAny",
    value: function pushAny(obj) {
      switch (_typeof(obj)) {
        case 'number':
          return this._pushNumber(obj);

        case 'bigint':
          return this._pushJSBigint(obj);

        case 'string':
          return this._pushString(obj);

        case 'boolean':
          return this._pushBoolean(obj);

        case 'undefined':
          return this._pushUndefined(obj);

        case 'object':
          return this._pushObject(obj);

        case 'symbol':
          switch (obj) {
            case SYMS.NULL:
              return this._pushNull(null);

            case SYMS.UNDEFINED:
              return this._pushUndefined(undefined);
            // TODO: Add pluggable support for other symbols

            default:
              throw new TypeError("Unknown symbol: ".concat(obj.toString()));
          }

        default:
          throw new TypeError("Unknown type: ".concat(_typeof(obj), ", ").concat(typeof obj.toString === 'function' ? obj.toString() : ''));
      }
    }
    /**
     * Encode an array and all of its elements.
     *
     * @param {Encoder} gen Encoder to use.
     * @param {any[]} obj Array to encode.
     * @param {object} [opts] Options.
     * @param {boolean} [opts.indefinite=false] Use indefinite encoding?
     * @returns {boolean} True on success.
     */

  }, {
    key: "removeLoopDetectors",

    /**
     * Remove the loop detector WeakSet for this Encoder.
     *
     * @returns {boolean} True when the Encoder was reset, else false.
     */
    value: function removeLoopDetectors() {
      if (!this.detectLoops) {
        return false;
      }

      this.detectLoops = new WeakSet();
      return true;
    }
    /**
     * @param {Encoder} gen Encoder.
     * @param {Date} obj Date to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }], [{
    key: "pushArray",
    value: function pushArray(gen, obj, opts) {
      opts = _objectSpread({
        indefinite: false
      }, opts);
      var len = obj.length;

      if (opts.indefinite) {
        if (!gen._pushUInt8(MT.ARRAY << 5 | NUMBYTES.INDEFINITE)) {
          return false;
        }
      } else if (!gen._pushInt(len, MT.ARRAY)) {
        return false;
      }

      for (var j = 0; j < len; j++) {
        if (!gen.pushAny(obj[j])) {
          return false;
        }
      }

      if (opts.indefinite) {
        if (!gen.push(BREAK)) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "_pushDate",
    value: function _pushDate(gen, obj) {
      switch (gen.dateType) {
        case 'string':
          return gen._pushTag(TAG.DATE_STRING) && gen._pushString(obj.toISOString());

        case 'int':
          return gen._pushTag(TAG.DATE_EPOCH) && gen._pushIntNum(Math.round(obj.getTime() / 1000));

        case 'float':
          // Force float
          return gen._pushTag(TAG.DATE_EPOCH) && gen._pushFloat(obj.getTime() / 1000);

        case 'number':
        default:
          // If we happen to have an integral number of seconds,
          // use integer.  Otherwise, use float.
          return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(obj.getTime() / 1000);
      }
    }
    /**
     * @param {Encoder} gen Encoder.
     * @param {Buffer} obj Buffer to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushBuffer",
    value: function _pushBuffer(gen, obj) {
      return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);
    }
    /**
     * @param {Encoder} gen Encoder.
     * @param {NoFilter} obj Buffer to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushNoFilter",
    value: function _pushNoFilter(gen, obj) {
      return Encoder._pushBuffer(gen,
      /** @type {Buffer} */
      obj.slice());
    }
    /**
     * @param {Encoder} gen Encoder.
     * @param {RegExp} obj RegExp to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushRegexp",
    value: function _pushRegexp(gen, obj) {
      return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);
    }
    /**
     * @param {Encoder} gen Encoder.
     * @param {Set} obj Set to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushSet",
    value: function _pushSet(gen, obj) {
      if (!gen._pushTag(TAG.SET)) {
        return false;
      }

      if (!gen._pushInt(obj.size, MT.ARRAY)) {
        return false;
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = obj[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var x = _step2.value;

          if (!gen.pushAny(x)) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return true;
    }
    /**
     * @param {Encoder} gen Encoder.
     * @param {URL} obj URL to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushURL",
    value: function _pushURL(gen, obj) {
      return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString());
    }
    /**
     * @param {Encoder} gen Encoder.
     * @param {object} obj Boxed String, Number, or Boolean object to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushBoxed",
    value: function _pushBoxed(gen, obj) {
      return gen.pushAny(obj.valueOf());
    }
    /**
     * @param {Encoder} gen Encoder.
     * @param {Map} obj Map to encode.
     * @returns {boolean} True on success.
     * @throws {Error} Map key that is undefined.
     * @ignore
     */

  }, {
    key: "_pushMap",
    value: function _pushMap(gen, obj, opts) {
      opts = _objectSpread({
        indefinite: false
      }, opts);

      var entries = _toConsumableArray(obj.entries());

      if (gen.omitUndefinedProperties) {
        entries = entries.filter(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              k = _ref2[0],
              v = _ref2[1];

          return v !== undefined;
        });
      }

      if (opts.indefinite) {
        if (!gen._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {
          return false;
        }
      } else if (!gen._pushInt(entries.length, MT.MAP)) {
        return false;
      } // Memoizing the cbor only helps in certain cases, and hurts in most
      // others.  Just avoid it.


      if (gen.canonical) {
        // Keep the key/value pairs together, so we don't have to do odd
        // gets with object keys later
        var enc = new Encoder({
          genTypes: gen.semanticTypes,
          canonical: gen.canonical,
          detectLoops: Boolean(gen.detectLoops),
          // Give enc its own loop detector
          dateType: gen.dateType,
          disallowUndefinedKeys: gen.disallowUndefinedKeys,
          collapseBigIntegers: gen.collapseBigIntegers
        });
        var bs = new NoFilter({
          highWaterMark: gen.readableHighWaterMark
        });
        enc.pipe(bs);
        entries.sort(function (_ref3, _ref4) {
          var _ref5 = _slicedToArray(_ref3, 1),
              a = _ref5[0];

          var _ref6 = _slicedToArray(_ref4, 1),
              b = _ref6[0];

          // Both a and b are the keys
          enc.pushAny(a);
          var a_cbor = bs.read();
          enc.pushAny(b);
          var b_cbor = bs.read();
          return a_cbor.compare(b_cbor);
        });
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = entries[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _step3$value = _slicedToArray(_step3.value, 2),
                k = _step3$value[0],
                v = _step3$value[1];

            if (gen.disallowUndefinedKeys && typeof k === 'undefined') {
              throw new Error('Invalid Map key: undefined');
            }

            if (!(gen.pushAny(k) && gen.pushAny(v))) {
              return false;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      } else {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = entries[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _step4$value = _slicedToArray(_step4.value, 2),
                _k = _step4$value[0],
                _v = _step4$value[1];

            if (gen.disallowUndefinedKeys && typeof _k === 'undefined') {
              throw new Error('Invalid Map key: undefined');
            }

            if (!(gen.pushAny(_k) && gen.pushAny(_v))) {
              return false;
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }

      if (opts.indefinite) {
        if (!gen.push(BREAK)) {
          return false;
        }
      }

      return true;
    }
    /**
     * @param {Encoder} gen Encoder.
     * @param {NodeJS.TypedArray} obj Array to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushTypedArray",
    value: function _pushTypedArray(gen, obj) {
      // See https://tools.ietf.org/html/rfc8746
      var typ = 64;
      var sz = obj.BYTES_PER_ELEMENT;
      var name = obj.constructor.name;

      if (name.startsWith('Float')) {
        typ |= 16;
        sz /= 2;
      } else if (!name.includes('U')) {
        typ |= 8;
      }

      if (name.includes('Clamped') || sz !== 1 && !utils.isBigEndian()) {
        typ |= 4;
      }

      typ |= {
        1: 0,
        2: 1,
        4: 2,
        8: 3
      }[sz];

      if (!gen._pushTag(typ)) {
        return false;
      }

      return Encoder._pushBuffer(gen, Buffer.from(obj.buffer, obj.byteOffset, obj.byteLength));
    }
    /**
     * @param {Encoder} gen Encoder.
     * @param { ArrayBuffer } obj Array to encode.
     * @returns {boolean} True on success.
     * @ignore
     */

  }, {
    key: "_pushArrayBuffer",
    value: function _pushArrayBuffer(gen, obj) {
      return Encoder._pushBuffer(gen, Buffer.from(obj));
    }
    /**
     * Encode the given object with indefinite length.  There are apparently
     * some (IMO) broken implementations of poorly-specified protocols that
     * REQUIRE indefinite-encoding.  See the example for how to add this as an
     * `encodeCBOR` function to an object or class to get indefinite encoding.
     *
     * @param {Encoder} gen The encoder to use.
     * @param {string|Buffer|Array|Map|object} [obj] The object to encode.  If
     *   null, use "this" instead.
     * @param {EncodingOptions} [options={}] Options for encoding.
     * @returns {boolean} True on success.
     * @throws {Error} No object to encode or invalid indefinite encoding.
     * @example <caption>Force indefinite encoding:</caption>
     * const o = {
     *   a: true,
     *   encodeCBOR: cbor.Encoder.encodeIndefinite,
     * }
     * const m = []
     * m.encodeCBOR = cbor.Encoder.encodeIndefinite
     * cbor.encodeOne([o, m])
     */

  }, {
    key: "encodeIndefinite",
    value: function encodeIndefinite(gen, obj) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (obj == null) {
        if (this == null) {
          throw new Error('No object to encode');
        }

        obj = this;
      } // TODO: consider other options


      var _options$chunkSize = options.chunkSize,
          chunkSize = _options$chunkSize === void 0 ? 4096 : _options$chunkSize;
      var ret = true;

      var objType = _typeof(obj);

      var buf = null;

      if (objType === 'string') {
        // TODO: make sure not to split surrogate pairs at the edges of chunks,
        // since such half-surrogates cannot be legally encoded as UTF-8.
        ret = ret && gen._pushUInt8(MT.UTF8_STRING << 5 | NUMBYTES.INDEFINITE);
        var offset = 0;

        while (offset < obj.length) {
          var endIndex = offset + chunkSize;
          ret = ret && gen._pushString(obj.slice(offset, endIndex));
          offset = endIndex;
        }

        ret = ret && gen.push(BREAK);
      } else if (buf = utils.bufferishToBuffer(obj)) {
        ret = ret && gen._pushUInt8(MT.BYTE_STRING << 5 | NUMBYTES.INDEFINITE);
        var _offset = 0;

        while (_offset < buf.length) {
          var _endIndex = _offset + chunkSize;

          ret = ret && Encoder._pushBuffer(gen, buf.slice(_offset, _endIndex));
          _offset = _endIndex;
        }

        ret = ret && gen.push(BREAK);
      } else if (Array.isArray(obj)) {
        ret = ret && Encoder.pushArray(gen, obj, {
          indefinite: true
        });
      } else if (obj instanceof Map) {
        ret = ret && Encoder._pushMap(gen, obj, {
          indefinite: true
        });
      } else {
        if (objType !== 'object') {
          throw new Error('Invalid indefinite encoding');
        }

        ret = ret && gen._pushObject(obj, {
          indefinite: true,
          skipTypes: true
        });
      }

      return ret;
    }
    /**
     * Encode one or more JavaScript objects, and return a Buffer containing the
     * CBOR bytes.
     *
     * @param {...any} objs The objects to encode.
     * @returns {Buffer} The encoded objects.
     */

  }, {
    key: "encode",
    value: function encode() {
      for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
        objs[_key] = arguments[_key];
      }

      return new Encoder()._encodeAll(objs);
    }
    /**
     * Encode one or more JavaScript objects canonically (slower!), and return
     * a Buffer containing the CBOR bytes.
     *
     * @param {...any} objs The objects to encode.
     * @returns {Buffer} The encoded objects.
     */

  }, {
    key: "encodeCanonical",
    value: function encodeCanonical() {
      for (var _len2 = arguments.length, objs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        objs[_key2] = arguments[_key2];
      }

      return new Encoder({
        canonical: true
      })._encodeAll(objs);
    }
    /**
     * Encode one JavaScript object using the given options.
     *
     * @param {any} obj The object to encode.
     * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.
     * @returns {Buffer} The encoded objects.
     * @static
     */

  }, {
    key: "encodeOne",
    value: function encodeOne(obj, options) {
      return new Encoder(options)._encodeAll([obj]);
    }
    /**
     * Encode one JavaScript object using the given options in a way that
     * is more resilient to objects being larger than the highWaterMark
     * number of bytes.  As with the other static encode functions, this
     * will still use a large amount of memory.  Use a stream-based approach
     * directly if you need to process large and complicated inputs.
     *
     * @param {any} obj The object to encode.
     * @param {EncodingOptions} [options={}] Passed to the Encoder constructor.
     * @returns {Promise<Buffer>} A promise for the encoded buffer.
     */

  }, {
    key: "encodeAsync",
    value: function encodeAsync(obj, options) {
      return new Promise(function (resolve, reject) {
        var bufs = [];
        var enc = new Encoder(options);
        enc.on('data', function (buf) {
          return bufs.push(buf);
        });
        enc.on('error', reject);
        enc.on('finish', function () {
          return resolve(Buffer.concat(bufs));
        });
        enc.pushAny(obj);
        enc.end();
      });
    }
    /**
     * The currently supported set of semantic types.  May be modified by plugins.
     *
     * @type {SemanticMap}
     */

  }, {
    key: "reset",

    /**
     * Reset the supported semantic types to the original set, before any
     * plugins modified the list.
     */
    value: function reset() {
      Encoder.SEMANTIC_TYPES = _objectSpread({}, SEMANTIC_TYPES);
    }
  }, {
    key: "SEMANTIC_TYPES",
    get: function get() {
      return current_SEMANTIC_TYPES;
    },
    set: function set(val) {
      current_SEMANTIC_TYPES = val;
    }
  }]);

  return Encoder;
}(stream.Transform);

Object.assign(SEMANTIC_TYPES, (_Object$assign = {
  Array: Encoder.pushArray,
  Date: Encoder._pushDate,
  Buffer: Encoder._pushBuffer
}, _defineProperty(_Object$assign, Buffer.name, Encoder._pushBuffer), _defineProperty(_Object$assign, "Map", Encoder._pushMap), _defineProperty(_Object$assign, "NoFilter", Encoder._pushNoFilter), _defineProperty(_Object$assign, NoFilter.name, Encoder._pushNoFilter), _defineProperty(_Object$assign, "RegExp", Encoder._pushRegexp), _defineProperty(_Object$assign, "Set", Encoder._pushSet), _defineProperty(_Object$assign, "ArrayBuffer", Encoder._pushArrayBuffer), _defineProperty(_Object$assign, "Uint8ClampedArray", Encoder._pushTypedArray), _defineProperty(_Object$assign, "Uint8Array", Encoder._pushTypedArray), _defineProperty(_Object$assign, "Uint16Array", Encoder._pushTypedArray), _defineProperty(_Object$assign, "Uint32Array", Encoder._pushTypedArray), _defineProperty(_Object$assign, "Int8Array", Encoder._pushTypedArray), _defineProperty(_Object$assign, "Int16Array", Encoder._pushTypedArray), _defineProperty(_Object$assign, "Int32Array", Encoder._pushTypedArray), _defineProperty(_Object$assign, "Float32Array", Encoder._pushTypedArray), _defineProperty(_Object$assign, "Float64Array", Encoder._pushTypedArray), _defineProperty(_Object$assign, "URL", Encoder._pushURL), _defineProperty(_Object$assign, "Boolean", Encoder._pushBoxed), _defineProperty(_Object$assign, "Number", Encoder._pushBoxed), _defineProperty(_Object$assign, "String", Encoder._pushBoxed), _Object$assign)); // Safari needs to get better.

if (typeof BigUint64Array !== 'undefined') {
  SEMANTIC_TYPES[BigUint64Array.name] = Encoder._pushTypedArray;
}

if (typeof BigInt64Array !== 'undefined') {
  SEMANTIC_TYPES[BigInt64Array.name] = Encoder._pushTypedArray;
}

Encoder.reset();
module.exports = Encoder;