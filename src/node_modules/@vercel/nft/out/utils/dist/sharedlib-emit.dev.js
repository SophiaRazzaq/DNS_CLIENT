"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sharedLibEmit = void 0;

var os_1 = __importDefault(require("os"));

var glob_1 = __importDefault(require("glob"));

var get_package_base_1 = require("./get-package-base");

var sharedlibGlob = '';

switch (os_1["default"].platform()) {
  case 'darwin':
    sharedlibGlob = '/**/*.@(dylib|so?(.*))';
    break;

  case 'win32':
    sharedlibGlob = '/**/*.dll';
    break;

  default:
    sharedlibGlob = '/**/*.so?(.*)';
} // helper for emitting the associated shared libraries when a binary is emitted


function sharedLibEmit(path, job) {
  var pkgPath, files;
  return regeneratorRuntime.async(function sharedLibEmit$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          // console.log('Emitting shared libs for ' + path);
          pkgPath = (0, get_package_base_1.getPackageBase)(path);

          if (pkgPath) {
            _context.next = 3;
            break;
          }

          return _context.abrupt("return");

        case 3:
          _context.next = 5;
          return regeneratorRuntime.awrap(new Promise(function (resolve, reject) {
            return (0, glob_1["default"])(pkgPath + sharedlibGlob, {
              ignore: pkgPath + '/**/node_modules/**/*',
              dot: true
            }, function (err, files) {
              return err ? reject(err) : resolve(files);
            });
          }));

        case 5:
          files = _context.sent;
          _context.next = 8;
          return regeneratorRuntime.awrap(Promise.all(files.map(function (file) {
            return job.emitFile(file, 'sharedlib', path);
          })));

        case 8:
        case "end":
          return _context.stop();
      }
    }
  });
}

exports.sharedLibEmit = sharedLibEmit;