#!/usr/bin/env node
"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var path_1 = require("path");

var graceful_fs_1 = require("graceful-fs");

var _graceful_fs_1$promis = graceful_fs_1.promises,
    copyFile = _graceful_fs_1$promis.copyFile,
    mkdir = _graceful_fs_1$promis.mkdir;

var rimraf = require('rimraf');

var node_file_trace_1 = require("./node-file-trace");

function printStack(file, reasons, stdout, cwd) {
  stdout.push(file);
  var reason = reasons.get(file);

  if (!reason || !reason.parents || reason.type.length === 1 && reason.type.includes('initial') && reason.parents.size === 0) {
    return;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = reason.parents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var parent = _step.value;
      printStack(parent, reasons, stdout, cwd);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}

function cli() {
  var action,
      entrypoint,
      exitpoint,
      outputDir,
      cwd,
      opts,
      _ref,
      fileList,
      esmFileList,
      warnings,
      reasons,
      allFiles,
      stdout,
      _iteratorNormalCompletion2,
      _didIteratorError2,
      _iteratorError2,
      _iterator2,
      _step2,
      warning,
      _iteratorNormalCompletion3,
      _didIteratorError3,
      _iteratorError3,
      _iterator3,
      _step3,
      f,
      src,
      dest,
      dir,
      isSymbolicLink,
      bytes,
      _iteratorNormalCompletion4,
      _didIteratorError4,
      _iteratorError4,
      _iterator4,
      _step4,
      _f,
      lstat,
      stat,
      normalizedExitPoint,
      _args = arguments;

  return regeneratorRuntime.async(function cli$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          action = _args.length > 0 && _args[0] !== undefined ? _args[0] : process.argv[2];
          entrypoint = _args.length > 1 && _args[1] !== undefined ? _args[1] : process.argv[3];
          exitpoint = _args.length > 2 && _args[2] !== undefined ? _args[2] : process.argv[4];
          outputDir = _args.length > 3 && _args[3] !== undefined ? _args[3] : 'dist';
          cwd = _args.length > 4 && _args[4] !== undefined ? _args[4] : process.cwd();
          opts = {
            ts: true,
            base: cwd,
            mixedModules: true,
            log: action == 'print' || action == 'build'
          };
          _context.next = 8;
          return regeneratorRuntime.awrap((0, node_file_trace_1.nodeFileTrace)([entrypoint], opts));

        case 8:
          _ref = _context.sent;
          fileList = _ref.fileList;
          esmFileList = _ref.esmFileList;
          warnings = _ref.warnings;
          reasons = _ref.reasons;
          allFiles = _toConsumableArray(fileList).concat(_toConsumableArray(esmFileList)).sort();
          stdout = [];

          if (!(action === 'print')) {
            _context.next = 42;
            break;
          }

          stdout.push('FILELIST:');
          stdout.push.apply(stdout, _toConsumableArray(allFiles));
          stdout.push('\n');

          if (!(warnings.size > 0)) {
            _context.next = 40;
            break;
          }

          stdout.push('WARNINGS:');
          _iteratorNormalCompletion2 = true;
          _didIteratorError2 = false;
          _iteratorError2 = undefined;
          _context.prev = 24;

          for (_iterator2 = warnings[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            warning = _step2.value;
            stdout.push(warning.toString());
          }

          _context.next = 32;
          break;

        case 28:
          _context.prev = 28;
          _context.t0 = _context["catch"](24);
          _didIteratorError2 = true;
          _iteratorError2 = _context.t0;

        case 32:
          _context.prev = 32;
          _context.prev = 33;

          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }

        case 35:
          _context.prev = 35;

          if (!_didIteratorError2) {
            _context.next = 38;
            break;
          }

          throw _iteratorError2;

        case 38:
          return _context.finish(35);

        case 39:
          return _context.finish(32);

        case 40:
          _context.next = 121;
          break;

        case 42:
          if (!(action === 'build')) {
            _context.next = 77;
            break;
          }

          rimraf.sync((0, path_1.join)(cwd, outputDir));
          _iteratorNormalCompletion3 = true;
          _didIteratorError3 = false;
          _iteratorError3 = undefined;
          _context.prev = 47;
          _iterator3 = allFiles[Symbol.iterator]();

        case 49:
          if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
            _context.next = 61;
            break;
          }

          f = _step3.value;
          src = (0, path_1.join)(cwd, f);
          dest = (0, path_1.join)(cwd, outputDir, f);
          dir = (0, path_1.dirname)(dest);
          _context.next = 56;
          return regeneratorRuntime.awrap(mkdir(dir, {
            recursive: true
          }));

        case 56:
          _context.next = 58;
          return regeneratorRuntime.awrap(copyFile(src, dest));

        case 58:
          _iteratorNormalCompletion3 = true;
          _context.next = 49;
          break;

        case 61:
          _context.next = 67;
          break;

        case 63:
          _context.prev = 63;
          _context.t1 = _context["catch"](47);
          _didIteratorError3 = true;
          _iteratorError3 = _context.t1;

        case 67:
          _context.prev = 67;
          _context.prev = 68;

          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }

        case 70:
          _context.prev = 70;

          if (!_didIteratorError3) {
            _context.next = 73;
            break;
          }

          throw _iteratorError3;

        case 73:
          return _context.finish(70);

        case 74:
          return _context.finish(67);

        case 75:
          _context.next = 121;
          break;

        case 77:
          if (!(action === 'size')) {
            _context.next = 102;
            break;
          }

          isSymbolicLink = function isSymbolicLink(m) {
            return (m & 61440) === 40960;
          };

          bytes = 0;
          _iteratorNormalCompletion4 = true;
          _didIteratorError4 = false;
          _iteratorError4 = undefined;
          _context.prev = 83;

          for (_iterator4 = allFiles[Symbol.iterator](); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            _f = _step4.value;
            lstat = (0, graceful_fs_1.lstatSync)(_f);

            if (isSymbolicLink(lstat.mode)) {
              bytes += lstat.size;
            } else {
              stat = (0, graceful_fs_1.statSync)(_f);
              bytes += stat.size;
            }
          }

          _context.next = 91;
          break;

        case 87:
          _context.prev = 87;
          _context.t2 = _context["catch"](83);
          _didIteratorError4 = true;
          _iteratorError4 = _context.t2;

        case 91:
          _context.prev = 91;
          _context.prev = 92;

          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }

        case 94:
          _context.prev = 94;

          if (!_didIteratorError4) {
            _context.next = 97;
            break;
          }

          throw _iteratorError4;

        case 97:
          return _context.finish(94);

        case 98:
          return _context.finish(91);

        case 99:
          stdout.push("".concat(bytes, " bytes total"));
          _context.next = 121;
          break;

        case 102:
          if (!(action === 'why')) {
            _context.next = 109;
            break;
          }

          if (exitpoint) {
            _context.next = 105;
            break;
          }

          throw new Error('Expected additional argument for "why" action');

        case 105:
          normalizedExitPoint = ((0, path_1.isAbsolute)(exitpoint) ? (0, path_1.relative)(cwd, exitpoint) : exitpoint).replace(/[/\\]/g, path_1.sep);
          printStack(normalizedExitPoint, reasons, stdout, cwd);
          _context.next = 121;
          break;

        case 109:
          stdout.push("\u25B3 nft ".concat(require('../package.json').version));
          stdout.push('');
          stdout.push('Usage:');
          stdout.push('');
          stdout.push("  $ nft [command] <file>");
          stdout.push('');
          stdout.push('Commands:');
          stdout.push('');
          stdout.push('  build [entrypoint]        trace and copy to the dist directory');
          stdout.push('  print [entrypoint]        trace and print to stdout');
          stdout.push('   size [entrypoint]        trace and print size in bytes');
          stdout.push('    why [entrypoint] [file] trace and print stack why file was included');

        case 121:
          return _context.abrupt("return", stdout.join('\n'));

        case 122:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[24, 28, 32, 40], [33,, 35, 39], [47, 63, 67, 75], [68,, 70, 74], [83, 87, 91, 99], [92,, 94, 98]]);
}

if (require.main === module) {
  cli().then(console.log)["catch"](console.error);
}

module.exports = cli;